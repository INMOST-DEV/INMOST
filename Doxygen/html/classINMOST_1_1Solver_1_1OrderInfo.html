<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>INMOST: INMOST::Solver::OrderInfo Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">INMOST
   </div>
   <div id="projectbrief">A toolkit for distributed mathematical modeling</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>INMOST</b></li><li class="navelem"><a class="el" href="classINMOST_1_1Solver.html">Solver</a></li><li class="navelem"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html">OrderInfo</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classINMOST_1_1Solver_1_1OrderInfo-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">INMOST::Solver::OrderInfo Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for low level parallel operations with objects of <a class="el" href="classINMOST_1_1Solver.html" title="Main class to set and solve linear system.">Solver</a> class.  
 <a href="classINMOST_1_1Solver_1_1OrderInfo.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="inmost__solver_8h_source.html">inmost_solver.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a39cb3da0f477eebc9742377ab0e451cc"><td class="memItemLeft" align="right" valign="top"><a id="a39cb3da0f477eebc9742377ab0e451cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#a39cb3da0f477eebc9742377ab0e451cc">Clear</a> ()</td></tr>
<tr class="memdesc:a39cb3da0f477eebc9742377ab0e451cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all structures and data. <br /></td></tr>
<tr class="separator:a39cb3da0f477eebc9742377ab0e451cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2e4998859c13bd156d40ab02c4d099"><td class="memItemLeft" align="right" valign="top"><a id="a7a2e4998859c13bd156d40ab02c4d099"></a>
bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#a7a2e4998859c13bd156d40ab02c4d099">HaveMatrix</a> ()</td></tr>
<tr class="memdesc:a7a2e4998859c13bd156d40ab02c4d099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <a class="el" href="classINMOST_1_1Matrix.html" title="Class for linear algebra operations on dense matrices.">Matrix</a> data have already been specified. <br /></td></tr>
<tr class="separator:a7a2e4998859c13bd156d40ab02c4d099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f63dbc4c8f7f9e455e7d79272066e4"><td class="memItemLeft" align="right" valign="top"><a id="ae9f63dbc4c8f7f9e455e7d79272066e4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#ae9f63dbc4c8f7f9e455e7d79272066e4">OrderInfo</a> ()</td></tr>
<tr class="memdesc:ae9f63dbc4c8f7f9e455e7d79272066e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default initialize all structures. <br /></td></tr>
<tr class="separator:ae9f63dbc4c8f7f9e455e7d79272066e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ac0fe0f430301dab083aff8e241873"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#a85ac0fe0f430301dab083aff8e241873">OrderInfo</a> (const <a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html">OrderInfo</a> &amp;other)</td></tr>
<tr class="memdesc:a85ac0fe0f430301dab083aff8e241873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all structures.  <a href="classINMOST_1_1Solver_1_1OrderInfo.html#a85ac0fe0f430301dab083aff8e241873">More...</a><br /></td></tr>
<tr class="separator:a85ac0fe0f430301dab083aff8e241873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d57307d3179f786d8a6fdc4948bc03b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html">OrderInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#a3d57307d3179f786d8a6fdc4948bc03b">operator=</a> (<a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html">OrderInfo</a> const &amp;other)</td></tr>
<tr class="memdesc:a3d57307d3179f786d8a6fdc4948bc03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign all structures.  <a href="classINMOST_1_1Solver_1_1OrderInfo.html#a3d57307d3179f786d8a6fdc4948bc03b">More...</a><br /></td></tr>
<tr class="separator:a3d57307d3179f786d8a6fdc4948bc03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9a9e09a0040626256975e2ff990e58"><td class="memItemLeft" align="right" valign="top"><a id="a4d9a9e09a0040626256975e2ff990e58"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#a4d9a9e09a0040626256975e2ff990e58">~OrderInfo</a> ()</td></tr>
<tr class="memdesc:a4d9a9e09a0040626256975e2ff990e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all data. <br /></td></tr>
<tr class="separator:a4d9a9e09a0040626256975e2ff990e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9cbb7c44206d57c9ee4e12b8334b61b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#ac9cbb7c44206d57c9ee4e12b8334b61b">PrepareMatrix</a> (<a class="el" href="classINMOST_1_1Sparse_1_1Matrix.html">Sparse::Matrix</a> &amp;m, INMOST_DATA_ENUM_TYPE overlap)</td></tr>
<tr class="memdesc:ac9cbb7c44206d57c9ee4e12b8334b61b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare parallel state of the <a class="el" href="classINMOST_1_1Matrix.html" title="Class for linear algebra operations on dense matrices.">Matrix</a> with specified overlap size.  <a href="classINMOST_1_1Solver_1_1OrderInfo.html#ac9cbb7c44206d57c9ee4e12b8334b61b">More...</a><br /></td></tr>
<tr class="separator:ac9cbb7c44206d57c9ee4e12b8334b61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f028a3332d53adf7cbb518e0374791"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#a65f028a3332d53adf7cbb518e0374791">RestoreMatrix</a> (<a class="el" href="classINMOST_1_1Sparse_1_1Matrix.html">Sparse::Matrix</a> &amp;m)</td></tr>
<tr class="memdesc:a65f028a3332d53adf7cbb518e0374791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore initial nonparallel state of the <a class="el" href="classINMOST_1_1Matrix.html" title="Class for linear algebra operations on dense matrices.">Matrix</a> with no overlap.  <a href="classINMOST_1_1Solver_1_1OrderInfo.html#a65f028a3332d53adf7cbb518e0374791">More...</a><br /></td></tr>
<tr class="separator:a65f028a3332d53adf7cbb518e0374791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84453535933b64f3603052e0f944b624"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#a84453535933b64f3603052e0f944b624">PrepareVector</a> (<a class="el" href="classINMOST_1_1Sparse_1_1Vector.html">Sparse::Vector</a> &amp;v) const</td></tr>
<tr class="memdesc:a84453535933b64f3603052e0f944b624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare parallel state of the Vector.  <a href="classINMOST_1_1Solver_1_1OrderInfo.html#a84453535933b64f3603052e0f944b624">More...</a><br /></td></tr>
<tr class="separator:a84453535933b64f3603052e0f944b624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea0e89403dac5d0bc15538f0f9c3122"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#a4ea0e89403dac5d0bc15538f0f9c3122">RestoreVector</a> (<a class="el" href="classINMOST_1_1Sparse_1_1Vector.html">Sparse::Vector</a> &amp;v) const</td></tr>
<tr class="memdesc:a4ea0e89403dac5d0bc15538f0f9c3122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore initial nonparallel state of the Vector.  <a href="classINMOST_1_1Solver_1_1OrderInfo.html#a4ea0e89403dac5d0bc15538f0f9c3122">More...</a><br /></td></tr>
<tr class="separator:a4ea0e89403dac5d0bc15538f0f9c3122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063238f671f4e5ae5238c057d57eea12"><td class="memItemLeft" align="right" valign="top">INMOST_DATA_ENUM_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#a063238f671f4e5ae5238c057d57eea12">GetProcessor</a> (INMOST_DATA_ENUM_TYPE gind) const</td></tr>
<tr class="memdesc:a063238f671f4e5ae5238c057d57eea12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the processor number by binary search for the specified global index.  <a href="classINMOST_1_1Solver_1_1OrderInfo.html#a063238f671f4e5ae5238c057d57eea12">More...</a><br /></td></tr>
<tr class="separator:a063238f671f4e5ae5238c057d57eea12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb3765326341cfafd49905f92734dc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#adbb3765326341cfafd49905f92734dc1">GetOverlapRegion</a> (INMOST_DATA_ENUM_TYPE proc, INMOST_DATA_ENUM_TYPE &amp;mbeg, INMOST_DATA_ENUM_TYPE &amp;mend) const</td></tr>
<tr class="memdesc:adbb3765326341cfafd49905f92734dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the overlap index region for the specified processor.  <a href="classINMOST_1_1Solver_1_1OrderInfo.html#adbb3765326341cfafd49905f92734dc1">More...</a><br /></td></tr>
<tr class="separator:adbb3765326341cfafd49905f92734dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642845d6da9336439428e08d46e1a987"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#a642845d6da9336439428e08d46e1a987">GetLocalRegion</a> (INMOST_DATA_ENUM_TYPE proc, INMOST_DATA_ENUM_TYPE &amp;mbeg, INMOST_DATA_ENUM_TYPE &amp;mend) const</td></tr>
<tr class="memdesc:a642845d6da9336439428e08d46e1a987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local index region for the specified processor.  <a href="classINMOST_1_1Solver_1_1OrderInfo.html#a642845d6da9336439428e08d46e1a987">More...</a><br /></td></tr>
<tr class="separator:a642845d6da9336439428e08d46e1a987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec1229b99019b2519b1ca5cd373f573"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#aeec1229b99019b2519b1ca5cd373f573">GetVectorRegion</a> (INMOST_DATA_ENUM_TYPE &amp;mbeg, INMOST_DATA_ENUM_TYPE &amp;mend) const</td></tr>
<tr class="memdesc:aeec1229b99019b2519b1ca5cd373f573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local index region for the current processor.  <a href="classINMOST_1_1Solver_1_1OrderInfo.html#aeec1229b99019b2519b1ca5cd373f573">More...</a><br /></td></tr>
<tr class="separator:aeec1229b99019b2519b1ca5cd373f573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3f6f39997d4f6e49c4e3014806bbf1"><td class="memItemLeft" align="right" valign="top"><a id="a3a3f6f39997d4f6e49c4e3014806bbf1"></a>
INMOST_DATA_ENUM_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#a3a3f6f39997d4f6e49c4e3014806bbf1">GetRank</a> () const</td></tr>
<tr class="memdesc:a3a3f6f39997d4f6e49c4e3014806bbf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rank of the current communicator, i.e. the current process index. <br /></td></tr>
<tr class="separator:a3a3f6f39997d4f6e49c4e3014806bbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff690626a1a57e5b79e01a1193c8b3d2"><td class="memItemLeft" align="right" valign="top"><a id="aff690626a1a57e5b79e01a1193c8b3d2"></a>
INMOST_DATA_ENUM_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#aff690626a1a57e5b79e01a1193c8b3d2">GetSize</a> () const</td></tr>
<tr class="memdesc:aff690626a1a57e5b79e01a1193c8b3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the current communicator, i.e. the total number of processes used. <br /></td></tr>
<tr class="separator:aff690626a1a57e5b79e01a1193c8b3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c65de0fdad35137a4fc6c10a847d768"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#a4c65de0fdad35137a4fc6c10a847d768">Update</a> (<a class="el" href="classINMOST_1_1Sparse_1_1Vector.html">Sparse::Vector</a> &amp;x)</td></tr>
<tr class="memdesc:a4c65de0fdad35137a4fc6c10a847d768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the shared data in parallel vector.  <a href="classINMOST_1_1Solver_1_1OrderInfo.html#a4c65de0fdad35137a4fc6c10a847d768">More...</a><br /></td></tr>
<tr class="separator:a4c65de0fdad35137a4fc6c10a847d768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1db2e20d7d54fafeb191a535adfe0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#acc1db2e20d7d54fafeb191a535adfe0c">Accumulate</a> (<a class="el" href="classINMOST_1_1Sparse_1_1Vector.html">Sparse::Vector</a> &amp;x)</td></tr>
<tr class="memdesc:acc1db2e20d7d54fafeb191a535adfe0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum shared values in parallel vector.  <a href="classINMOST_1_1Solver_1_1OrderInfo.html#acc1db2e20d7d54fafeb191a535adfe0c">More...</a><br /></td></tr>
<tr class="separator:acc1db2e20d7d54fafeb191a535adfe0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88ff641559bcaf1525e52099d44d9d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#ac88ff641559bcaf1525e52099d44d9d6">Integrate</a> (INMOST_DATA_REAL_TYPE *inout, INMOST_DATA_ENUM_TYPE num) const</td></tr>
<tr class="memdesc:ac88ff641559bcaf1525e52099d44d9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sum of num elements of real array on all processes.  <a href="classINMOST_1_1Solver_1_1OrderInfo.html#ac88ff641559bcaf1525e52099d44d9d6">More...</a><br /></td></tr>
<tr class="separator:ac88ff641559bcaf1525e52099d44d9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05bad618988a906be884f5a577864ea2"><td class="memItemLeft" align="right" valign="top"><a id="a05bad618988a906be884f5a577864ea2"></a>
INMOST_MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#a05bad618988a906be884f5a577864ea2">GetComm</a> () const</td></tr>
<tr class="memdesc:a05bad618988a906be884f5a577864ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the communicator which the solver is associated with. <br /></td></tr>
<tr class="separator:a05bad618988a906be884f5a577864ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4e243c601d87a4be072c2fc8c1a3c9"><td class="memItemLeft" align="right" valign="top">INMOST_MPI_Request *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#a0e4e243c601d87a4be072c2fc8c1a3c9">GetSendRequests</a> ()</td></tr>
<tr class="memdesc:a0e4e243c601d87a4be072c2fc8c1a3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI structures that hold information on sent data.  <a href="classINMOST_1_1Solver_1_1OrderInfo.html#a0e4e243c601d87a4be072c2fc8c1a3c9">More...</a><br /></td></tr>
<tr class="separator:a0e4e243c601d87a4be072c2fc8c1a3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb17df8429be00a1a9489d44a04645e"><td class="memItemLeft" align="right" valign="top">INMOST_MPI_Request *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#a9fb17df8429be00a1a9489d44a04645e">GetRecvRequests</a> ()</td></tr>
<tr class="memdesc:a9fb17df8429be00a1a9489d44a04645e"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI structures that hold information on posted receive requests.  <a href="classINMOST_1_1Solver_1_1OrderInfo.html#a9fb17df8429be00a1a9489d44a04645e">More...</a><br /></td></tr>
<tr class="separator:a9fb17df8429be00a1a9489d44a04645e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0bac5fba6d238cb22a76c2094a5f48"><td class="memItemLeft" align="right" valign="top"><a id="a3f0bac5fba6d238cb22a76c2094a5f48"></a>
INMOST_DATA_ENUM_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#a3f0bac5fba6d238cb22a76c2094a5f48">GetSendRequestsSize</a> ()</td></tr>
<tr class="memdesc:a3f0bac5fba6d238cb22a76c2094a5f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of send requests. <br /></td></tr>
<tr class="separator:a3f0bac5fba6d238cb22a76c2094a5f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae766d3d64dc46603feb600e1f19105c5"><td class="memItemLeft" align="right" valign="top"><a id="ae766d3d64dc46603feb600e1f19105c5"></a>
INMOST_DATA_ENUM_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#ae766d3d64dc46603feb600e1f19105c5">GetRecvRequestsSize</a> ()</td></tr>
<tr class="memdesc:ae766d3d64dc46603feb600e1f19105c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of posted receive requests. <br /></td></tr>
<tr class="separator:ae766d3d64dc46603feb600e1f19105c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3df60e1a4c9e016aef33a800e048dce"><td class="memItemLeft" align="right" valign="top"><a id="ad3df60e1a4c9e016aef33a800e048dce"></a>
INMOST_DATA_ENUM_TYPE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#ad3df60e1a4c9e016aef33a800e048dce">GetSendExchangeArray</a> ()</td></tr>
<tr class="memdesc:ad3df60e1a4c9e016aef33a800e048dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request raw access to array used to send data. <br /></td></tr>
<tr class="separator:ad3df60e1a4c9e016aef33a800e048dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8c8c157fbdb8609047cad5a18407ea"><td class="memItemLeft" align="right" valign="top"><a id="acb8c8c157fbdb8609047cad5a18407ea"></a>
INMOST_DATA_ENUM_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#acb8c8c157fbdb8609047cad5a18407ea">GetSendExchangeSize</a> ()</td></tr>
<tr class="memdesc:acb8c8c157fbdb8609047cad5a18407ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the array used to send data. <br /></td></tr>
<tr class="separator:acb8c8c157fbdb8609047cad5a18407ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ba99d91a554c149d20f1cbbcb9afee"><td class="memItemLeft" align="right" valign="top"><a id="a90ba99d91a554c149d20f1cbbcb9afee"></a>
INMOST_DATA_ENUM_TYPE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#a90ba99d91a554c149d20f1cbbcb9afee">GetRecvExchangeArray</a> ()</td></tr>
<tr class="memdesc:a90ba99d91a554c149d20f1cbbcb9afee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request raw acces to array used to receive data. <br /></td></tr>
<tr class="separator:a90ba99d91a554c149d20f1cbbcb9afee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786492332f92c61da93e69864e173f4a"><td class="memItemLeft" align="right" valign="top"><a id="a786492332f92c61da93e69864e173f4a"></a>
INMOST_DATA_ENUM_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html#a786492332f92c61da93e69864e173f4a">GetRecvExchangeSize</a> ()</td></tr>
<tr class="memdesc:a786492332f92c61da93e69864e173f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the array used to receive data. <br /></td></tr>
<tr class="separator:a786492332f92c61da93e69864e173f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for low level parallel operations with objects of <a class="el" href="classINMOST_1_1Solver.html" title="Main class to set and solve linear system.">Solver</a> class. </p>
<p>This class auguments the matrix with additional layers of overlap for Additive Schwartz method to work. Also allows to expand vectors according to new matrix size and to organize vector data exchange in both directions. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a85ac0fe0f430301dab083aff8e241873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ac0fe0f430301dab083aff8e241873">&#9670;&nbsp;</a></span>OrderInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INMOST::Solver::OrderInfo::OrderInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html">OrderInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy all structures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Right hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acc1db2e20d7d54fafeb191a535adfe0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1db2e20d7d54fafeb191a535adfe0c">&#9670;&nbsp;</a></span>Accumulate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Solver::OrderInfo::Accumulate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Sparse_1_1Vector.html">Sparse::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum shared values in parallel vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector for which the shared data should be accumulated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a642845d6da9336439428e08d46e1a987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642845d6da9336439428e08d46e1a987">&#9670;&nbsp;</a></span>GetLocalRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Solver::OrderInfo::GetLocalRegion </td>
          <td>(</td>
          <td class="paramtype">INMOST_DATA_ENUM_TYPE&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INMOST_DATA_ENUM_TYPE &amp;&#160;</td>
          <td class="paramname"><em>mbeg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INMOST_DATA_ENUM_TYPE &amp;&#160;</td>
          <td class="paramname"><em>mend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local index region for the specified processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>Processor number. </td></tr>
    <tr><td class="paramname">mbeg</td><td>Record the first index here. </td></tr>
    <tr><td class="paramname">mbeg</td><td>Record the last index here. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbb3765326341cfafd49905f92734dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb3765326341cfafd49905f92734dc1">&#9670;&nbsp;</a></span>GetOverlapRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Solver::OrderInfo::GetOverlapRegion </td>
          <td>(</td>
          <td class="paramtype">INMOST_DATA_ENUM_TYPE&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INMOST_DATA_ENUM_TYPE &amp;&#160;</td>
          <td class="paramname"><em>mbeg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INMOST_DATA_ENUM_TYPE &amp;&#160;</td>
          <td class="paramname"><em>mend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the overlap index region for the specified processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>Processor number. </td></tr>
    <tr><td class="paramname">mbeg</td><td>Record the first index here. </td></tr>
    <tr><td class="paramname">mbeg</td><td>Record the last index here. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a063238f671f4e5ae5238c057d57eea12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063238f671f4e5ae5238c057d57eea12">&#9670;&nbsp;</a></span>GetProcessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INMOST_DATA_ENUM_TYPE INMOST::Solver::OrderInfo::GetProcessor </td>
          <td>(</td>
          <td class="paramtype">INMOST_DATA_ENUM_TYPE&#160;</td>
          <td class="paramname"><em>gind</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the processor number by binary search for the specified global index. </p>
<p>Finds the processor that contains provided index in it's interval of indices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gind</td><td>Global index in the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fb17df8429be00a1a9489d44a04645e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb17df8429be00a1a9489d44a04645e">&#9670;&nbsp;</a></span>GetRecvRequests()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INMOST_MPI_Request* INMOST::Solver::OrderInfo::GetRecvRequests </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>MPI structures that hold information on posted receive requests. </p>
<p>Access to MPI structures that allow for asynchronous exchange of data. </p>

</div>
</div>
<a id="a0e4e243c601d87a4be072c2fc8c1a3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4e243c601d87a4be072c2fc8c1a3c9">&#9670;&nbsp;</a></span>GetSendRequests()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INMOST_MPI_Request* INMOST::Solver::OrderInfo::GetSendRequests </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>MPI structures that hold information on sent data. </p>
<p>Access to MPI structures that allow for asynchronous exchange of data. </p>

</div>
</div>
<a id="aeec1229b99019b2519b1ca5cd373f573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec1229b99019b2519b1ca5cd373f573">&#9670;&nbsp;</a></span>GetVectorRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Solver::OrderInfo::GetVectorRegion </td>
          <td>(</td>
          <td class="paramtype">INMOST_DATA_ENUM_TYPE &amp;&#160;</td>
          <td class="paramname"><em>mbeg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INMOST_DATA_ENUM_TYPE &amp;&#160;</td>
          <td class="paramname"><em>mend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local index region for the current processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mbeg</td><td>Record the first index here. </td></tr>
    <tr><td class="paramname">mbeg</td><td>Record the last index here. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac88ff641559bcaf1525e52099d44d9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88ff641559bcaf1525e52099d44d9d6">&#9670;&nbsp;</a></span>Integrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Solver::OrderInfo::Integrate </td>
          <td>(</td>
          <td class="paramtype">INMOST_DATA_REAL_TYPE *&#160;</td>
          <td class="paramname"><em>inout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INMOST_DATA_ENUM_TYPE&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sum of num elements of real array on all processes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inout</td><td>Data that should be integrated. </td></tr>
    <tr><td class="paramname">num</td><td>Number of entries in inout array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d57307d3179f786d8a6fdc4948bc03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d57307d3179f786d8a6fdc4948bc03b">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html">OrderInfo</a>&amp; INMOST::Solver::OrderInfo::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Solver_1_1OrderInfo.html">OrderInfo</a> const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign all structures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Right hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9cbb7c44206d57c9ee4e12b8334b61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9cbb7c44206d57c9ee4e12b8334b61b">&#9670;&nbsp;</a></span>PrepareMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Solver::OrderInfo::PrepareMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Sparse_1_1Matrix.html">Sparse::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INMOST_DATA_ENUM_TYPE&#160;</td>
          <td class="paramname"><em>overlap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare parallel state of the <a class="el" href="classINMOST_1_1Matrix.html" title="Class for linear algebra operations on dense matrices.">Matrix</a> with specified overlap size. </p>
<p>This state of the matrix can be used, for instance, to construct the preconditioner for Additive Swartz method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td><a class="el" href="classINMOST_1_1Matrix.html" title="Class for linear algebra operations on dense matrices.">Matrix</a> to be expanded. </td></tr>
    <tr><td class="paramname">overlap</td><td>Overlap size, viz. the number of overlap layers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84453535933b64f3603052e0f944b624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84453535933b64f3603052e0f944b624">&#9670;&nbsp;</a></span>PrepareVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Solver::OrderInfo::PrepareVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Sparse_1_1Vector.html">Sparse::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare parallel state of the Vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector to be expanded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65f028a3332d53adf7cbb518e0374791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f028a3332d53adf7cbb518e0374791">&#9670;&nbsp;</a></span>RestoreMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Solver::OrderInfo::RestoreMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Sparse_1_1Matrix.html">Sparse::Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore initial nonparallel state of the <a class="el" href="classINMOST_1_1Matrix.html" title="Class for linear algebra operations on dense matrices.">Matrix</a> with no overlap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td><a class="el" href="classINMOST_1_1Matrix.html" title="Class for linear algebra operations on dense matrices.">Matrix</a> to be restored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ea0e89403dac5d0bc15538f0f9c3122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea0e89403dac5d0bc15538f0f9c3122">&#9670;&nbsp;</a></span>RestoreVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Solver::OrderInfo::RestoreVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Sparse_1_1Vector.html">Sparse::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore initial nonparallel state of the Vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector to be restored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c65de0fdad35137a4fc6c10a847d768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c65de0fdad35137a4fc6c10a847d768">&#9670;&nbsp;</a></span>Update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Solver::OrderInfo::Update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Sparse_1_1Vector.html">Sparse::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the shared data in parallel vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector for which the shared data should be updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="inmost__solver_8h_source.html">inmost_solver.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 14 2023 19:52:29 for INMOST by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.1
</small></address>
</body>
</html>
