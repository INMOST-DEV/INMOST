<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>INMOST: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">INMOST
   </div>
   <div id="projectbrief">A toolkit for distributed mathematical modeling</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt>Class <a class="el" href="classINMOST_1_1AbstractEntry.html">INMOST::AbstractEntry</a>  </dt>
<dd><a class="anchor" id="_todo000001"></a><ol type="1">
<li>Is there a need for layout on how matrices are returned?</li>
<li>Is there a need for layout on how unknowns and equations are arranged?</li>
<li>Function for update of variables.</li>
<li>Function for synchronization of variables.  </li>
</ol>
</dd>
<dt>Member <a class="el" href="classINMOST_1_1AbstractMatrix.html#ab44ab543a9b322f7b5931fc06cd7c519">INMOST::AbstractMatrix&lt; Var &gt;::MPT</a>  (INMOST_DATA_ENUM_TYPE *Perm, INMOST_DATA_REAL_TYPE *SL=NULL, INMOST_DATA_REAL_TYPE *SR=NULL) const</dt>
<dd><a class="anchor" id="_todo000011"></a><ol type="1">
<li>Test rescaling.</li>
<li>Test on non-square matrices.  </li>
</ol>
</dd>
<dt>Member <a class="el" href="classINMOST_1_1AbstractMatrixReadOnly.html#a6767f3132b8b8d2e58a815e9b18c3c36">INMOST::AbstractMatrixReadOnly&lt; Var &gt;::Invert</a>  (int *ierr=NULL) const</dt>
<dd><a class="anchor" id="_todo000009"></a>(test) Activate and test implementation with Solve.  </dd>
<dt>Member <a class="el" href="classINMOST_1_1AbstractMatrixReadOnly.html#af2b56b9efc1914d501db1bed4a26af4b">INMOST::AbstractMatrixReadOnly&lt; Var &gt;::Solve</a>  (const AbstractMatrixReadOnly&lt; typeB &gt; &amp;B, int *ierr=NULL) const</dt>
<dd><a class="anchor" id="_todo000010"></a><ol type="1">
<li>Test implementation.</li>
<li>Maximum product transversal + block pivoting instead of pivoting by maximum element.  </li>
</ol>
</dd>
<dt>Member <a class="el" href="classINMOST_1_1AbstractMatrixReadOnly.html#a954bd927dd3ac52651ba5d43d0d79100">INMOST::AbstractMatrixReadOnly&lt; Var &gt;::SVD</a>  (AbstractMatrix&lt; Var &gt; &amp;U, AbstractMatrix&lt; Var &gt; &amp;Sigma, AbstractMatrix&lt; Var &gt; &amp;V, bool order_singular_values=true, bool nonnegative=true) const</dt>
<dd><a class="anchor" id="_todo000008"></a>Test implementation for auto-differentiation.  </dd>
<dt>Class <a class="el" href="classINMOST_1_1AbstractOperator.html">INMOST::AbstractOperator</a>  </dt>
<dd><a class="anchor" id="_todo000042"></a><ol type="1">
<li>Different types of operators: time-stepping, local point-wise (curl,grad on element), global integrators (div,curl on domain), interpolators, inter-mesh interpolators. Each has its own functions. Implementation should be flexible enough to prevent limitation.</li>
<li>Ultimately operators should stack together: for staggered incompressible navier-stokes: Time(nU) + Projection(Divergence(ConvectionDiffusion(nU,\mu,Reconstruction(nU)))) - Grad(P) = f Divergence(nU) = 0  </li>
</ol>
</dd>
<dt>Class <a class="el" href="classINMOST_1_1Automatizator.html">INMOST::Automatizator</a>  </dt>
<dd><a class="anchor" id="_todo000004"></a><ol type="1">
<li>(test) UnRegisterTag.</li>
<li>(test) Copy constructor.</li>
<li>Rename  </li>
</ol>
</dd>
<dt>Member <a class="el" href="classINMOST_1_1Cell.html#ad70836c77e9c4495463feecfb044ccbc">INMOST::Cell::CheckEdgeOrder</a>  () const</dt>
<dd><a class="anchor" id="_todo000022"></a><ol type="1">
<li>Use in topology check algorithms.  </li>
</ol>
</dd>
<dt>Member <a class="el" href="classINMOST_1_1Cell.html#a177f2b65dc915cfe947228376549de71">INMOST::Cell::FixEdgeOrder</a>  () const</dt>
<dd><a class="anchor" id="_todo000023"></a><ol type="1">
<li>Use in topology check algorithms.  </li>
</ol>
</dd>
<dt>Member <a class="el" href="classINMOST_1_1Cell.html#ae434acd05c8b1a23850b2363f728a221">INMOST::Cell::getEdges</a>  () const</dt>
<dd><a class="anchor" id="_todo000021"></a> One should thoroughly check three scenarios of function execution in shared parallel environment for different types of cells (simple tet/hex cells as well as complex polyhedral cells) and draw a conclusion on the best scenario for each condition. One of the development versions contains all the algorithms, ask for the files.<ol type="1">
<li>Use of markers (current variant).</li>
<li>Put all elements into array with duplications, then run std::sort and std::unique.</li>
<li>Put all elements into array, check for duplication by running through array. </li>
</ol>
</dd>
<dt>Member <a class="el" href="classINMOST_1_1Cell.html#a02e0510ca7648aa61f9858321564cdb3">INMOST::Cell::Inside</a>  (const real *point) const</dt>
<dd><a class="anchor" id="_todo000025"></a><ol type="1">
<li>Should be checked or extended for 2d cells. (done, testing)  </li>
</ol>
</dd>
<dt>Member <a class="el" href="classINMOST_1_1Cell.html#afd127d2e41a4b4362dc3399d9ac96a59">INMOST::Cell::SplitCell</a>  (<a class="el" href="classINMOST_1_1Cell.html" title="An interface for elements of type CELL.">Cell</a> cell, const ElementArray&lt; Face &gt; &amp;faces, MarkerType del_protect)</dt>
<dd><a class="anchor" id="_todo000024"></a><ol type="1">
<li>The algorithm inside is minimizing the size of the adjacency graph for each new cell. The correct behavior is to calculate volume of the cell for each adjacency graph and choose the graph with minimal volume. This requires calculation of volume for non-convex cells. For correct calculation of volume on non-convex cells one should find one face for which normal orientation can be clearly determined and then orient all edges of the cell with respect to the orientation of edges of this face and establish normals for all faces. Once the algorithm is implemented here it should be implemented in geometrical services or vice verse.</li>
<li>Probably the algorithm should minimize the volume and adjacency graph size altogether. Between the cells with smallest volume within some tolerance select those that have smallest adjacency graph.  </li>
</ol>
</dd>
<dt>Member <a class="el" href="classINMOST_1_1Cell.html#a97b75dfe626e83807ebee898f741fcc6">INMOST::Cell::Volume</a>  () const</dt>
<dd><a class="anchor" id="_todo000026"></a><ol type="1">
<li>Geometric services should correctly resolve volume for non-convex cells.  </li>
</ol>
</dd>
<dt>Member <a class="el" href="classINMOST_1_1Element.html#a7721dd76bb34cbea608045406e3e21b4">INMOST::Element::Connect</a>  (const HandleType *adjacent, INMOST_DATA_ENUM_TYPE num) const</dt>
<dd><a class="anchor" id="_todo000020"></a><ol type="1">
<li>Asserts in this function should be replaced by Topography checks.</li>
<li>This function should be used for construction of elements instead of current implementation.</li>
<li>Should correctly account for order of edges (may be implemented through CheckEdgeOrder, FixEdgeOrder).  </li>
</ol>
</dd>
<dt>Member <a class="el" href="classINMOST_1_1Element.html#a2c25f1b5ef80d9e0dc99d15dba739cfe">INMOST::Element::Hide</a>  () const</dt>
<dd><a class="anchor" id="_todo000018"></a>Probably have to check normal orientation after hiding a back cell for a face.  </dd>
<dt>Member <a class="el" href="classINMOST_1_1Element.html#acdd0a46d9574328ff63af29a9cffb309">INMOST::Element::Show</a>  () const</dt>
<dd><a class="anchor" id="_todo000019"></a>Probably have to check normal orientation after recovering a back cell for a face.  </dd>
<dt>Member <a class="el" href="classINMOST_1_1ElementSet.html#a272ff54d48a7468ca7f8c305fa4ef779">INMOST::ElementSet::AddElements</a>  (const HandleType *handles, enumerator num) const</dt>
<dd><a class="anchor" id="_todo000027"></a>Recheck usage of markers.  </dd>
<dt>Member <a class="el" href="classINMOST_1_1ElementSet.html#a6f72cec074a16523861a5e3383b51c8c">INMOST::ElementSet::SortSet</a>  (ComparatorType comp) const</dt>
<dd><a class="anchor" id="_todo000029"></a> !TODO 52 - check radix sort on big endian computer  </dd>
<dt>Member <a class="el" href="classINMOST_1_1ElementSet.html#a211931a21ead13068d10c23540655259">INMOST::ElementSet::Subtract</a>  (const <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> &amp;other) const</dt>
<dd><a class="anchor" id="_todo000028"></a> If other and current sets are sorted in same way, may perform narrowing traversal by retrieving mutual lower_bound/higher_bound O(log(n)) operations for detecting common subsets in sorted sets. May work good when deleting handles by small chunks, ApplyModification may greatly benefit.  </dd>
<dt>Class <a class="el" href="classINMOST_1_1Matrix.html">INMOST::Matrix&lt; Var, storage_type &gt;</a>  </dt>
<dd><a class="anchor" id="_todo000007"></a>:<ol type="1">
<li>expression templates for operations (???) how to for multiplication? efficient multiplication would require all the matrix elements to be precomputed. consider number 5 instead.</li>
<li>(ok) template matrix type for AD variables</li>
<li>(ok,test) template container type for data storage.</li>
<li>(ok,test) option for wrapper container around provided data storage. (to perform matrix operations with existing data)</li>
<li>consider multi-threaded stack to get space for matrices for local operations and returns.</li>
<li>class <a class="el" href="classINMOST_1_1SubMatrix.html" title="This class allows for in-place operations on submatrix of the matrix elements.">SubMatrix</a> for fortran-like access to matrix.</li>
<li>Uniform implementation of algorithms for <a class="el" href="classINMOST_1_1Matrix.html" title="Class for linear algebra operations on dense matrices.">Matrix</a> and Submatrix. to achieve: make abdstract class with abstract element access operator, make matrix and submatrix ancestors of that class  </li>
</ol>
</dd>
<dt>Member <a class="el" href="classINMOST_1_1Matrix.html#a9f8220283374e29ba006d8a6159dfb18">INMOST::Matrix&lt; Var, storage_type &gt;::Matrix</a>  (const storage_type &amp;pspace, enumerator pn, enumerator pm)</dt>
<dd><a class="anchor" id="_todo000016"></a>Do we need reference for pspace or just pspace?  </dd>
<dt>Member <a class="el" href="classINMOST_1_1Matrix.html#a3819814cacb9e8692b3242cf50dabf52">INMOST::Matrix&lt; Var, storage_type &gt;::Matrix</a>  (const storage_type &amp;pspace)</dt>
<dd><a class="anchor" id="_todo000017"></a>Do we need reference for pspace or just pspace?  </dd>
<dt>Member <a class="el" href="classINMOST_1_1Matrix.html#a69ffa4c7ed7c4dcd7e6e555c4d9bf067">INMOST::Matrix&lt; Var, storage_type &gt;::RemoveColumns</a>  (enumerator first, enumerator last)</dt>
<dd><a class="anchor" id="_todo000015"></a>check  </dd>
<dt>Member <a class="el" href="classINMOST_1_1Matrix.html#a186baf212a878782ec88bf2407e0b77f">INMOST::Matrix&lt; Var, storage_type &gt;::RemoveRows</a>  (enumerator first, enumerator last)</dt>
<dd><a class="anchor" id="_todo000014"></a>check  </dd>
<dt>Member <a class="el" href="classINMOST_1_1Mesh.html#a1f53070855f3503b2f4cefc16cedd6a0">INMOST::Mesh::ApplyModification</a>  ()</dt>
<dd><a class="anchor" id="_todo000038"></a><ol type="1">
<li>maybe instead of forming set of deleted elements and subtracting set from other sets it is better to remove each modified element (done, check and compare)</li>
<li>parent/child elements in set would not be replaced or reconnected, this may lead to wrong behavior (done, check and compare)  </li>
</ol>
</dd>
<dt>Member <a class="el" href="classINMOST_1_1Mesh.html#ae39e30b11f35de81d2a9b8451ef87391">INMOST::Mesh::AssignGlobalID</a>  (ElementType mask)</dt>
<dd><a class="anchor" id="_todo000031"></a><ol type="1">
<li>invoking function before loading mesh will not renew global identificators after load but would not unset have_global_id either. There are probably too many places when global ids may become invalid but no flag will be set. It may be benefitial to set such flags along with updating geometrical data which seems to be maintained fairly well during mesh modification  </li>
</ol>
</dd>
<dt>Member <a class="el" href="classINMOST_1_1Mesh.html#a55549e9d46cd92e2f3122e1516f3c9fd">INMOST::Mesh::BeginTopologyCheck</a>  (ElementType etype, const HandleType *adj, enumerator num)</dt>
<dd><a class="anchor" id="_todo000039"></a> list checks performed inside in description  </dd>
<dt>Member <a class="el" href="classINMOST_1_1Mesh.html#a97177e1b6f8fe810eb5d072fb378b22e">INMOST::Mesh::EndTopologyCheck</a>  (HandleType e, TopologyCheck begin_check)</dt>
<dd><a class="anchor" id="_todo000040"></a> list checks performed inside in description.  </dd>
<dt>Member <a class="el" href="classINMOST_1_1Mesh.html#a0f3d0cb9965d12635cc2df7ad458661a">INMOST::Mesh::ExchangeData</a>  (const <a class="el" href="classINMOST_1_1Tag.html" title="This class provides the access to the individual mesh datum and general information about it.">Tag</a> &amp;tag, ElementType mask, MarkerType select=0)</dt>
<dd><a class="anchor" id="_todo000032"></a> see TODO in <a class="el" href="classINMOST_1_1Mesh.html#a2d488479041917c975b1e662d642c4a5" title="Accumulation of data from ghost elements to shared elements.">Mesh::ReduceData</a> </dd>
<dt>Member <a class="el" href="classINMOST_1_1Mesh.html#ae44b9cfcb8964acbd710562df331a51a">INMOST::Mesh::ExchangeMarked</a>  (enum Action action=AGhost)</dt>
<dd><a class="anchor" id="_todo000034"></a><ol type="1">
<li>test halo exchange algorithm (if used then change collective point-2-point to collective)</li>
<li>see TODO 2 in <a class="el" href="classINMOST_1_1Mesh.html#ade20ec7c8563e82bf8057bc47a3314b7" title="Migrate all the elements to the new owners prescribed in data corresponding to RedistributeTag.">Mesh::Redistribute</a> </li>
</ol>
</dd>
<dt>Member <a class="el" href="classINMOST_1_1Mesh.html#a5dfd481d638b2d2d72193b4b8fa159a4">INMOST::Mesh::Load</a>  (std::string File)</dt>
<dd><a class="anchor" id="_todo000036"></a><ol type="1">
<li>When loading mesh with the same tag name but different type or size, load will fail.</li>
<li>When loading tags in internal format should remember definition and sparsity masks for subsequent data loading. This will cure the case when tags were already previously defined on mesh with different masks and data will be read incorrectly.  </li>
</ol>
</dd>
<dt>Member <a class="el" href="classINMOST_1_1Mesh.html#ade20ec7c8563e82bf8057bc47a3314b7">INMOST::Mesh::Redistribute</a>  ()</dt>
<dd><a class="anchor" id="_todo000035"></a><ol type="1">
<li>introduce "TEMPORARY_KEEP_GHOSTED" tag that will store processors on which copy of element should be kept, internally just merge it with "TEMPORARY_NEW_PROCESSORS" tag this will allow user to control ghosting of certain elements and not to invoke ExchangeMarked every time after Redistribute. This is probably already done using Mesh::SendtoTag, because function fills it without clearing and ExchangeMarked performs initial action based on SendtoTag, it is due to check that SendtoTag is properly merged with "TEMPORARY_NEW_PROCESSORS" before call to ExchangeMarked and received elements are not deleted by accident.</li>
<li>let user provide any integer tag as input without involving RedistributeTag </li>
</ol>
</dd>
<dt>Member <a class="el" href="classINMOST_1_1Mesh.html#a2d488479041917c975b1e662d642c4a5">INMOST::Mesh::ReduceData</a>  (const <a class="el" href="classINMOST_1_1Tag.html" title="This class provides the access to the individual mesh datum and general information about it.">Tag</a> &amp;tag, ElementType mask, MarkerType select, ReduceOperation op)</dt>
<dd><a class="anchor" id="_todo000033"></a><ol type="1">
<li>Exchanging DATA_REFERENCE,DATA_REMOTE_REFERENCE tags not implemented, this is due to the absence of any conclusion</li>
</ol>
<ul>
<li>on how it should behave: either only search within elements owned by the other processor and establish references and set InvalidHandle() to elements that are not found (fairly easy, will involve search operations to check against owned elements for similar entry, efficient implementation will require bounding search trees (see TODO 49);</li>
<li>or: send all the referenced elements through PackElementsData and establish all the links within elements reproduced by UnpackElementsData (UnpackElementsData calls UnpackTagData with set of unpacked elements using which it will be very comfortable to establish references on remote processor). Drawback is that exchanging laplacian operator in such a manner should result in the whole grid being shared among all the processors. </li>
</ul>
</dd>
<dt>Member <a class="el" href="classINMOST_1_1Mesh.html#a5cb95f1e8d6b7987496fc8276c86cf3a">INMOST::Mesh::RemoveGhostElements</a>  (const HandleType *ghost, enumerator num)</dt>
<dd><a class="anchor" id="_todo000030"></a><ol type="1">
<li>Currently request for deletion of elements of lower level then cell will be simply ignored, ensure in future that algorithm will properly rise deletion data from lower to upper adjacencies to delete all the upper adjacencies that depend on deleted lower adjacencies  </li>
</ol>
</dd>
<dt>Member <a class="el" href="classINMOST_1_1Mesh.html#ac12ba58210b79c61e64a74c389cd11f6">INMOST::Mesh::Save</a>  (std::string File)</dt>
<dd><a class="anchor" id="_todo000037"></a><ol type="1">
<li>Markers are not saved in internal format due to possible conflict during load.  </li>
</ol>
</dd>
<dt>Member <a class="el" href="classINMOST_1_1Mesh.html#a9f8cfa72de874bd9a17fb0067ac8d515">INMOST::Mesh::SortByGlobalID</a>  (HandleType *h, enumerator num)</dt>
<dd><a class="anchor" id="_todo000041"></a> TODO 53 check that putting global ids to array will be faster  </dd>
<dt>Class <a class="el" href="classINMOST_1_1MultiEntry.html">INMOST::MultiEntry</a>  </dt>
<dd><a class="anchor" id="_todo000003"></a><ol type="1">
<li>Check it works</li>
<li>Check if it crashes with different combinations of entries on different element types or different masks.  </li>
</ol>
</dd>
<dt>Class <a class="el" href="classINMOST_1_1Residual.html">INMOST::Residual</a>  </dt>
<dd><a class="anchor" id="_todo000043"></a><ol type="1">
<li>Extend for hessian calculation.  </li>
</ol>
</dd>
<dt>Class <a class="el" href="classINMOST_1_1StatusBlockEntry.html">INMOST::StatusBlockEntry</a>  </dt>
<dd><a class="anchor" id="_todo000002"></a><ol type="1">
<li>Check it works  </li>
</ol>
</dd>
<dt>Class <a class="el" href="classINMOST_1_1stencil__block__variable.html">INMOST::stencil_block_variable</a>  </dt>
<dd><a class="anchor" id="_todo000005"></a>coefficients could be matrices here, introduce another class?  </dd>
<dt>Member <a class="el" href="classINMOST_1_1SymmetricMatrix.html#abb13ce177a8f9313e7b10127352e3ba3">INMOST::SymmetricMatrix&lt; Var, storage_type &gt;::SymmetricMatrix</a>  (const storage_type &amp;pspace)</dt>
<dd><a class="anchor" id="_todo000013"></a>Do we need reference for pspace or just pspace?  </dd>
<dt>Member <a class="el" href="classINMOST_1_1SymmetricMatrix.html#a889f56df1da003ee377a75300cdcc062">INMOST::SymmetricMatrix&lt; Var, storage_type &gt;::SymmetricMatrix</a>  (const storage_type &amp;pspace, enumerator pn)</dt>
<dd><a class="anchor" id="_todo000012"></a>Do we need reference for pspace or just pspace? </dd>
</dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 14 2023 19:52:28 for INMOST by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.1
</small></address>
</body>
</html>
