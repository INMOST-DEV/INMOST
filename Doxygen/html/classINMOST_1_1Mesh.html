<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>INMOST: INMOST::Mesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">INMOST
   </div>
   <div id="projectbrief">A toolkit for distributed mathematical modeling</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>INMOST</b></li><li class="navelem"><a class="el" href="classINMOST_1_1Mesh.html">Mesh</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classINMOST_1_1Mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">INMOST::Mesh Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for INMOST::Mesh:</div>
<div class="dyncontent">
<div class="center"><img src="classINMOST_1_1Mesh__inherit__graph.png" border="0" usemap="#aINMOST_1_1Mesh_inherit__map" alt="Inheritance graph"/></div>
<map name="aINMOST_1_1Mesh_inherit__map" id="aINMOST_1_1Mesh_inherit__map">
<area shape="rect" title=" " alt="" coords="111,80,227,107"/>
<area shape="rect" href="classINMOST_1_1TagManager.html" title=" " alt="" coords="5,5,165,32"/>
<area shape="rect" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes." alt="" coords="189,5,320,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for INMOST::Mesh:</div>
<div class="dyncontent">
<div class="center"><img src="classINMOST_1_1Mesh__coll__graph.png" border="0" usemap="#aINMOST_1_1Mesh_coll__map" alt="Collaboration graph"/></div>
<map name="aINMOST_1_1Mesh_coll__map" id="aINMOST_1_1Mesh_coll__map">
<area shape="rect" title=" " alt="" coords="713,231,829,257"/>
<area shape="rect" href="classINMOST_1_1TagManager.html" title=" " alt="" coords="403,180,563,207"/>
<area shape="rect" href="classINMOST_1_1chunk__array.html" title=" " alt="" coords="15,5,216,61"/>
<area shape="rect" href="classINMOST_1_1chunk__array.html" title=" " alt="" coords="5,85,225,141"/>
<area shape="rect" href="classINMOST_1_1chunk__array.html" title=" " alt="" coords="21,165,210,221"/>
<area shape="rect" href="classINMOST_1_1chunk__array.html" title=" " alt="" coords="19,245,212,301"/>
<area shape="rect" href="classINMOST_1_1chunk__array.html" title=" " alt="" coords="22,326,209,367"/>
<area shape="rect" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes." alt="" coords="417,231,548,257"/>
<area shape="rect" href="classINMOST_1_1Tag.html" title="This class provides the access to the individual mesh datum and general information about it." alt="" coords="431,281,534,308"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">base_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1BulkComparator.html">BulkComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1BulkDFComparator.html">BulkDFComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1CentroidComparator.html">CentroidComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1elements__by__type.html">elements_by_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structINMOST_1_1Mesh_1_1exch__recv__reqs__t.html">exch_recv_reqs_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1GlobalIDComparator.html">GlobalIDComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1HierarchyComparator.html">HierarchyComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1IntegerComparator.html">IntegerComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1IntegerDFComparator.html">IntegerDFComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1MarkerComparator.html">MarkerComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1MeasureComparator.html">MeasureComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1PrivateMarkerComparator.html">PrivateMarkerComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1RealComparator.html">RealComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1RealDFComparator.html">RealDFComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1SetNameComparator.html">SetNameComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7c38597c1e6e3e963983df9259231a33"><td class="memItemLeft" align="right" valign="top"><a id="a7c38597c1e6e3e963983df9259231a33"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>MeshState</b> { <b>Serial</b>
, <b>Parallel</b>
 }</td></tr>
<tr class="separator:a7c38597c1e6e3e963983df9259231a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6188cbe799f92cbddf37e2ff1310489e"><td class="memItemLeft" align="right" valign="top"><a id="a6188cbe799f92cbddf37e2ff1310489e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>Action</b> { <b>AGhost</b>
, <b>AMigrate</b>
 }</td></tr>
<tr class="separator:a6188cbe799f92cbddf37e2ff1310489e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e305a71cac82ce87df7bfe9c8e807d"><td class="memItemLeft" align="right" valign="top"><a id="a96e305a71cac82ce87df7bfe9c8e807d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>Prepare</b> { <b>UnknownSize</b>
, <b>UnknownSource</b>
 }</td></tr>
<tr class="separator:a96e305a71cac82ce87df7bfe9c8e807d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9055f423fc6502c7e476ce1247904e6"><td class="memItemLeft" align="right" valign="top"><a id="ae9055f423fc6502c7e476ce1247904e6"></a>
typedef <a class="el" href="classINMOST_1_1chunk__array.html">chunk_array</a>&lt; <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>, chunk_bits_empty &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>empty_container</b></td></tr>
<tr class="separator:ae9055f423fc6502c7e476ce1247904e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8e9f6b0b8eea367c332c36320d4c02"><td class="memItemLeft" align="right" valign="top"><a id="a7a8e9f6b0b8eea367c332c36320d4c02"></a>
typedef <a class="el" href="classINMOST_1_1chunk__array.html">chunk_array</a>&lt; <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>, chunk_bits_elems &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>links_container</b></td></tr>
<tr class="separator:a7a8e9f6b0b8eea367c332c36320d4c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa5359ad0ee39a9a35ed7230d8bd3e1"><td class="memItemLeft" align="right" valign="top"><a id="a7aa5359ad0ee39a9a35ed7230d8bd3e1"></a>
typedef <a class="el" href="classINMOST_1_1array.html">TagManager::sparse_sub_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sparse_type</b></td></tr>
<tr class="separator:a7aa5359ad0ee39a9a35ed7230d8bd3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108a6bf9c3b9ce9d446c891a23329ef1"><td class="memItemLeft" align="right" valign="top"><a id="a108a6bf9c3b9ce9d446c891a23329ef1"></a>
typedef <a class="el" href="structINMOST_1_1TagManager_1_1sparse__sub__record.html">TagManager::sparse_sub_record</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sparse_rec</b></td></tr>
<tr class="separator:a108a6bf9c3b9ce9d446c891a23329ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32a7de3dbfafd84c6635212b20aecb7"><td class="memItemLeft" align="right" valign="top"><a id="aa32a7de3dbfafd84c6635212b20aecb7"></a>
typedef sparse_type::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>senum</b></td></tr>
<tr class="separator:aa32a7de3dbfafd84c6635212b20aecb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeee557c442078e3354b2fa2ea4a0809"><td class="memItemLeft" align="right" valign="top"><a id="aeeee557c442078e3354b2fa2ea4a0809"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>ReduceOperation</b>) (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, const <a class="el" href="classINMOST_1_1Element.html">Element</a> &amp;element, const INMOST_DATA_BULK_TYPE *recv_data, INMOST_DATA_ENUM_TYPE recv_size)</td></tr>
<tr class="separator:aeeee557c442078e3354b2fa2ea4a0809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e96c6c49203571ef3f391a5e65f5de"><td class="memItemLeft" align="right" valign="top"><a id="a10e96c6c49203571ef3f391a5e65f5de"></a>
typedef std::vector&lt; <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tag_set</b></td></tr>
<tr class="separator:a10e96c6c49203571ef3f391a5e65f5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d97c93d9d3a7bee03180d5cd4372696"><td class="memItemLeft" align="right" valign="top"><a id="a2d97c93d9d3a7bee03180d5cd4372696"></a>
typedef std::vector&lt; HandleType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>element_set</b></td></tr>
<tr class="separator:a2d97c93d9d3a7bee03180d5cd4372696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956b5292142d9a206f47a00d3f55b22f"><td class="memItemLeft" align="right" valign="top"><a id="a956b5292142d9a206f47a00d3f55b22f"></a>
typedef std::vector&lt; INMOST_DATA_BULK_TYPE &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>buffer_type</b></td></tr>
<tr class="separator:a956b5292142d9a206f47a00d3f55b22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ae9912a7097744db789754a90118d5"><td class="memItemLeft" align="right" valign="top"><a id="ac6ae9912a7097744db789754a90118d5"></a>
typedef std::map&lt; int, element_set &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>proc_elements</b></td></tr>
<tr class="separator:ac6ae9912a7097744db789754a90118d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad396ce459946a34ebd8cc5e564ff7e20"><td class="memItemLeft" align="right" valign="top"><a id="ad396ce459946a34ebd8cc5e564ff7e20"></a>
typedef std::pair&lt; int, buffer_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>proc_buffer_type</b></td></tr>
<tr class="separator:ad396ce459946a34ebd8cc5e564ff7e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdffb8a47775004fd0b7497d321405c"><td class="memItemLeft" align="right" valign="top"><a id="a9cdffb8a47775004fd0b7497d321405c"></a>
typedef std::vector&lt; proc_buffer_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>exch_buffer_type</b></td></tr>
<tr class="separator:a9cdffb8a47775004fd0b7497d321405c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5826ddbba44159c983d1727941d05a3"><td class="memItemLeft" align="right" valign="top"><a id="af5826ddbba44159c983d1727941d05a3"></a>
typedef std::vector&lt; INMOST_MPI_Request &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>exch_reqs_type</b></td></tr>
<tr class="separator:af5826ddbba44159c983d1727941d05a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f18534740826c47eea3c0dd3b86ca5"><td class="memItemLeft" align="right" valign="top"><a id="ac3f18534740826c47eea3c0dd3b86ca5"></a>
typedef struct <a class="el" href="structINMOST_1_1Mesh_1_1exch__recv__reqs__t.html">INMOST::Mesh::exch_recv_reqs_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>exch_recv_reqs_type</b></td></tr>
<tr class="separator:ac3f18534740826c47eea3c0dd3b86ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23730b3d7aa66d705a94d8439070e581"><td class="memItemLeft" align="right" valign="top"><a id="a23730b3d7aa66d705a94d8439070e581"></a>
typedef std::map&lt; int, <a class="el" href="classINMOST_1_1Mesh_1_1elements__by__type.html">elements_by_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>parallel_storage</b></td></tr>
<tr class="separator:a23730b3d7aa66d705a94d8439070e581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb45e67595e5c4d9881c3a00313d3fd"><td class="memItemLeft" align="right" valign="top"><a id="abdb45e67595e5c4d9881c3a00313d3fd"></a>
typedef std::map&lt; int, <a class="el" href="classINMOST_1_1Mesh_1_1elements__by__type.html">elements_by_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>proc_elements_by_type</b></td></tr>
<tr class="separator:abdb45e67595e5c4d9881c3a00313d3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3a085d38c3b8b12d708afef270bca9"><td class="memItemLeft" align="right" valign="top"><a id="a4d3a085d38c3b8b12d708afef270bca9"></a>
typedef <a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">base_iterator</a>&lt; <a class="el" href="classINMOST_1_1Storage.html">Storage</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iteratorStorage</b></td></tr>
<tr class="separator:a4d3a085d38c3b8b12d708afef270bca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f367f5aa2b0d86940e52a8a93b17e0"><td class="memItemLeft" align="right" valign="top"><a id="a37f367f5aa2b0d86940e52a8a93b17e0"></a>
typedef <a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">base_iterator</a>&lt; <a class="el" href="classINMOST_1_1Element.html">Element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iteratorElement</b></td></tr>
<tr class="separator:a37f367f5aa2b0d86940e52a8a93b17e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a8ae93bb4bbfb4d9ca36b2f324ca00"><td class="memItemLeft" align="right" valign="top"><a id="a29a8ae93bb4bbfb4d9ca36b2f324ca00"></a>
typedef <a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">base_iterator</a>&lt; <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iteratorSet</b></td></tr>
<tr class="separator:a29a8ae93bb4bbfb4d9ca36b2f324ca00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808ade85adce097c826e100527391b1d"><td class="memItemLeft" align="right" valign="top"><a id="a808ade85adce097c826e100527391b1d"></a>
typedef <a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">base_iterator</a>&lt; <a class="el" href="classINMOST_1_1Cell.html">Cell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iteratorCell</b></td></tr>
<tr class="separator:a808ade85adce097c826e100527391b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b0ec48bb09310671f2cb9fed44d8d4"><td class="memItemLeft" align="right" valign="top"><a id="a72b0ec48bb09310671f2cb9fed44d8d4"></a>
typedef <a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">base_iterator</a>&lt; <a class="el" href="classINMOST_1_1Face.html">Face</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iteratorFace</b></td></tr>
<tr class="separator:a72b0ec48bb09310671f2cb9fed44d8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c66b43ab828c819ec65f660c93937f"><td class="memItemLeft" align="right" valign="top"><a id="ae3c66b43ab828c819ec65f660c93937f"></a>
typedef <a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">base_iterator</a>&lt; <a class="el" href="classINMOST_1_1Edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iteratorEdge</b></td></tr>
<tr class="separator:ae3c66b43ab828c819ec65f660c93937f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972f183065ada503d896cd70d73e95b2"><td class="memItemLeft" align="right" valign="top"><a id="a972f183065ada503d896cd70d73e95b2"></a>
typedef <a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">base_iterator</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iteratorNode</b></td></tr>
<tr class="separator:a972f183065ada503d896cd70d73e95b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ab70302c5e4bb756153c3007627102"><td class="memItemLeft" align="right" valign="top"><a id="a45ab70302c5e4bb756153c3007627102"></a>
typedef std::map&lt; GeometricData, ElementType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GeomParam</b></td></tr>
<tr class="separator:a45ab70302c5e4bb756153c3007627102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classINMOST_1_1TagManager"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classINMOST_1_1TagManager')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classINMOST_1_1TagManager.html">INMOST::TagManager</a></td></tr>
<tr class="memitem:adda9f59b50509dee56fa03697e1b4b02 inherit pub_types_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="adda9f59b50509dee56fa03697e1b4b02"></a>
typedef tag_array_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>iteratorTag</b></td></tr>
<tr class="separator:adda9f59b50509dee56fa03697e1b4b02 inherit pub_types_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classINMOST_1_1Storage"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classINMOST_1_1Storage')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classINMOST_1_1Storage.html">INMOST::Storage</a></td></tr>
<tr class="memitem:a853346784b4a5822a7fac54d8f10f805 inherit pub_types_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a853346784b4a5822a7fac54d8f10f805"></a>
typedef INMOST_DATA_REAL_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a></td></tr>
<tr class="memdesc:a853346784b4a5822a7fac54d8f10f805 inherit pub_types_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes.">Storage</a> type for representing real values. <br /></td></tr>
<tr class="separator:a853346784b4a5822a7fac54d8f10f805 inherit pub_types_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec96942bc647417a801e2895b45964d2 inherit pub_types_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="aec96942bc647417a801e2895b45964d2"></a>
typedef INMOST_DATA_INTEGER_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a></td></tr>
<tr class="memdesc:aec96942bc647417a801e2895b45964d2 inherit pub_types_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes.">Storage</a> type for representing integer values. <br /></td></tr>
<tr class="separator:aec96942bc647417a801e2895b45964d2 inherit pub_types_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae429556af77094077d212e0ac23c8cfc inherit pub_types_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="ae429556af77094077d212e0ac23c8cfc"></a>
typedef INMOST_DATA_BULK_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a></td></tr>
<tr class="memdesc:ae429556af77094077d212e0ac23c8cfc inherit pub_types_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes.">Storage</a> type for representing one byte of abstract data. <br /></td></tr>
<tr class="separator:ae429556af77094077d212e0ac23c8cfc inherit pub_types_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae333dfced6fa9cfde0c8e7dcf1b0cc2b inherit pub_types_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="ae333dfced6fa9cfde0c8e7dcf1b0cc2b"></a>
typedef INMOST_DATA_ENUM_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a></td></tr>
<tr class="memdesc:ae333dfced6fa9cfde0c8e7dcf1b0cc2b inherit pub_types_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for representing unsigned integer values. <br /></td></tr>
<tr class="separator:ae333dfced6fa9cfde0c8e7dcf1b0cc2b inherit pub_types_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8674802045ec170a3c9d0e3281545b54 inherit pub_types_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a8674802045ec170a3c9d0e3281545b54"></a>
typedef HandleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a8674802045ec170a3c9d0e3281545b54">reference</a></td></tr>
<tr class="memdesc:a8674802045ec170a3c9d0e3281545b54 inherit pub_types_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes.">Storage</a> type for representing references to <a class="el" href="classINMOST_1_1Element.html">Element</a>. <br /></td></tr>
<tr class="separator:a8674802045ec170a3c9d0e3281545b54 inherit pub_types_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211e235d55d933c5dc3f7040e0b50504 inherit pub_types_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a211e235d55d933c5dc3f7040e0b50504"></a>
typedef RemoteHandleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a211e235d55d933c5dc3f7040e0b50504">remote_reference</a></td></tr>
<tr class="memdesc:a211e235d55d933c5dc3f7040e0b50504 inherit pub_types_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes.">Storage</a> type for representing references to <a class="el" href="classINMOST_1_1Element.html">Element</a> in another <a class="el" href="classINMOST_1_1Mesh.html">Mesh</a>. <br /></td></tr>
<tr class="separator:a211e235d55d933c5dc3f7040e0b50504 inherit pub_types_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430e5358d435befb38169beef593527e inherit pub_types_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a430e5358d435befb38169beef593527e"></a>
typedef <a class="el" href="classINMOST_1_1shell.html">shell</a>&lt; <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a430e5358d435befb38169beef593527e">real_array</a></td></tr>
<tr class="memdesc:a430e5358d435befb38169beef593527e inherit pub_types_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes.">Storage</a> type for representing arrays of real values. <br /></td></tr>
<tr class="separator:a430e5358d435befb38169beef593527e inherit pub_types_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1637367f0487eb778894b57fc94647 inherit pub_types_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a4d1637367f0487eb778894b57fc94647"></a>
typedef <a class="el" href="classINMOST_1_1shell.html">shell</a>&lt; <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a4d1637367f0487eb778894b57fc94647">integer_array</a></td></tr>
<tr class="memdesc:a4d1637367f0487eb778894b57fc94647 inherit pub_types_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes.">Storage</a> type for representing arrays of integer values. <br /></td></tr>
<tr class="separator:a4d1637367f0487eb778894b57fc94647 inherit pub_types_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e49b2a38cb55dd59529bd23e8b1b852 inherit pub_types_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a6e49b2a38cb55dd59529bd23e8b1b852"></a>
typedef <a class="el" href="classINMOST_1_1shell.html">shell</a>&lt; <a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a6e49b2a38cb55dd59529bd23e8b1b852">bulk_array</a></td></tr>
<tr class="memdesc:a6e49b2a38cb55dd59529bd23e8b1b852 inherit pub_types_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes.">Storage</a> type for representing abstract data as a series of bytes. <br /></td></tr>
<tr class="separator:a6e49b2a38cb55dd59529bd23e8b1b852 inherit pub_types_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26add298824745e27a977a633d436c21 inherit pub_types_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a26add298824745e27a977a633d436c21"></a>
typedef <a class="el" href="classINMOST_1_1multivar__expression.html">variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a26add298824745e27a977a633d436c21">var</a></td></tr>
<tr class="memdesc:a26add298824745e27a977a633d436c21 inherit pub_types_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes.">Storage</a> type for representing real value with vector of variations. <br /></td></tr>
<tr class="separator:a26add298824745e27a977a633d436c21 inherit pub_types_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7412664cc3faf19cdaf391a97ac46b59 inherit pub_types_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a7412664cc3faf19cdaf391a97ac46b59"></a>
typedef <a class="el" href="classINMOST_1_1shell.html">shell</a>&lt; <a class="el" href="classINMOST_1_1multivar__expression.html">variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a7412664cc3faf19cdaf391a97ac46b59">var_array</a></td></tr>
<tr class="memdesc:a7412664cc3faf19cdaf391a97ac46b59 inherit pub_types_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes.">Storage</a> type for representing array of values with vectors of variations. <br /></td></tr>
<tr class="separator:a7412664cc3faf19cdaf391a97ac46b59 inherit pub_types_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab6f7bfe240d38a59102bc8929480cd65"><td class="memItemLeft" align="right" valign="top"><a id="ab6f7bfe240d38a59102bc8929480cd65"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ab6f7bfe240d38a59102bc8929480cd65">AddOrientedTag</a> (<a class="el" href="classINMOST_1_1Tag.html">Tag</a> t)</td></tr>
<tr class="memdesc:ab6f7bfe240d38a59102bc8929480cd65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a data tag that follows normal orientation. <br /></td></tr>
<tr class="separator:ab6f7bfe240d38a59102bc8929480cd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6befb4ffc1dfaaf476339fc8eca4181c"><td class="memItemLeft" align="right" valign="top"><a id="a6befb4ffc1dfaaf476339fc8eca4181c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a6befb4ffc1dfaaf476339fc8eca4181c">RemOrientedTag</a> (<a class="el" href="classINMOST_1_1Tag.html">Tag</a> t)</td></tr>
<tr class="memdesc:a6befb4ffc1dfaaf476339fc8eca4181c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a data tag that follows normal orientation. <br /></td></tr>
<tr class="separator:a6befb4ffc1dfaaf476339fc8eca4181c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e300e2d9240b92bd6a6ce4ad8506e1"><td class="memItemLeft" align="right" valign="top"><a id="ab6e300e2d9240b92bd6a6ce4ad8506e1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ab6e300e2d9240b92bd6a6ce4ad8506e1">OrientTags</a> (<a class="el" href="classINMOST_1_1Face.html">Face</a> f)</td></tr>
<tr class="memdesc:ab6e300e2d9240b92bd6a6ce4ad8506e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap sign for oriented data. <br /></td></tr>
<tr class="separator:ab6e300e2d9240b92bd6a6ce4ad8506e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a996485484abadae7f6b08c3f15abae"><td class="memItemLeft" align="right" valign="top"><a id="a5a996485484abadae7f6b08c3f15abae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a5a996485484abadae7f6b08c3f15abae">OrientTag</a> (<a class="el" href="classINMOST_1_1Face.html">Face</a> f, <a class="el" href="classINMOST_1_1Tag.html">Tag</a> t)</td></tr>
<tr class="memdesc:a5a996485484abadae7f6b08c3f15abae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap sign for oriented data of a single tag. <br /></td></tr>
<tr class="separator:a5a996485484abadae7f6b08c3f15abae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c8a9bd436f8afbf0f2cf705d076fe7"><td class="memItemLeft" align="right" valign="top"><a id="a56c8a9bd436f8afbf0f2cf705d076fe7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a56c8a9bd436f8afbf0f2cf705d076fe7">ReportConnection</a> (HandleType h)</td></tr>
<tr class="memdesc:a56c8a9bd436f8afbf0f2cf705d076fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Go through all elements and detect presence of prescribed element in any reference data tag. <br /></td></tr>
<tr class="separator:a56c8a9bd436f8afbf0f2cf705d076fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9d87c22843c13e650befe095817230"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a1d9d87c22843c13e650befe095817230">HaveGlobalID</a> (ElementType types) const</td></tr>
<tr class="memdesc:a1d9d87c22843c13e650befe095817230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether global identificator was set on certain type of elements.  <a href="classINMOST_1_1Mesh.html#a1d9d87c22843c13e650befe095817230">More...</a><br /></td></tr>
<tr class="separator:a1d9d87c22843c13e650befe095817230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1038abd2e0042337e60b578f76f119"><td class="memItemLeft" align="right" valign="top"><a id="aaa1038abd2e0042337e60b578f76f119"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aaa1038abd2e0042337e60b578f76f119">Clear</a> ()</td></tr>
<tr class="memdesc:aaa1038abd2e0042337e60b578f76f119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all data and all elements from the mesh Reset geometry service and topology check flags. <br /></td></tr>
<tr class="separator:aaa1038abd2e0042337e60b578f76f119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d7cbbd5950153b3c16e26f1bd50c3d"><td class="memItemLeft" align="right" valign="top"><a id="ab2d7cbbd5950153b3c16e26f1bd50c3d"></a>
<a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ab2d7cbbd5950153b3c16e26f1bd50c3d">MemoryUsage</a> (HandleType h)</td></tr>
<tr class="memdesc:ab2d7cbbd5950153b3c16e26f1bd50c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For parmetis return total number in bytes of occupied memory by element and its data. <br /></td></tr>
<tr class="separator:ab2d7cbbd5950153b3c16e26f1bd50c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e25917eef6ef12ea7366b6f18302b36"><td class="memItemLeft" align="right" valign="top"><a id="a7e25917eef6ef12ea7366b6f18302b36"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Mesh</b> (std::string name)</td></tr>
<tr class="separator:a7e25917eef6ef12ea7366b6f18302b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef026100f4ec3b0165a5816558faadc2"><td class="memItemLeft" align="right" valign="top"><a id="aef026100f4ec3b0165a5816558faadc2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Mesh</b> (const <a class="el" href="classINMOST_1_1Mesh.html">Mesh</a> &amp;other)</td></tr>
<tr class="separator:aef026100f4ec3b0165a5816558faadc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cc916a08f462721b5986abf71005ea"><td class="memItemLeft" align="right" valign="top"><a id="a83cc916a08f462721b5986abf71005ea"></a>
<a class="el" href="classINMOST_1_1Mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classINMOST_1_1Mesh.html">Mesh</a> const &amp;other)</td></tr>
<tr class="separator:a83cc916a08f462721b5986abf71005ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d860dda768f1d8b7a1b5cd2066cb504"><td class="memItemLeft" align="right" valign="top">MarkerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a3d860dda768f1d8b7a1b5cd2066cb504">CreateMarker</a> ()</td></tr>
<tr class="memdesc:a3d860dda768f1d8b7a1b5cd2066cb504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new marker.  <a href="classINMOST_1_1Mesh.html#a3d860dda768f1d8b7a1b5cd2066cb504">More...</a><br /></td></tr>
<tr class="separator:a3d860dda768f1d8b7a1b5cd2066cb504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ac154b7c4f179fdafbc9a03f491f37"><td class="memItemLeft" align="right" valign="top"><a id="a53ac154b7c4f179fdafbc9a03f491f37"></a>
MarkerType&#160;</td><td class="memItemRight" valign="bottom"><b>CreatePrivateMarker</b> ()</td></tr>
<tr class="separator:a53ac154b7c4f179fdafbc9a03f491f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40814cb2b1031870784d1a2fd3f389de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a40814cb2b1031870784d1a2fd3f389de">ReleaseMarker</a> (MarkerType n, ElementType cleanup=NONE)</td></tr>
<tr class="memdesc:a40814cb2b1031870784d1a2fd3f389de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release marker back for reuse.  <a href="classINMOST_1_1Mesh.html#a40814cb2b1031870784d1a2fd3f389de">More...</a><br /></td></tr>
<tr class="separator:a40814cb2b1031870784d1a2fd3f389de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7797c1f6958cba059956e9770cdfc5"><td class="memItemLeft" align="right" valign="top"><a id="afa7797c1f6958cba059956e9770cdfc5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ReleasePrivateMarker</b> (MarkerType n, ElementType cleanup=NONE)</td></tr>
<tr class="separator:afa7797c1f6958cba059956e9770cdfc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef41098a12fe80cac6f45ee94ef892b"><td class="memItemLeft" align="right" valign="top">__INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a8ef41098a12fe80cac6f45ee94ef892b">SetEpsilon</a> (<a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> e)</td></tr>
<tr class="memdesc:a8ef41098a12fe80cac6f45ee94ef892b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set tolerance for coordinates comparison.  <a href="classINMOST_1_1Mesh.html#a8ef41098a12fe80cac6f45ee94ef892b">More...</a><br /></td></tr>
<tr class="separator:a8ef41098a12fe80cac6f45ee94ef892b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f63380ce8002b1bc5bca17d9c3161c"><td class="memItemLeft" align="right" valign="top">__INLINE <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ae3f63380ce8002b1bc5bca17d9c3161c">GetEpsilon</a> () const</td></tr>
<tr class="memdesc:ae3f63380ce8002b1bc5bca17d9c3161c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve tolerance for coordinates comparison.  <a href="classINMOST_1_1Mesh.html#ae3f63380ce8002b1bc5bca17d9c3161c">More...</a><br /></td></tr>
<tr class="separator:ae3f63380ce8002b1bc5bca17d9c3161c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a2c4cb85d29a3f8bae803b013a52c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a04a2c4cb85d29a3f8bae803b013a52c9">SetDimensions</a> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> dim)</td></tr>
<tr class="memdesc:a04a2c4cb85d29a3f8bae803b013a52c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set number of dimensions for mesh.  <a href="classINMOST_1_1Mesh.html#a04a2c4cb85d29a3f8bae803b013a52c9">More...</a><br /></td></tr>
<tr class="separator:a04a2c4cb85d29a3f8bae803b013a52c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7273bdff94d190cb7864059b2b02ef31"><td class="memItemLeft" align="right" valign="top">__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a7273bdff94d190cb7864059b2b02ef31">GetDimensions</a> () const</td></tr>
<tr class="memdesc:a7273bdff94d190cb7864059b2b02ef31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of dimensions of mesh.  <a href="classINMOST_1_1Mesh.html#a7273bdff94d190cb7864059b2b02ef31">More...</a><br /></td></tr>
<tr class="separator:a7273bdff94d190cb7864059b2b02ef31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add610999b1e7a8ce4aae6b3f9528d5e1"><td class="memItemLeft" align="right" valign="top">__INLINE MeshState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#add610999b1e7a8ce4aae6b3f9528d5e1">GetMeshState</a> () const</td></tr>
<tr class="memdesc:add610999b1e7a8ce4aae6b3f9528d5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get parallel state of the mesh.  <a href="classINMOST_1_1Mesh.html#add610999b1e7a8ce4aae6b3f9528d5e1">More...</a><br /></td></tr>
<tr class="separator:add610999b1e7a8ce4aae6b3f9528d5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a591e56eca265720dc01cc861577c27"><td class="memItemLeft" align="right" valign="top"><a id="a2a591e56eca265720dc01cc861577c27"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GlobalIDTag</b> () const</td></tr>
<tr class="separator:a2a591e56eca265720dc01cc861577c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbc834c78d1f9ef5b96a278a0311537"><td class="memItemLeft" align="right" valign="top"><a id="aacbc834c78d1f9ef5b96a278a0311537"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>CoordsTag</b> () const</td></tr>
<tr class="separator:aacbc834c78d1f9ef5b96a278a0311537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00cfe84ac5b96003a359f3d67e42e80"><td class="memItemLeft" align="right" valign="top"><a id="af00cfe84ac5b96003a359f3d67e42e80"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>LowConnTag</b> () const</td></tr>
<tr class="separator:af00cfe84ac5b96003a359f3d67e42e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3286e9f3e5c73f6db970bee2d97227"><td class="memItemLeft" align="right" valign="top"><a id="abc3286e9f3e5c73f6db970bee2d97227"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>HighConnTag</b> () const</td></tr>
<tr class="separator:abc3286e9f3e5c73f6db970bee2d97227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a07023c88660ff5cf8b11708e1f4885"><td class="memItemLeft" align="right" valign="top"><a id="a7a07023c88660ff5cf8b11708e1f4885"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>MarkersTag</b> () const</td></tr>
<tr class="separator:a7a07023c88660ff5cf8b11708e1f4885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598cf78870a0bcd9cdd08163c8416652"><td class="memItemLeft" align="right" valign="top"><a id="a598cf78870a0bcd9cdd08163c8416652"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GeomTypeTag</b> () const</td></tr>
<tr class="separator:a598cf78870a0bcd9cdd08163c8416652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af411af4711902adf8378e3aa13b46411"><td class="memItemLeft" align="right" valign="top"><a id="af411af4711902adf8378e3aa13b46411"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>SendtoTag</b> () const</td></tr>
<tr class="separator:af411af4711902adf8378e3aa13b46411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eaf82affe2b0b9baf9a37e08a736f1e"><td class="memItemLeft" align="right" valign="top"><a id="a1eaf82affe2b0b9baf9a37e08a736f1e"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>SharedTag</b> () const</td></tr>
<tr class="separator:a1eaf82affe2b0b9baf9a37e08a736f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fbc64c8014ad79bca09c6f812b22df"><td class="memItemLeft" align="right" valign="top"><a id="aa0fbc64c8014ad79bca09c6f812b22df"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>OwnerTag</b> () const</td></tr>
<tr class="separator:aa0fbc64c8014ad79bca09c6f812b22df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5883b21ca28af6351611c7a61dfe46d8"><td class="memItemLeft" align="right" valign="top"><a id="a5883b21ca28af6351611c7a61dfe46d8"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>LayersTag</b> () const</td></tr>
<tr class="separator:a5883b21ca28af6351611c7a61dfe46d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b57ccc3672351604eaf2006aa09360c"><td class="memItemLeft" align="right" valign="top"><a id="a6b57ccc3672351604eaf2006aa09360c"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>BridgeTag</b> () const</td></tr>
<tr class="separator:a6b57ccc3672351604eaf2006aa09360c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad189626a1edcdd972e895342894665be"><td class="memItemLeft" align="right" valign="top"><a id="ad189626a1edcdd972e895342894665be"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ProcessorsTag</b> () const</td></tr>
<tr class="separator:ad189626a1edcdd972e895342894665be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d607d7dabb80cafeeefa12eb3cb8a17"><td class="memItemLeft" align="right" valign="top"><a id="a1d607d7dabb80cafeeefa12eb3cb8a17"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>SetNameTag</b> () const</td></tr>
<tr class="separator:a1d607d7dabb80cafeeefa12eb3cb8a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e14f6de1c708913feb036612b7e4e9"><td class="memItemLeft" align="right" valign="top"><a id="a83e14f6de1c708913feb036612b7e4e9"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>SetComparatorTag</b> () const</td></tr>
<tr class="separator:a83e14f6de1c708913feb036612b7e4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd4e1b35b122a5cfc24d6d74229b81b"><td class="memItemLeft" align="right" valign="top"><a id="a1cd4e1b35b122a5cfc24d6d74229b81b"></a>
__INLINE <a class="el" href="classINMOST_1_1Tag.html">Tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a1cd4e1b35b122a5cfc24d6d74229b81b">RedistributeTag</a> ()</td></tr>
<tr class="memdesc:a1cd4e1b35b122a5cfc24d6d74229b81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Don't put this shortcut to any function directly, as it creates tag inside assign to other object of type <a class="el" href="classINMOST_1_1Tag.html" title="This class provides the access to the individual mesh datum and general information about it.">Tag</a> and put this object to functions. <br /></td></tr>
<tr class="separator:a1cd4e1b35b122a5cfc24d6d74229b81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d7bfbdaa069199d3f8b3c3e9e7f151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Tag.html">Tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a02d7bfbdaa069199d3f8b3c3e9e7f151">CreateTag</a> (std::string name, DataType dtype, ElementType etype, ElementType sparse, INMOST_DATA_ENUM_TYPE size=ENUMUNDEF)</td></tr>
<tr class="memdesc:a02d7bfbdaa069199d3f8b3c3e9e7f151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the tag by name, type and size.  <a href="classINMOST_1_1Mesh.html#a02d7bfbdaa069199d3f8b3c3e9e7f151">More...</a><br /></td></tr>
<tr class="separator:a02d7bfbdaa069199d3f8b3c3e9e7f151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43e132d6fd14903e263f00fbcffec51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Tag.html">Tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ae43e132d6fd14903e263f00fbcffec51">DeleteTag</a> (<a class="el" href="classINMOST_1_1Tag.html">Tag</a> tag, ElementType mask=NODE|EDGE|FACE|CELL|ESET|MESH)</td></tr>
<tr class="memdesc:ae43e132d6fd14903e263f00fbcffec51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the data that is represented by the tag from elements of selected type.  <a href="classINMOST_1_1Mesh.html#ae43e132d6fd14903e263f00fbcffec51">More...</a><br /></td></tr>
<tr class="separator:ae43e132d6fd14903e263f00fbcffec51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2922f80c6c522500a887fe115cf5271d"><td class="memItemLeft" align="right" valign="top">__INLINE iteratorTag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a2922f80c6c522500a887fe115cf5271d">BeginTag</a> ()</td></tr>
<tr class="memdesc:a2922f80c6c522500a887fe115cf5271d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first tag defined on the mesh.  <a href="classINMOST_1_1Mesh.html#a2922f80c6c522500a887fe115cf5271d">More...</a><br /></td></tr>
<tr class="separator:a2922f80c6c522500a887fe115cf5271d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e44c6e0e39783512dd18424e21d3d8d"><td class="memItemLeft" align="right" valign="top">__INLINE <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a1e44c6e0e39783512dd18424e21d3d8d">NumberOfTags</a> () const</td></tr>
<tr class="memdesc:a1e44c6e0e39783512dd18424e21d3d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the total number of valid tags.  <a href="classINMOST_1_1Mesh.html#a1e44c6e0e39783512dd18424e21d3d8d">More...</a><br /></td></tr>
<tr class="separator:a1e44c6e0e39783512dd18424e21d3d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69466c97ab50182ba143df2a76d5d9f"><td class="memItemLeft" align="right" valign="top">__INLINE iteratorTag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ae69466c97ab50182ba143df2a76d5d9f">EndTag</a> ()</td></tr>
<tr class="memdesc:ae69466c97ab50182ba143df2a76d5d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the indicator for loop to end iteration over tags.  <a href="classINMOST_1_1Mesh.html#ae69466c97ab50182ba143df2a76d5d9f">More...</a><br /></td></tr>
<tr class="separator:ae69466c97ab50182ba143df2a76d5d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2edad518a07d8d9cfadf7803553a4991"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a2edad518a07d8d9cfadf7803553a4991">CreateNode</a> (const <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> *coords)</td></tr>
<tr class="memdesc:a2edad518a07d8d9cfadf7803553a4991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create node by given coordinates.  <a href="classINMOST_1_1Mesh.html#a2edad518a07d8d9cfadf7803553a4991">More...</a><br /></td></tr>
<tr class="separator:a2edad518a07d8d9cfadf7803553a4991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b50ae7b0deede13ab3425cd6547943"><td class="memItemLeft" align="right" valign="top"><a id="ae3b50ae7b0deede13ab3425cd6547943"></a>
std::pair&lt; <a class="el" href="classINMOST_1_1Edge.html">Edge</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateEdge</b> (const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt; &amp;nodes)</td></tr>
<tr class="separator:ae3b50ae7b0deede13ab3425cd6547943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709a5702c9f1dca9247ddf3efc23f411"><td class="memItemLeft" align="right" valign="top"><a id="a709a5702c9f1dca9247ddf3efc23f411"></a>
std::pair&lt; <a class="el" href="classINMOST_1_1Face.html">Face</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateFace</b> (const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Edge.html">Edge</a> &gt; &amp;edges)</td></tr>
<tr class="separator:a709a5702c9f1dca9247ddf3efc23f411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71e8a84e80ee682db190ee94302d8eb"><td class="memItemLeft" align="right" valign="top"><a id="ae71e8a84e80ee682db190ee94302d8eb"></a>
std::pair&lt; <a class="el" href="classINMOST_1_1Face.html">Face</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateFace</b> (const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt; &amp;nodes)</td></tr>
<tr class="separator:ae71e8a84e80ee682db190ee94302d8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413c965ed64b148ae4740d5c5247c175"><td class="memItemLeft" align="right" valign="top"><a id="a413c965ed64b148ae4740d5c5247c175"></a>
std::pair&lt; <a class="el" href="classINMOST_1_1Cell.html">Cell</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateCell</b> (const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Face.html">Face</a> &gt; &amp;faces, const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt; &amp;suggest_nodes=<a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt;(NULL))</td></tr>
<tr class="separator:a413c965ed64b148ae4740d5c5247c175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c90ec59dfa9ea6b9585bb38913712b"><td class="memItemLeft" align="right" valign="top"><a id="a58c90ec59dfa9ea6b9585bb38913712b"></a>
std::pair&lt; <a class="el" href="classINMOST_1_1Cell.html">Cell</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateCell</b> (const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt; &amp;c_f_nodes, const <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> *c_f_numnodes, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> num_c_faces, const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt; &amp;suggest_nodes=<a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt;(NULL))</td></tr>
<tr class="separator:a58c90ec59dfa9ea6b9585bb38913712b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7dfce5b40fb2436e105908e35465c95"><td class="memItemLeft" align="right" valign="top"><a id="ac7dfce5b40fb2436e105908e35465c95"></a>
std::pair&lt; <a class="el" href="classINMOST_1_1Cell.html">Cell</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateCell</b> (const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt; &amp;c_nodes, const <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> *c_f_nodeinds, const <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> *c_f_numnodes, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> num_c_faces, const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt; &amp;suggest_nodes=<a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt;(NULL))</td></tr>
<tr class="separator:ac7dfce5b40fb2436e105908e35465c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c27ec28c027eaf82475a35ab97b0ad"><td class="memItemLeft" align="right" valign="top"><a id="a13c27ec28c027eaf82475a35ab97b0ad"></a>
std::pair&lt; <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateSet</b> (std::string name)</td></tr>
<tr class="separator:a13c27ec28c027eaf82475a35ab97b0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2931fd14ca2de972598ee281181e7bc5"><td class="memItemLeft" align="right" valign="top"><a id="a2931fd14ca2de972598ee281181e7bc5"></a>
std::pair&lt; <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a2931fd14ca2de972598ee281181e7bc5">CreateSetUnique</a> (std::string name)</td></tr>
<tr class="memdesc:a2931fd14ca2de972598ee281181e7bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as Mesh::CreateSet without checking existence of the set. <br /></td></tr>
<tr class="separator:a2931fd14ca2de972598ee281181e7bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5223aa8af17d63c7be40027ff789df7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a5223aa8af17d63c7be40027ff789df7e">GetSet</a> (std::string name)</td></tr>
<tr class="memdesc:a5223aa8af17d63c7be40027ff789df7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve set by name.  <a href="classINMOST_1_1Mesh.html#a5223aa8af17d63c7be40027ff789df7e">More...</a><br /></td></tr>
<tr class="separator:a5223aa8af17d63c7be40027ff789df7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031ce76512ea59b68cad89aca64b8da7"><td class="memItemLeft" align="right" valign="top"><a id="a031ce76512ea59b68cad89aca64b8da7"></a>
<a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a031ce76512ea59b68cad89aca64b8da7">GetSetsByPrefix</a> (std::string prefix)</td></tr>
<tr class="memdesc:a031ce76512ea59b68cad89aca64b8da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all the sets whose names start with given prefix. <br /></td></tr>
<tr class="separator:a031ce76512ea59b68cad89aca64b8da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc758c5116fb3bca50d8910a1381b22d"><td class="memItemLeft" align="right" valign="top"><a id="abc758c5116fb3bca50d8910a1381b22d"></a>
HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>LastCreated</b> () const</td></tr>
<tr class="separator:abc758c5116fb3bca50d8910a1381b22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cabd0f3b552a8f002690be665cb2b4"><td class="memItemLeft" align="right" valign="top"><a id="ad2cabd0f3b552a8f002690be665cb2b4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidHandleRange</b> (HandleType h) const</td></tr>
<tr class="separator:ad2cabd0f3b552a8f002690be665cb2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1477116ad70d8741d38aaa118feb6d"><td class="memItemLeft" align="right" valign="top"><a id="aad1477116ad70d8741d38aaa118feb6d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidElementNum</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> etypenum, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const</td></tr>
<tr class="separator:aad1477116ad70d8741d38aaa118feb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e7eb11a5efb365738b563737a8c0d6"><td class="memItemLeft" align="right" valign="top"><a id="ad7e7eb11a5efb365738b563737a8c0d6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidElement</b> (ElementType etype, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const</td></tr>
<tr class="separator:ad7e7eb11a5efb365738b563737a8c0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446b4f78c7412c3db0cbfd8e6354d235"><td class="memItemLeft" align="right" valign="top"><a id="a446b4f78c7412c3db0cbfd8e6354d235"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidCell</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const</td></tr>
<tr class="separator:a446b4f78c7412c3db0cbfd8e6354d235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0be79beca155d5b76d857a4b71805ff"><td class="memItemLeft" align="right" valign="top"><a id="ab0be79beca155d5b76d857a4b71805ff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidFace</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const</td></tr>
<tr class="separator:ab0be79beca155d5b76d857a4b71805ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e384019c0bab0a2945e4d0a45379cf8"><td class="memItemLeft" align="right" valign="top"><a id="a3e384019c0bab0a2945e4d0a45379cf8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidEdge</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const</td></tr>
<tr class="separator:a3e384019c0bab0a2945e4d0a45379cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c306f22863e4995385296fe65ed96e3"><td class="memItemLeft" align="right" valign="top"><a id="a6c306f22863e4995385296fe65ed96e3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidNode</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const</td></tr>
<tr class="separator:a6c306f22863e4995385296fe65ed96e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f73377a022f6244544d079da17f8f5"><td class="memItemLeft" align="right" valign="top"><a id="ae3f73377a022f6244544d079da17f8f5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidElementSet</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const</td></tr>
<tr class="separator:ae3f73377a022f6244544d079da17f8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40fc20241ee383a9b52d727bad3f877"><td class="memItemLeft" align="right" valign="top"><a id="af40fc20241ee383a9b52d727bad3f877"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidElement</b> (HandleType h) const</td></tr>
<tr class="separator:af40fc20241ee383a9b52d727bad3f877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fd4e8639eaee4461608e33d6d10dbe"><td class="memItemLeft" align="right" valign="top">HandleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a97fd4e8639eaee4461608e33d6d10dbe">FindSharedAdjacency</a> (const HandleType *arr, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> num) const</td></tr>
<tr class="memdesc:a97fd4e8639eaee4461608e33d6d10dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve upper adjacent that is shared by multiple lower adjacencies.  <a href="classINMOST_1_1Mesh.html#a97fd4e8639eaee4461608e33d6d10dbe">More...</a><br /></td></tr>
<tr class="separator:a97fd4e8639eaee4461608e33d6d10dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5191aea52d0cb3b8719500bc98d72df"><td class="memItemLeft" align="right" valign="top"><a id="ae5191aea52d0cb3b8719500bc98d72df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ReorderEmpty</b> (ElementType reordertypes)</td></tr>
<tr class="separator:ae5191aea52d0cb3b8719500bc98d72df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1b5232061e8f615d962c55dc5397c6"><td class="memItemLeft" align="right" valign="top"><a id="acc1b5232061e8f615d962c55dc5397c6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ReorderApply</b> (<a class="el" href="classINMOST_1_1Tag.html">Tag</a> index, ElementType mask)</td></tr>
<tr class="separator:acc1b5232061e8f615d962c55dc5397c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e1126542b6778477ec51bf61dd35d1"><td class="memItemLeft" align="right" valign="top"><a id="a73e1126542b6778477ec51bf61dd35d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RestoreCellNodes</b> (HandleType hc, <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt; &amp;ret)</td></tr>
<tr class="separator:a73e1126542b6778477ec51bf61dd35d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa084c637bc9f6850ed77fbb7778d404"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#afa084c637bc9f6850ed77fbb7778d404">Real</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:afa084c637bc9f6850ed77fbb7778d404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to inner memory location of the first element of the array of real values.  <a href="classINMOST_1_1Mesh.html#afa084c637bc9f6850ed77fbb7778d404">More...</a><br /></td></tr>
<tr class="separator:afa084c637bc9f6850ed77fbb7778d404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d44832b3e826a2b61c8e91c5457fbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aa9d44832b3e826a2b61c8e91c5457fbf">Integer</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:aa9d44832b3e826a2b61c8e91c5457fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to inner memory location of the first element of the array of integer values.  <a href="classINMOST_1_1Mesh.html#aa9d44832b3e826a2b61c8e91c5457fbf">More...</a><br /></td></tr>
<tr class="separator:aa9d44832b3e826a2b61c8e91c5457fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df5a8793e5cd8e38182de107d381d9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a9df5a8793e5cd8e38182de107d381d9e">Bulk</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a9df5a8793e5cd8e38182de107d381d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference in inner representation to the first element of array of bytes.  <a href="classINMOST_1_1Mesh.html#a9df5a8793e5cd8e38182de107d381d9e">More...</a><br /></td></tr>
<tr class="separator:a9df5a8793e5cd8e38182de107d381d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa8b2f65d63edbbed90d865ab6f5314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a8674802045ec170a3c9d0e3281545b54">reference</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#acfa8b2f65d63edbbed90d865ab6f5314">Reference</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:acfa8b2f65d63edbbed90d865ab6f5314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference in an inner representation to the first element of array of element handles.  <a href="classINMOST_1_1Mesh.html#acfa8b2f65d63edbbed90d865ab6f5314">More...</a><br /></td></tr>
<tr class="separator:acfa8b2f65d63edbbed90d865ab6f5314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb599c441558cf1cdb40f37be8d0562"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a211e235d55d933c5dc3f7040e0b50504">remote_reference</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a6cb599c441558cf1cdb40f37be8d0562">RemoteReference</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a6cb599c441558cf1cdb40f37be8d0562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference in an inner representation to the first element of array of element remote handles.  <a href="classINMOST_1_1Mesh.html#a6cb599c441558cf1cdb40f37be8d0562">More...</a><br /></td></tr>
<tr class="separator:a6cb599c441558cf1cdb40f37be8d0562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bdd4e7c0d26750ca0aa40e03fc7d4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a430e5358d435befb38169beef593527e">real_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a06bdd4e7c0d26750ca0aa40e03fc7d4c">RealArray</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a06bdd4e7c0d26750ca0aa40e03fc7d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of real values.  <a href="classINMOST_1_1Mesh.html#a06bdd4e7c0d26750ca0aa40e03fc7d4c">More...</a><br /></td></tr>
<tr class="separator:a06bdd4e7c0d26750ca0aa40e03fc7d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0bbbfafae1405bd27b726bdbb4c2cdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a4d1637367f0487eb778894b57fc94647">integer_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ac0bbbfafae1405bd27b726bdbb4c2cdd">IntegerArray</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:ac0bbbfafae1405bd27b726bdbb4c2cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of integer values.  <a href="classINMOST_1_1Mesh.html#ac0bbbfafae1405bd27b726bdbb4c2cdd">More...</a><br /></td></tr>
<tr class="separator:ac0bbbfafae1405bd27b726bdbb4c2cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae496bab413c4a6103ee62ae3903e95fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a6e49b2a38cb55dd59529bd23e8b1b852">bulk_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ae496bab413c4a6103ee62ae3903e95fe">BulkArray</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:ae496bab413c4a6103ee62ae3903e95fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of bytes.  <a href="classINMOST_1_1Mesh.html#ae496bab413c4a6103ee62ae3903e95fe">More...</a><br /></td></tr>
<tr class="separator:ae496bab413c4a6103ee62ae3903e95fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac211da4cbe1dc33394c9b725b64b1e86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage_1_1reference__array.html">reference_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ac211da4cbe1dc33394c9b725b64b1e86">ReferenceArray</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:ac211da4cbe1dc33394c9b725b64b1e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of element handles.  <a href="classINMOST_1_1Mesh.html#ac211da4cbe1dc33394c9b725b64b1e86">More...</a><br /></td></tr>
<tr class="separator:ac211da4cbe1dc33394c9b725b64b1e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7759b6b5f4a79de76713c4cf1fda1dbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage_1_1remote__reference__array.html">remote_reference_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a7759b6b5f4a79de76713c4cf1fda1dbf">RemoteReferenceArray</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a7759b6b5f4a79de76713c4cf1fda1dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of element remote handles.  <a href="classINMOST_1_1Mesh.html#a7759b6b5f4a79de76713c4cf1fda1dbf">More...</a><br /></td></tr>
<tr class="separator:a7759b6b5f4a79de76713c4cf1fda1dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e88bbdedcf71c3226f3dc94da66807"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a90e88bbdedcf71c3226f3dc94da66807">RealDF</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a90e88bbdedcf71c3226f3dc94da66807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to inner memory location of the first element of the array of real values.  <a href="classINMOST_1_1Mesh.html#a90e88bbdedcf71c3226f3dc94da66807">More...</a><br /></td></tr>
<tr class="separator:a90e88bbdedcf71c3226f3dc94da66807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd3068d4db02871478bea86fce38945"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a3dd3068d4db02871478bea86fce38945">IntegerDF</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a3dd3068d4db02871478bea86fce38945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to inner memory location of the first element of the array of integer values.  <a href="classINMOST_1_1Mesh.html#a3dd3068d4db02871478bea86fce38945">More...</a><br /></td></tr>
<tr class="separator:a3dd3068d4db02871478bea86fce38945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88229181252531147051badf5a05e263"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a88229181252531147051badf5a05e263">BulkDF</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a88229181252531147051badf5a05e263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference in dense array to the first element of constant size array of bytes.  <a href="classINMOST_1_1Mesh.html#a88229181252531147051badf5a05e263">More...</a><br /></td></tr>
<tr class="separator:a88229181252531147051badf5a05e263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5abf1a33ab21a0c60338a97287fc115"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a8674802045ec170a3c9d0e3281545b54">reference</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ab5abf1a33ab21a0c60338a97287fc115">ReferenceDF</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:ab5abf1a33ab21a0c60338a97287fc115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference in dense array to the first element of constant size array of element handles.  <a href="classINMOST_1_1Mesh.html#ab5abf1a33ab21a0c60338a97287fc115">More...</a><br /></td></tr>
<tr class="separator:ab5abf1a33ab21a0c60338a97287fc115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdb38e9a9120e954ef1c4d7b912c591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a211e235d55d933c5dc3f7040e0b50504">remote_reference</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a4fdb38e9a9120e954ef1c4d7b912c591">RemoteReferenceDF</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a4fdb38e9a9120e954ef1c4d7b912c591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference in dense array to the first element of constant size array of element remote handles.  <a href="classINMOST_1_1Mesh.html#a4fdb38e9a9120e954ef1c4d7b912c591">More...</a><br /></td></tr>
<tr class="separator:a4fdb38e9a9120e954ef1c4d7b912c591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8527fa3c2f6ece108b5abce389566365"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a430e5358d435befb38169beef593527e">real_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a8527fa3c2f6ece108b5abce389566365">RealArrayDF</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a8527fa3c2f6ece108b5abce389566365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of real values in dense array.  <a href="classINMOST_1_1Mesh.html#a8527fa3c2f6ece108b5abce389566365">More...</a><br /></td></tr>
<tr class="separator:a8527fa3c2f6ece108b5abce389566365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5351b2b6e7f7824598cb46b3c35118"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a4d1637367f0487eb778894b57fc94647">integer_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a9d5351b2b6e7f7824598cb46b3c35118">IntegerArrayDF</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a9d5351b2b6e7f7824598cb46b3c35118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of integer values in dense array.  <a href="classINMOST_1_1Mesh.html#a9d5351b2b6e7f7824598cb46b3c35118">More...</a><br /></td></tr>
<tr class="separator:a9d5351b2b6e7f7824598cb46b3c35118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d63f6a251db48695306180f22ff67e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a6e49b2a38cb55dd59529bd23e8b1b852">bulk_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a53d63f6a251db48695306180f22ff67e">BulkArrayDF</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a53d63f6a251db48695306180f22ff67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of bytes in dense array.  <a href="classINMOST_1_1Mesh.html#a53d63f6a251db48695306180f22ff67e">More...</a><br /></td></tr>
<tr class="separator:a53d63f6a251db48695306180f22ff67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ba4c935940111e2c9584a9cc96fe6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage_1_1reference__array.html">reference_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a92ba4c935940111e2c9584a9cc96fe6f">ReferenceArrayDF</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a92ba4c935940111e2c9584a9cc96fe6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of element handles in dense array.  <a href="classINMOST_1_1Mesh.html#a92ba4c935940111e2c9584a9cc96fe6f">More...</a><br /></td></tr>
<tr class="separator:a92ba4c935940111e2c9584a9cc96fe6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9375f7cdff4c060bb765028c95a9e73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage_1_1remote__reference__array.html">remote_reference_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aa9375f7cdff4c060bb765028c95a9e73">RemoteReferenceArrayDF</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:aa9375f7cdff4c060bb765028c95a9e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of element remote handles in dense array.  <a href="classINMOST_1_1Mesh.html#aa9375f7cdff4c060bb765028c95a9e73">More...</a><br /></td></tr>
<tr class="separator:aa9375f7cdff4c060bb765028c95a9e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679a4a6ed4e4508126919b8fc8fea27a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a679a4a6ed4e4508126919b8fc8fea27a">RealDV</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a679a4a6ed4e4508126919b8fc8fea27a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference in dense array to the first element of variable size array of real values.  <a href="classINMOST_1_1Mesh.html#a679a4a6ed4e4508126919b8fc8fea27a">More...</a><br /></td></tr>
<tr class="separator:a679a4a6ed4e4508126919b8fc8fea27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20ebec0bab305054c5960d7683bfcfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#af20ebec0bab305054c5960d7683bfcfd">IntegerDV</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:af20ebec0bab305054c5960d7683bfcfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference in dense array to the first element of variable size array of integer values.  <a href="classINMOST_1_1Mesh.html#af20ebec0bab305054c5960d7683bfcfd">More...</a><br /></td></tr>
<tr class="separator:af20ebec0bab305054c5960d7683bfcfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a62a1c63ac51297dddabb1312f32d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a35a62a1c63ac51297dddabb1312f32d1">BulkDV</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a35a62a1c63ac51297dddabb1312f32d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference in dense array to the first element of variable size array of bytes.  <a href="classINMOST_1_1Mesh.html#a35a62a1c63ac51297dddabb1312f32d1">More...</a><br /></td></tr>
<tr class="separator:a35a62a1c63ac51297dddabb1312f32d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87430b220565362949e68b073e07c8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a8674802045ec170a3c9d0e3281545b54">reference</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ac87430b220565362949e68b073e07c8a">ReferenceDV</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:ac87430b220565362949e68b073e07c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference in dense array to the first element of variable size array of element handles.  <a href="classINMOST_1_1Mesh.html#ac87430b220565362949e68b073e07c8a">More...</a><br /></td></tr>
<tr class="separator:ac87430b220565362949e68b073e07c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74af68d7c80c8b6b8259cfb68e47dd16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a211e235d55d933c5dc3f7040e0b50504">remote_reference</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a74af68d7c80c8b6b8259cfb68e47dd16">RemoteReferenceDV</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a74af68d7c80c8b6b8259cfb68e47dd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference in dense array to the first element of variable size array of element remote handles.  <a href="classINMOST_1_1Mesh.html#a74af68d7c80c8b6b8259cfb68e47dd16">More...</a><br /></td></tr>
<tr class="separator:a74af68d7c80c8b6b8259cfb68e47dd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a5f7d22e5b9f7c01b9741719b853dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a430e5358d435befb38169beef593527e">real_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ae7a5f7d22e5b9f7c01b9741719b853dc">RealArrayDV</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:ae7a5f7d22e5b9f7c01b9741719b853dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of real values in dense array of variable size.  <a href="classINMOST_1_1Mesh.html#ae7a5f7d22e5b9f7c01b9741719b853dc">More...</a><br /></td></tr>
<tr class="separator:ae7a5f7d22e5b9f7c01b9741719b853dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74aed700689551567039dfddfbf5971"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a4d1637367f0487eb778894b57fc94647">integer_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ad74aed700689551567039dfddfbf5971">IntegerArrayDV</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:ad74aed700689551567039dfddfbf5971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of integer values in dense array of variable size.  <a href="classINMOST_1_1Mesh.html#ad74aed700689551567039dfddfbf5971">More...</a><br /></td></tr>
<tr class="separator:ad74aed700689551567039dfddfbf5971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042974abc70e48b9dc84714ca1a50655"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a6e49b2a38cb55dd59529bd23e8b1b852">bulk_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a042974abc70e48b9dc84714ca1a50655">BulkArrayDV</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a042974abc70e48b9dc84714ca1a50655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of bytes in dense array of variable size.  <a href="classINMOST_1_1Mesh.html#a042974abc70e48b9dc84714ca1a50655">More...</a><br /></td></tr>
<tr class="separator:a042974abc70e48b9dc84714ca1a50655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a8c6f6d53a863be14b2c137de4eff5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage_1_1reference__array.html">reference_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aa2a8c6f6d53a863be14b2c137de4eff5">ReferenceArrayDV</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:aa2a8c6f6d53a863be14b2c137de4eff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of element handles in dense array of variable size.  <a href="classINMOST_1_1Mesh.html#aa2a8c6f6d53a863be14b2c137de4eff5">More...</a><br /></td></tr>
<tr class="separator:aa2a8c6f6d53a863be14b2c137de4eff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610fbebb7fb4d1b0c4103fc5b3a37170"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage_1_1remote__reference__array.html">remote_reference_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a610fbebb7fb4d1b0c4103fc5b3a37170">RemoteReferenceArrayDV</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a610fbebb7fb4d1b0c4103fc5b3a37170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of element remote handles in dense array of variable size.  <a href="classINMOST_1_1Mesh.html#a610fbebb7fb4d1b0c4103fc5b3a37170">More...</a><br /></td></tr>
<tr class="separator:a610fbebb7fb4d1b0c4103fc5b3a37170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b421003de19dbff80dc5975cd139fc1"><td class="memItemLeft" align="right" valign="top"><a id="a9b421003de19dbff80dc5975cd139fc1"></a>
<a class="el" href="classINMOST_1_1Storage.html#a26add298824745e27a977a633d436c21">var</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Variable</b> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="separator:a9b421003de19dbff80dc5975cd139fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fcb04c85cea94c9dbfdc12791fe4f4f"><td class="memItemLeft" align="right" valign="top"><a id="a6fcb04c85cea94c9dbfdc12791fe4f4f"></a>
<a class="el" href="classINMOST_1_1Storage.html#a26add298824745e27a977a633d436c21">var</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>VariableDF</b> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="separator:a6fcb04c85cea94c9dbfdc12791fe4f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8af34264dcfcf869b7ee970d87d3c9"><td class="memItemLeft" align="right" valign="top"><a id="a3d8af34264dcfcf869b7ee970d87d3c9"></a>
<a class="el" href="classINMOST_1_1Storage.html#a26add298824745e27a977a633d436c21">var</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>VariableDV</b> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="separator:a3d8af34264dcfcf869b7ee970d87d3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544a85f3724a57e61aec8bbd28b0fef1"><td class="memItemLeft" align="right" valign="top"><a id="a544a85f3724a57e61aec8bbd28b0fef1"></a>
<a class="el" href="classINMOST_1_1Storage.html#a7412664cc3faf19cdaf391a97ac46b59">var_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>VariableArray</b> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="separator:a544a85f3724a57e61aec8bbd28b0fef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2229cce6dd3256af03af46a30f951b0"><td class="memItemLeft" align="right" valign="top"><a id="ab2229cce6dd3256af03af46a30f951b0"></a>
<a class="el" href="classINMOST_1_1Storage.html#a7412664cc3faf19cdaf391a97ac46b59">var_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>VariableArrayDF</b> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="separator:ab2229cce6dd3256af03af46a30f951b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bec74e7592ab6fc9b9e5b7c97740313"><td class="memItemLeft" align="right" valign="top"><a id="a5bec74e7592ab6fc9b9e5b7c97740313"></a>
<a class="el" href="classINMOST_1_1Storage.html#a7412664cc3faf19cdaf391a97ac46b59">var_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>VariableArrayDV</b> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="separator:a5bec74e7592ab6fc9b9e5b7c97740313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56670d2eca32f6af4bdd9c18a160dc81"><td class="memItemLeft" align="right" valign="top">__INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a56670d2eca32f6af4bdd9c18a160dc81">SetMarker</a> (HandleType h, MarkerType n)</td></tr>
<tr class="memdesc:a56670d2eca32f6af4bdd9c18a160dc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a marker on the element represented by handle.  <a href="classINMOST_1_1Mesh.html#a56670d2eca32f6af4bdd9c18a160dc81">More...</a><br /></td></tr>
<tr class="separator:a56670d2eca32f6af4bdd9c18a160dc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be4fb19b5b9511a2b9d6c5c595997b4"><td class="memItemLeft" align="right" valign="top"><a id="a3be4fb19b5b9511a2b9d6c5c595997b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetPrivateMarker</b> (HandleType h, MarkerType n)</td></tr>
<tr class="separator:a3be4fb19b5b9511a2b9d6c5c595997b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58894a249c136bf2ece10bdbe9d8c93c"><td class="memItemLeft" align="right" valign="top"><a id="a58894a249c136bf2ece10bdbe9d8c93c"></a>
__INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>SetAnyMarker</b> (HandleType h, MarkerType n)</td></tr>
<tr class="separator:a58894a249c136bf2ece10bdbe9d8c93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8df87a8d03de319611d696f1fed6acf"><td class="memItemLeft" align="right" valign="top">__INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ac8df87a8d03de319611d696f1fed6acf">SetMarkerArray</a> (const HandleType *h, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> n, MarkerType m)</td></tr>
<tr class="memdesc:ac8df87a8d03de319611d696f1fed6acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a marker on the set of handles.  <a href="classINMOST_1_1Mesh.html#ac8df87a8d03de319611d696f1fed6acf">More...</a><br /></td></tr>
<tr class="separator:ac8df87a8d03de319611d696f1fed6acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8351e223dff35a7ce652f32e438ca638"><td class="memItemLeft" align="right" valign="top"><a id="a8351e223dff35a7ce652f32e438ca638"></a>
__INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>SetPrivateMarkerArray</b> (const HandleType *h, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> n, MarkerType m)</td></tr>
<tr class="separator:a8351e223dff35a7ce652f32e438ca638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3fe4c29b066e1787375bb8ab5e2c50"><td class="memItemLeft" align="right" valign="top"><a id="a5e3fe4c29b066e1787375bb8ab5e2c50"></a>
__INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>SetAnyMarkerArray</b> (const HandleType *h, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> n, MarkerType m)</td></tr>
<tr class="separator:a5e3fe4c29b066e1787375bb8ab5e2c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fb28d26004e1f3c4c7aa8b291ecdab"><td class="memItemLeft" align="right" valign="top">__INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a91fb28d26004e1f3c4c7aa8b291ecdab">GetMarker</a> (HandleType h, MarkerType n) const</td></tr>
<tr class="memdesc:a91fb28d26004e1f3c4c7aa8b291ecdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the marker is set one the element.  <a href="classINMOST_1_1Mesh.html#a91fb28d26004e1f3c4c7aa8b291ecdab">More...</a><br /></td></tr>
<tr class="separator:a91fb28d26004e1f3c4c7aa8b291ecdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f809bee2484ed3e22885d19b3d7172e"><td class="memItemLeft" align="right" valign="top"><a id="a2f809bee2484ed3e22885d19b3d7172e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetPrivateMarker</b> (HandleType h, MarkerType n) const</td></tr>
<tr class="separator:a2f809bee2484ed3e22885d19b3d7172e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f5bd586b5afcc469bdaa3a18426e54"><td class="memItemLeft" align="right" valign="top"><a id="a44f5bd586b5afcc469bdaa3a18426e54"></a>
__INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetAnyMarker</b> (HandleType h, MarkerType n) const</td></tr>
<tr class="separator:a44f5bd586b5afcc469bdaa3a18426e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2820b01ab65f402c31a03158a3ebd76c"><td class="memItemLeft" align="right" valign="top">__INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a2820b01ab65f402c31a03158a3ebd76c">RemMarker</a> (HandleType h, MarkerType n)</td></tr>
<tr class="memdesc:a2820b01ab65f402c31a03158a3ebd76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the marker from the element.  <a href="classINMOST_1_1Mesh.html#a2820b01ab65f402c31a03158a3ebd76c">More...</a><br /></td></tr>
<tr class="separator:a2820b01ab65f402c31a03158a3ebd76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5e1885988a4ac1e0beb326422da8e6"><td class="memItemLeft" align="right" valign="top"><a id="a9a5e1885988a4ac1e0beb326422da8e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RemPrivateMarker</b> (HandleType h, MarkerType n)</td></tr>
<tr class="separator:a9a5e1885988a4ac1e0beb326422da8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede7dd4262ae7df8a5f8ecbf4258eb6b"><td class="memItemLeft" align="right" valign="top"><a id="aede7dd4262ae7df8a5f8ecbf4258eb6b"></a>
__INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>RemAnyMarker</b> (HandleType h, MarkerType n)</td></tr>
<tr class="separator:aede7dd4262ae7df8a5f8ecbf4258eb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f8614996be1f7dd81825a447e9f4e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a14f8614996be1f7dd81825a447e9f4e8">RemMarkerArray</a> (const HandleType *h, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> n, MarkerType m)</td></tr>
<tr class="memdesc:a14f8614996be1f7dd81825a447e9f4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the marker from the set of handles.  <a href="classINMOST_1_1Mesh.html#a14f8614996be1f7dd81825a447e9f4e8">More...</a><br /></td></tr>
<tr class="separator:a14f8614996be1f7dd81825a447e9f4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecd1a36ff0b30e86a34b2c995751577"><td class="memItemLeft" align="right" valign="top"><a id="a4ecd1a36ff0b30e86a34b2c995751577"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RemPrivateMarkerArray</b> (const HandleType *h, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> n, MarkerType m)</td></tr>
<tr class="separator:a4ecd1a36ff0b30e86a34b2c995751577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b688c3af40eeef80d7d365c56be193f"><td class="memItemLeft" align="right" valign="top"><a id="a4b688c3af40eeef80d7d365c56be193f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a4b688c3af40eeef80d7d365c56be193f">ClearMarkerSpace</a> (HandleType h)</td></tr>
<tr class="memdesc:a4b688c3af40eeef80d7d365c56be193f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all the markers from the element. <br /></td></tr>
<tr class="separator:a4b688c3af40eeef80d7d365c56be193f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851aa9f4f849695e3fca2c387e3e5196"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a851aa9f4f849695e3fca2c387e3e5196">GetMarkerSpace</a> (HandleType h, <a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a> copy[MarkerFields]) const</td></tr>
<tr class="memdesc:a851aa9f4f849695e3fca2c387e3e5196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the bytes that store markers on the element.  <a href="classINMOST_1_1Mesh.html#a851aa9f4f849695e3fca2c387e3e5196">More...</a><br /></td></tr>
<tr class="separator:a851aa9f4f849695e3fca2c387e3e5196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcd74b16a7a86db78d2cf5bb814f5a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aadcd74b16a7a86db78d2cf5bb814f5a3">SetMarkerSpace</a> (HandleType h, <a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a> source[MarkerFields])</td></tr>
<tr class="memdesc:aadcd74b16a7a86db78d2cf5bb814f5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite the bytes that store markers on the element.  <a href="classINMOST_1_1Mesh.html#aadcd74b16a7a86db78d2cf5bb814f5a3">More...</a><br /></td></tr>
<tr class="separator:aadcd74b16a7a86db78d2cf5bb814f5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7462d775868bb6ef687cef8a5198cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1array.html">Element::adj_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a1e7462d775868bb6ef687cef8a5198cb">HighConn</a> (HandleType h)</td></tr>
<tr class="memdesc:a1e7462d775868bb6ef687cef8a5198cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access directly higher order adjacencies of current element with right of modification.  <a href="classINMOST_1_1Mesh.html#a1e7462d775868bb6ef687cef8a5198cb">More...</a><br /></td></tr>
<tr class="separator:a1e7462d775868bb6ef687cef8a5198cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39817a2ee5b491d82a294b94e30c0d4"><td class="memItemLeft" align="right" valign="top"><a id="ab39817a2ee5b491d82a294b94e30c0d4"></a>
ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ab39817a2ee5b491d82a294b94e30c0d4">HaveUpperAdjacencies</a> () const</td></tr>
<tr class="memdesc:ab39817a2ee5b491d82a294b94e30c0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that upper adjacencies are stored. <br /></td></tr>
<tr class="separator:ab39817a2ee5b491d82a294b94e30c0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd220800a414542d2180781ba9a3ec1"><td class="memItemLeft" align="right" valign="top"><a id="a5fd220800a414542d2180781ba9a3ec1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a5fd220800a414542d2180781ba9a3ec1">RemoveUpperAdjacencies</a> (ElementType mask=(NODE|EDGE|FACE))</td></tr>
<tr class="memdesc:a5fd220800a414542d2180781ba9a3ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all upper adjacencies, access to HighConn should fire assertion and retrieval of upper adjacencies is no longer valid. <br /></td></tr>
<tr class="separator:a5fd220800a414542d2180781ba9a3ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d59212ecc5594a35e874c2ab546d8c6"><td class="memItemLeft" align="right" valign="top"><a id="a3d59212ecc5594a35e874c2ab546d8c6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a3d59212ecc5594a35e874c2ab546d8c6">RestoreUpperAdjacencies</a> (ElementType mask=(NODE|EDGE|FACE))</td></tr>
<tr class="memdesc:a3d59212ecc5594a35e874c2ab546d8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore all upper adjacencies. <br /></td></tr>
<tr class="separator:a3d59212ecc5594a35e874c2ab546d8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e0913eec41fb88a05eab207243d01c"><td class="memItemLeft" align="right" valign="top"><a id="a43e0913eec41fb88a05eab207243d01c"></a>
ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a43e0913eec41fb88a05eab207243d01c">HaveLowerAdjacencies</a> () const</td></tr>
<tr class="memdesc:a43e0913eec41fb88a05eab207243d01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that upper adjacencies are stored. <br /></td></tr>
<tr class="separator:a43e0913eec41fb88a05eab207243d01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0964577b1d2cd6fb1ad172ba12602c"><td class="memItemLeft" align="right" valign="top"><a id="a3b0964577b1d2cd6fb1ad172ba12602c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a3b0964577b1d2cd6fb1ad172ba12602c">RemoveLowerAdjacencies</a> (ElementType mask=(EDGE|FACE|CELL))</td></tr>
<tr class="memdesc:a3b0964577b1d2cd6fb1ad172ba12602c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all upper adjacencies, access to HighConn should fire assertion and retrieval of upper adjacencies is no longer valid. <br /></td></tr>
<tr class="separator:a3b0964577b1d2cd6fb1ad172ba12602c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e968713b28788247a42bda07344eeb"><td class="memItemLeft" align="right" valign="top"><a id="a91e968713b28788247a42bda07344eeb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a91e968713b28788247a42bda07344eeb">RestoreLowerAdjacencies</a> (ElementType mask=(EDGE|FACE|CELL))</td></tr>
<tr class="memdesc:a91e968713b28788247a42bda07344eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore all upper adjacencies. <br /></td></tr>
<tr class="separator:a91e968713b28788247a42bda07344eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4990122a06138844b19ff1fb16e638b6"><td class="memItemLeft" align="right" valign="top"><a id="a4990122a06138844b19ff1fb16e638b6"></a>
<a class="el" href="classINMOST_1_1array.html">Element::adj_type</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a4990122a06138844b19ff1fb16e638b6">HighConn</a> (HandleType h) const</td></tr>
<tr class="memdesc:a4990122a06138844b19ff1fb16e638b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access directly higher order adjacencies of current element without right of modification. <br /></td></tr>
<tr class="separator:a4990122a06138844b19ff1fb16e638b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20f64a301adf9c3fafe28a8f921a791"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1array.html">Element::adj_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ad20f64a301adf9c3fafe28a8f921a791">LowConn</a> (HandleType h)</td></tr>
<tr class="memdesc:ad20f64a301adf9c3fafe28a8f921a791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access directly lower order adjacencies of current element with right of modification.  <a href="classINMOST_1_1Mesh.html#ad20f64a301adf9c3fafe28a8f921a791">More...</a><br /></td></tr>
<tr class="separator:ad20f64a301adf9c3fafe28a8f921a791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbea0322e1896291cd9e452df55fe89e"><td class="memItemLeft" align="right" valign="top"><a id="afbea0322e1896291cd9e452df55fe89e"></a>
<a class="el" href="classINMOST_1_1array.html">Element::adj_type</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#afbea0322e1896291cd9e452df55fe89e">LowConn</a> (HandleType h) const</td></tr>
<tr class="memdesc:afbea0322e1896291cd9e452df55fe89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access directly lower order adjacencies of current element without right of modification. <br /></td></tr>
<tr class="separator:afbea0322e1896291cd9e452df55fe89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069440f8fcef7797d8bc6fee41e0069c"><td class="memItemLeft" align="right" valign="top">INMOST_DATA_ENUM_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a069440f8fcef7797d8bc6fee41e0069c">GetDataSize</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="memdesc:a069440f8fcef7797d8bc6fee41e0069c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the array.  <a href="classINMOST_1_1Mesh.html#a069440f8fcef7797d8bc6fee41e0069c">More...</a><br /></td></tr>
<tr class="separator:a069440f8fcef7797d8bc6fee41e0069c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285e4114d858ae4df1232161ac62acad"><td class="memItemLeft" align="right" valign="top">INMOST_DATA_ENUM_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a285e4114d858ae4df1232161ac62acad">GetDataCapacity</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="memdesc:a285e4114d858ae4df1232161ac62acad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the structure in bytes required to represent the data on current element.  <a href="classINMOST_1_1Mesh.html#a285e4114d858ae4df1232161ac62acad">More...</a><br /></td></tr>
<tr class="separator:a285e4114d858ae4df1232161ac62acad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa110839ebe411d43f2f25b3b912793a4"><td class="memItemLeft" align="right" valign="top">INMOST_DATA_ENUM_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aa110839ebe411d43f2f25b3b912793a4">GetDataCapacity</a> (const INMOST_DATA_BULK_TYPE *data, INMOST_DATA_ENUM_TYPE size, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="memdesc:aa110839ebe411d43f2f25b3b912793a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes in data used for given type of tag.  <a href="classINMOST_1_1Mesh.html#aa110839ebe411d43f2f25b3b912793a4">More...</a><br /></td></tr>
<tr class="separator:aa110839ebe411d43f2f25b3b912793a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ade9beb68c97be47897b50ce6e4dcb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a8ade9beb68c97be47897b50ce6e4dcb6">SetDataSize</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> new_size)</td></tr>
<tr class="memdesc:a8ade9beb68c97be47897b50ce6e4dcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the array for data of variable size.  <a href="classINMOST_1_1Mesh.html#a8ade9beb68c97be47897b50ce6e4dcb6">More...</a><br /></td></tr>
<tr class="separator:a8ade9beb68c97be47897b50ce6e4dcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06563442cfd581928b1f323daa151389"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a06563442cfd581928b1f323daa151389">GetData</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> shift, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> size, void *data) const</td></tr>
<tr class="memdesc:a06563442cfd581928b1f323daa151389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy inner data array of size elements to provided array beginning from shift element.  <a href="classINMOST_1_1Mesh.html#a06563442cfd581928b1f323daa151389">More...</a><br /></td></tr>
<tr class="separator:a06563442cfd581928b1f323daa151389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e40d1712147e6dc39113d855882743e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a2e40d1712147e6dc39113d855882743e">SetData</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> shift, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> size, const void *data)</td></tr>
<tr class="memdesc:a2e40d1712147e6dc39113d855882743e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy into inner data array of size elements from provided array beginning from shift element.  <a href="classINMOST_1_1Mesh.html#a2e40d1712147e6dc39113d855882743e">More...</a><br /></td></tr>
<tr class="separator:a2e40d1712147e6dc39113d855882743e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab20c754eef0006e3085dc546e893bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#afab20c754eef0006e3085dc546e893bb">DelData</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:afab20c754eef0006e3085dc546e893bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove tag data from given element.  <a href="classINMOST_1_1Mesh.html#afab20c754eef0006e3085dc546e893bb">More...</a><br /></td></tr>
<tr class="separator:afab20c754eef0006e3085dc546e893bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac72292a681f80f9f112566e3c04bc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#abac72292a681f80f9f112566e3c04bc5">DelDenseData</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:abac72292a681f80f9f112566e3c04bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes data of variable size, clears to zero data of fixed size.  <a href="classINMOST_1_1Mesh.html#abac72292a681f80f9f112566e3c04bc5">More...</a><br /></td></tr>
<tr class="separator:abac72292a681f80f9f112566e3c04bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc7b729335ae0490f855bf560ad8553"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a5cc7b729335ae0490f855bf560ad8553">DelDenseData</a> (void *data, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a5cc7b729335ae0490f855bf560ad8553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes data of variable size, clears to zero data of fixed size.  <a href="classINMOST_1_1Mesh.html#a5cc7b729335ae0490f855bf560ad8553">More...</a><br /></td></tr>
<tr class="separator:a5cc7b729335ae0490f855bf560ad8553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1a1d2343274836b3a74e615e057b9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a4e1a1d2343274836b3a74e615e057b9b">DelSparseData</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a4e1a1d2343274836b3a74e615e057b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes data of variable size and sparse tag data.  <a href="classINMOST_1_1Mesh.html#a4e1a1d2343274836b3a74e615e057b9b">More...</a><br /></td></tr>
<tr class="separator:a4e1a1d2343274836b3a74e615e057b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f07de278c0d245577192b66b809118"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a77f07de278c0d245577192b66b809118">HaveData</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="memdesc:a77f07de278c0d245577192b66b809118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether data is present on given element.  <a href="classINMOST_1_1Mesh.html#a77f07de278c0d245577192b66b809118">More...</a><br /></td></tr>
<tr class="separator:a77f07de278c0d245577192b66b809118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5048ebdfea161a46e7e69b1f9fac409"><td class="memItemLeft" align="right" valign="top"><a id="aa5048ebdfea161a46e7e69b1f9fac409"></a>
Element::GeometricType&#160;</td><td class="memItemRight" valign="bottom"><b>GetGeometricType</b> (HandleType h) const</td></tr>
<tr class="separator:aa5048ebdfea161a46e7e69b1f9fac409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497dd8d40df1e33fd3040056a7922549"><td class="memItemLeft" align="right" valign="top"><a id="a497dd8d40df1e33fd3040056a7922549"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetGeometricType</b> (HandleType h, Element::GeometricType type)</td></tr>
<tr class="separator:a497dd8d40df1e33fd3040056a7922549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f84a185381a0096fc358e7e2ff5db7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ab9f84a185381a0096fc358e7e2ff5db7">GlobalID</a> (HandleType h)</td></tr>
<tr class="memdesc:ab9f84a185381a0096fc358e7e2ff5db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve global id of the element with right of modification (dangerous to modify).  <a href="classINMOST_1_1Mesh.html#ab9f84a185381a0096fc358e7e2ff5db7">More...</a><br /></td></tr>
<tr class="separator:ab9f84a185381a0096fc358e7e2ff5db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4d944b04580540e53d95017404788f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#adf4d944b04580540e53d95017404788f">GlobalID</a> (HandleType h) const</td></tr>
<tr class="memdesc:adf4d944b04580540e53d95017404788f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve global id of the element without right of modification.  <a href="classINMOST_1_1Mesh.html#adf4d944b04580540e53d95017404788f">More...</a><br /></td></tr>
<tr class="separator:adf4d944b04580540e53d95017404788f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cea6fbb28e02e8068289475f5d0b99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a17cea6fbb28e02e8068289475f5d0b99">DataLocalID</a> (HandleType h) const</td></tr>
<tr class="memdesc:a17cea6fbb28e02e8068289475f5d0b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve position of the data position of current element.  <a href="classINMOST_1_1Mesh.html#a17cea6fbb28e02e8068289475f5d0b99">More...</a><br /></td></tr>
<tr class="separator:a17cea6fbb28e02e8068289475f5d0b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b96761783011c7f0c1fdad296ceb31"><td class="memItemLeft" align="right" valign="top">Element::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ac4b96761783011c7f0c1fdad296ceb31">GetStatus</a> (HandleType h) const</td></tr>
<tr class="memdesc:ac4b96761783011c7f0c1fdad296ceb31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve parallel status of the element.  <a href="classINMOST_1_1Mesh.html#ac4b96761783011c7f0c1fdad296ceb31">More...</a><br /></td></tr>
<tr class="separator:ac4b96761783011c7f0c1fdad296ceb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666201ee66a5a0f871d17781055b06ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a666201ee66a5a0f871d17781055b06ac">SetStatus</a> (HandleType h, Element::Status s)</td></tr>
<tr class="memdesc:a666201ee66a5a0f871d17781055b06ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set parallel status of the element.  <a href="classINMOST_1_1Mesh.html#a666201ee66a5a0f871d17781055b06ac">More...</a><br /></td></tr>
<tr class="separator:a666201ee66a5a0f871d17781055b06ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2c090ee95e802c4f486a5d98fc6cb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a0e2c090ee95e802c4f486a5d98fc6cb0">Destroy</a> (HandleType h)</td></tr>
<tr class="memdesc:a0e2c090ee95e802c4f486a5d98fc6cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completely destroy element from mesh.  <a href="classINMOST_1_1Mesh.html#a0e2c090ee95e802c4f486a5d98fc6cb0">More...</a><br /></td></tr>
<tr class="separator:a0e2c090ee95e802c4f486a5d98fc6cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656d48f7478afdc5240295ad97929dab"><td class="memItemLeft" align="right" valign="top"><a id="a656d48f7478afdc5240295ad97929dab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a656d48f7478afdc5240295ad97929dab">Destroy</a> (const <a class="el" href="classINMOST_1_1Storage.html">Storage</a> &amp;e)</td></tr>
<tr class="memdesc:a656d48f7478afdc5240295ad97929dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut for typed elements. <br /></td></tr>
<tr class="separator:a656d48f7478afdc5240295ad97929dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3eaaadcd233cf11deba24d1fd64ad1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a2b3eaaadcd233cf11deba24d1fd64ad1">Hide</a> (HandleType h)</td></tr>
<tr class="memdesc:a2b3eaaadcd233cf11deba24d1fd64ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hide element from mesh.  <a href="classINMOST_1_1Mesh.html#a2b3eaaadcd233cf11deba24d1fd64ad1">More...</a><br /></td></tr>
<tr class="separator:a2b3eaaadcd233cf11deba24d1fd64ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfe7b75e432280922bfa7293743115c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a3bfe7b75e432280922bfa7293743115c">Show</a> (HandleType h)</td></tr>
<tr class="memdesc:a3bfe7b75e432280922bfa7293743115c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show element from mesh.  <a href="classINMOST_1_1Mesh.html#a3bfe7b75e432280922bfa7293743115c">More...</a><br /></td></tr>
<tr class="separator:a3bfe7b75e432280922bfa7293743115c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569c516120df121980d0585deadd3634"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a569c516120df121980d0585deadd3634">Delete</a> (HandleType h)</td></tr>
<tr class="memdesc:a569c516120df121980d0585deadd3634"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will hide element in modification state (between BeginModification and EndModification) or call Destroy in non-modification state.  <a href="classINMOST_1_1Mesh.html#a569c516120df121980d0585deadd3634">More...</a><br /></td></tr>
<tr class="separator:a569c516120df121980d0585deadd3634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7703ed18e5fb15efe6e878acd7f2b119"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a7703ed18e5fb15efe6e878acd7f2b119">Hidden</a> (HandleType h) const</td></tr>
<tr class="memdesc:a7703ed18e5fb15efe6e878acd7f2b119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether element is hidden.  <a href="classINMOST_1_1Mesh.html#a7703ed18e5fb15efe6e878acd7f2b119">More...</a><br /></td></tr>
<tr class="separator:a7703ed18e5fb15efe6e878acd7f2b119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473a038fc2a9f9ba422dc17ea60114a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a473a038fc2a9f9ba422dc17ea60114a0">New</a> (HandleType h) const</td></tr>
<tr class="memdesc:a473a038fc2a9f9ba422dc17ea60114a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether element is new.  <a href="classINMOST_1_1Mesh.html#a473a038fc2a9f9ba422dc17ea60114a0">More...</a><br /></td></tr>
<tr class="separator:a473a038fc2a9f9ba422dc17ea60114a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887f25126d7a0fc38e238e5c2b033d58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a887f25126d7a0fc38e238e5c2b033d58">ComputeGeometricType</a> (HandleType h)</td></tr>
<tr class="memdesc:a887f25126d7a0fc38e238e5c2b033d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recompute geometrical type of current element and set it to element.  <a href="classINMOST_1_1Mesh.html#a887f25126d7a0fc38e238e5c2b033d58">More...</a><br /></td></tr>
<tr class="separator:a887f25126d7a0fc38e238e5c2b033d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09727abab2781d3fbbcff23ca064777b"><td class="memItemLeft" align="right" valign="top"><a id="a09727abab2781d3fbbcff23ca064777b"></a>
INMOST_DATA_ENUM_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a09727abab2781d3fbbcff23ca064777b">GetArrayCapacity</a> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> etypenum)</td></tr>
<tr class="memdesc:a09727abab2781d3fbbcff23ca064777b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is needed by <a class="el" href="classINMOST_1_1TagManager.html">TagManager</a>, may be made private in future follows definition of <a class="el" href="classINMOST_1_1chunk__array.html">chunk_array</a> to estimate current occupancy of arrays. <br /></td></tr>
<tr class="separator:a09727abab2781d3fbbcff23ca064777b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6d4d7e0051555693f9bb5998087598"><td class="memItemLeft" align="right" valign="top"><a id="a2a6d4d7e0051555693f9bb5998087598"></a>
HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>FindSharedGhost</b> (ElementType etype, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">Storage::integer</a> global_id, int source_proc, int owner_proc)</td></tr>
<tr class="separator:a2a6d4d7e0051555693f9bb5998087598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9740bf2efd3376eebf74f62722fc63"><td class="memItemLeft" align="right" valign="top"><a id="afb9740bf2efd3376eebf74f62722fc63"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ClearFile</b> ()</td></tr>
<tr class="separator:afb9740bf2efd3376eebf74f62722fc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e45b137719114d78119bfe487be259f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a2e45b137719114d78119bfe487be259f">SetParallelFileStrategy</a> (int strategy)</td></tr>
<tr class="memdesc:a2e45b137719114d78119bfe487be259f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set parallel strategy for inner communications.  <a href="classINMOST_1_1Mesh.html#a2e45b137719114d78119bfe487be259f">More...</a><br /></td></tr>
<tr class="separator:a2e45b137719114d78119bfe487be259f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74339d3cdcf08469453ff198be689833"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a74339d3cdcf08469453ff198be689833">GetParallelFileStrategy</a> () const</td></tr>
<tr class="memdesc:a74339d3cdcf08469453ff198be689833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve currently set parallel strategy for ".pmf" files.  <a href="classINMOST_1_1Mesh.html#a74339d3cdcf08469453ff198be689833">More...</a><br /></td></tr>
<tr class="separator:a74339d3cdcf08469453ff198be689833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64099d7b4acb86101bf3edf2865b4627"><td class="memItemLeft" align="right" valign="top"><a id="a64099d7b4acb86101bf3edf2865b4627"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a64099d7b4acb86101bf3edf2865b4627">GetProcessorRank</a> () const</td></tr>
<tr class="memdesc:a64099d7b4acb86101bf3edf2865b4627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get rank of current processor. <br /></td></tr>
<tr class="separator:a64099d7b4acb86101bf3edf2865b4627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4226b216250f2451f5c03ce213f0d08"><td class="memItemLeft" align="right" valign="top"><a id="af4226b216250f2451f5c03ce213f0d08"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#af4226b216250f2451f5c03ce213f0d08">GetProcessorsNumber</a> () const</td></tr>
<tr class="memdesc:af4226b216250f2451f5c03ce213f0d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of processors. <br /></td></tr>
<tr class="separator:af4226b216250f2451f5c03ce213f0d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865cf48f424dd4e5c82a803c516fe982"><td class="memItemLeft" align="right" valign="top"><a id="a865cf48f424dd4e5c82a803c516fe982"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a865cf48f424dd4e5c82a803c516fe982">GetLocalProcessorRank</a> () const</td></tr>
<tr class="memdesc:a865cf48f424dd4e5c82a803c516fe982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get rank of current processor in shared environment (OpenMP) <br /></td></tr>
<tr class="separator:a865cf48f424dd4e5c82a803c516fe982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398b5ee7cdde6ab247de2bd8698a45fc"><td class="memItemLeft" align="right" valign="top"><a id="a398b5ee7cdde6ab247de2bd8698a45fc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a398b5ee7cdde6ab247de2bd8698a45fc">GetLocalProcessorNumber</a> () const</td></tr>
<tr class="memdesc:a398b5ee7cdde6ab247de2bd8698a45fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of processors in shared environment (OpenMP) <br /></td></tr>
<tr class="separator:a398b5ee7cdde6ab247de2bd8698a45fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa471b2166b305b8d36380cee003e7383"><td class="memItemLeft" align="right" valign="top"><a id="aa471b2166b305b8d36380cee003e7383"></a>
INMOST_MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aa471b2166b305b8d36380cee003e7383">GetCommunicator</a> () const</td></tr>
<tr class="memdesc:aa471b2166b305b8d36380cee003e7383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve MPI communicator. <br /></td></tr>
<tr class="separator:aa471b2166b305b8d36380cee003e7383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83336df357d35b8cbf22d192d9dfdbde"><td class="memItemLeft" align="right" valign="top"><a id="a83336df357d35b8cbf22d192d9dfdbde"></a>
INMOST_MPI_Group&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a83336df357d35b8cbf22d192d9dfdbde">GetGroup</a> () const</td></tr>
<tr class="memdesc:a83336df357d35b8cbf22d192d9dfdbde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve MPI group corresponding to the communicator. <br /></td></tr>
<tr class="separator:a83336df357d35b8cbf22d192d9dfdbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60495d087cbd5c893c5322ba0fa2c69"><td class="memItemLeft" align="right" valign="top"><a id="ab60495d087cbd5c893c5322ba0fa2c69"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ab60495d087cbd5c893c5322ba0fa2c69">SetCommunicator</a> (INMOST_MPI_Comm _comm)</td></tr>
<tr class="memdesc:ab60495d087cbd5c893c5322ba0fa2c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set MPI communicator. <br /></td></tr>
<tr class="separator:ab60495d087cbd5c893c5322ba0fa2c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c67f67dc44186328158785141ddf40e"><td class="memItemLeft" align="right" valign="top"><a id="a0c67f67dc44186328158785141ddf40e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a0c67f67dc44186328158785141ddf40e">ResolveShared</a> (bool only_new=false)</td></tr>
<tr class="memdesc:a0c67f67dc44186328158785141ddf40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find elements that are common between processors. <br /></td></tr>
<tr class="separator:a0c67f67dc44186328158785141ddf40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8b7b1fc5ee58a1230027d30f38314f"><td class="memItemLeft" align="right" valign="top"><a id="a0b8b7b1fc5ee58a1230027d30f38314f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a0b8b7b1fc5ee58a1230027d30f38314f">ResolveSets</a> ()</td></tr>
<tr class="memdesc:a0b8b7b1fc5ee58a1230027d30f38314f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find sets that are common between processors. <br /></td></tr>
<tr class="separator:a0b8b7b1fc5ee58a1230027d30f38314f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca313cd3c6c49504eac95aea5d442bf2"><td class="memItemLeft" align="right" valign="top"><a id="aca313cd3c6c49504eac95aea5d442bf2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aca313cd3c6c49504eac95aea5d442bf2">RemoveGhost</a> (MarkerType marker=0)</td></tr>
<tr class="memdesc:aca313cd3c6c49504eac95aea5d442bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all the ghost cells. <br /></td></tr>
<tr class="separator:aca313cd3c6c49504eac95aea5d442bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb95f1e8d6b7987496fc8276c86cf3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a5cb95f1e8d6b7987496fc8276c86cf3a">RemoveGhostElements</a> (const HandleType *ghost, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> num)</td></tr>
<tr class="memdesc:a5cb95f1e8d6b7987496fc8276c86cf3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete some ghost cells provided in array.  <a href="classINMOST_1_1Mesh.html#a5cb95f1e8d6b7987496fc8276c86cf3a">More...</a><br /></td></tr>
<tr class="separator:a5cb95f1e8d6b7987496fc8276c86cf3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac883e455fe795e9a7db3cc8c99ac26"><td class="memTemplParams" colspan="2"><a id="a0ac883e455fe795e9a7db3cc8c99ac26"></a>
template&lt;typename EType &gt; </td></tr>
<tr class="memitem:a0ac883e455fe795e9a7db3cc8c99ac26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RemoveGhostElements</b> (const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; EType &gt; &amp;ghost)</td></tr>
<tr class="separator:a0ac883e455fe795e9a7db3cc8c99ac26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c59c400e41943ea87dbb1f0eff1e2bd"><td class="memItemLeft" align="right" valign="top"><a id="a5c59c400e41943ea87dbb1f0eff1e2bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveGhostElements</b> (const <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> &amp;ghost)</td></tr>
<tr class="separator:a5c59c400e41943ea87dbb1f0eff1e2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39e30b11f35de81d2a9b8451ef87391"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ae39e30b11f35de81d2a9b8451ef87391">AssignGlobalID</a> (ElementType mask)</td></tr>
<tr class="memdesc:ae39e30b11f35de81d2a9b8451ef87391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign unique numbers to elements.  <a href="classINMOST_1_1Mesh.html#ae39e30b11f35de81d2a9b8451ef87391">More...</a><br /></td></tr>
<tr class="separator:ae39e30b11f35de81d2a9b8451ef87391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3d0cb9965d12635cc2df7ad458661a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a0f3d0cb9965d12635cc2df7ad458661a">ExchangeData</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, ElementType mask, MarkerType select=0)</td></tr>
<tr class="memdesc:a0f3d0cb9965d12635cc2df7ad458661a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update data from Shared elements to Ghost elements.  <a href="classINMOST_1_1Mesh.html#a0f3d0cb9965d12635cc2df7ad458661a">More...</a><br /></td></tr>
<tr class="separator:a0f3d0cb9965d12635cc2df7ad458661a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6644fc263bfaef7dc483b2873b96cc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ae6644fc263bfaef7dc483b2873b96cc6">ExchangeOrientedData</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, ElementType mask, MarkerType select=0, MarkerType orient=0)</td></tr>
<tr class="memdesc:ae6644fc263bfaef7dc483b2873b96cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is similar to ExchangeData, except that it will change the orientation of recieved data upon completion for the exchanged tags, registered through AddOrientedTag.  <a href="classINMOST_1_1Mesh.html#ae6644fc263bfaef7dc483b2873b96cc6">More...</a><br /></td></tr>
<tr class="separator:ae6644fc263bfaef7dc483b2873b96cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ca81c3d8a01aa6a9ce983769fa03cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a35ca81c3d8a01aa6a9ce983769fa03cd">ExchangeDataBegin</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, ElementType mask, MarkerType select, <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;storage)</td></tr>
<tr class="memdesc:a35ca81c3d8a01aa6a9ce983769fa03cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start asynchronous synchronization of data.  <a href="classINMOST_1_1Mesh.html#a35ca81c3d8a01aa6a9ce983769fa03cd">More...</a><br /></td></tr>
<tr class="separator:a35ca81c3d8a01aa6a9ce983769fa03cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443828dada7d0fe8ebcf8040593e1ac1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a443828dada7d0fe8ebcf8040593e1ac1">ExchangeDataEnd</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, ElementType mask, MarkerType select, <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;storage)</td></tr>
<tr class="memdesc:a443828dada7d0fe8ebcf8040593e1ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete asynchronous synchronization of data.  <a href="classINMOST_1_1Mesh.html#a443828dada7d0fe8ebcf8040593e1ac1">More...</a><br /></td></tr>
<tr class="separator:a443828dada7d0fe8ebcf8040593e1ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dd6dfc566d9dbdde5c1c9f819b4fdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a48dd6dfc566d9dbdde5c1c9f819b4fdd">ExchangeData</a> (const tag_set &amp;tags, ElementType mask, MarkerType select=0)</td></tr>
<tr class="memdesc:a48dd6dfc566d9dbdde5c1c9f819b4fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will perform exchange of multiple data tags.  <a href="classINMOST_1_1Mesh.html#a48dd6dfc566d9dbdde5c1c9f819b4fdd">More...</a><br /></td></tr>
<tr class="separator:a48dd6dfc566d9dbdde5c1c9f819b4fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9913d34884eca179c968472a0525d82b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a9913d34884eca179c968472a0525d82b">ExchangeOrientedData</a> (const tag_set &amp;tags, ElementType mask, MarkerType select=0, MarkerType orient=0)</td></tr>
<tr class="memdesc:a9913d34884eca179c968472a0525d82b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is similar to ExchangeData, except that it will change the orientation of recieved data upon completion for the exchanged tags, registered through AddOrientedTag.  <a href="classINMOST_1_1Mesh.html#a9913d34884eca179c968472a0525d82b">More...</a><br /></td></tr>
<tr class="separator:a9913d34884eca179c968472a0525d82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418d72493b24344d247b811bd980b3a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a418d72493b24344d247b811bd980b3a9">ExchangeDataBegin</a> (const tag_set &amp;tags, ElementType mask, MarkerType select, <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;storage)</td></tr>
<tr class="memdesc:a418d72493b24344d247b811bd980b3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will initialize exchange of multiple data tags.  <a href="classINMOST_1_1Mesh.html#a418d72493b24344d247b811bd980b3a9">More...</a><br /></td></tr>
<tr class="separator:a418d72493b24344d247b811bd980b3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49bac8c58e4e610eb4c7ec7dd9f4b96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aa49bac8c58e4e610eb4c7ec7dd9f4b96">ExchangeDataEnd</a> (const tag_set &amp;tags, ElementType mask, MarkerType select, <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;storage)</td></tr>
<tr class="memdesc:aa49bac8c58e4e610eb4c7ec7dd9f4b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will finalize exchange of multiple data tags.  <a href="classINMOST_1_1Mesh.html#aa49bac8c58e4e610eb4c7ec7dd9f4b96">More...</a><br /></td></tr>
<tr class="separator:aa49bac8c58e4e610eb4c7ec7dd9f4b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d488479041917c975b1e662d642c4a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a2d488479041917c975b1e662d642c4a5">ReduceData</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, ElementType mask, MarkerType select, ReduceOperation op)</td></tr>
<tr class="memdesc:a2d488479041917c975b1e662d642c4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulation of data from ghost elements to shared elements.  <a href="classINMOST_1_1Mesh.html#a2d488479041917c975b1e662d642c4a5">More...</a><br /></td></tr>
<tr class="separator:a2d488479041917c975b1e662d642c4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0597bf77b8438dc79bf791912a2b34d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a0597bf77b8438dc79bf791912a2b34d2">ReduceDataBegin</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, ElementType mask, MarkerType select, <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;storage)</td></tr>
<tr class="memdesc:a0597bf77b8438dc79bf791912a2b34d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function intializes data reduction.  <a href="classINMOST_1_1Mesh.html#a0597bf77b8438dc79bf791912a2b34d2">More...</a><br /></td></tr>
<tr class="separator:a0597bf77b8438dc79bf791912a2b34d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8273226d8ab6e54baba5db22107df37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aa8273226d8ab6e54baba5db22107df37">ReduceDataEnd</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, ElementType mask, MarkerType select, ReduceOperation op, <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;storage)</td></tr>
<tr class="memdesc:aa8273226d8ab6e54baba5db22107df37"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function completes data reduction.  <a href="classINMOST_1_1Mesh.html#aa8273226d8ab6e54baba5db22107df37">More...</a><br /></td></tr>
<tr class="separator:aa8273226d8ab6e54baba5db22107df37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831a8bab953c4d8aa102e58bac81c25f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a831a8bab953c4d8aa102e58bac81c25f">ReduceData</a> (const tag_set &amp;tags, ElementType mask, MarkerType select, ReduceOperation op)</td></tr>
<tr class="memdesc:a831a8bab953c4d8aa102e58bac81c25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will perform reduction of multiple data tags.  <a href="classINMOST_1_1Mesh.html#a831a8bab953c4d8aa102e58bac81c25f">More...</a><br /></td></tr>
<tr class="separator:a831a8bab953c4d8aa102e58bac81c25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c5b8a155e89d182f18e26dbe4b8670"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a71c5b8a155e89d182f18e26dbe4b8670">ReduceDataBegin</a> (const tag_set &amp;tags, ElementType mask, MarkerType select, <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;storage)</td></tr>
<tr class="memdesc:a71c5b8a155e89d182f18e26dbe4b8670"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will initialize reduction of multiple data tags.  <a href="classINMOST_1_1Mesh.html#a71c5b8a155e89d182f18e26dbe4b8670">More...</a><br /></td></tr>
<tr class="separator:a71c5b8a155e89d182f18e26dbe4b8670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf4380aa2878e72cf399f97598dcebe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aabf4380aa2878e72cf399f97598dcebe">ReduceDataEnd</a> (const tag_set &amp;tags, ElementType mask, MarkerType select, ReduceOperation op, <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;storage)</td></tr>
<tr class="memdesc:aabf4380aa2878e72cf399f97598dcebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will finalize exchange of multiple data tags.  <a href="classINMOST_1_1Mesh.html#aabf4380aa2878e72cf399f97598dcebe">More...</a><br /></td></tr>
<tr class="separator:aabf4380aa2878e72cf399f97598dcebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44b9cfcb8964acbd710562df331a51a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ae44b9cfcb8964acbd710562df331a51a">ExchangeMarked</a> (enum Action action=AGhost)</td></tr>
<tr class="memdesc:ae44b9cfcb8964acbd710562df331a51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function realizes two algorithms: ghosting of elements and migration of elements.  <a href="classINMOST_1_1Mesh.html#ae44b9cfcb8964acbd710562df331a51a">More...</a><br /></td></tr>
<tr class="separator:ae44b9cfcb8964acbd710562df331a51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8cabff3db1f7af1b426f8e2f582752"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a9e8cabff3db1f7af1b426f8e2f582752">ExchangeGhost</a> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> layers, ElementType bridge, MarkerType select=0, bool delete_ghost=true)</td></tr>
<tr class="memdesc:a9e8cabff3db1f7af1b426f8e2f582752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Form several layers of ghost cells that are adjacent through bridge elements to current cells.  <a href="classINMOST_1_1Mesh.html#a9e8cabff3db1f7af1b426f8e2f582752">More...</a><br /></td></tr>
<tr class="separator:a9e8cabff3db1f7af1b426f8e2f582752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade20ec7c8563e82bf8057bc47a3314b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ade20ec7c8563e82bf8057bc47a3314b7">Redistribute</a> ()</td></tr>
<tr class="memdesc:ade20ec7c8563e82bf8057bc47a3314b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Migrate all the elements to the new owners prescribed in data corresponding to RedistributeTag.  <a href="classINMOST_1_1Mesh.html#ade20ec7c8563e82bf8057bc47a3314b7">More...</a><br /></td></tr>
<tr class="separator:ade20ec7c8563e82bf8057bc47a3314b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9787ba8c75b41b76b89aeeae2e8aefad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a9787ba8c75b41b76b89aeeae2e8aefad">Enumerate</a> (ElementType mask, <a class="el" href="classINMOST_1_1Tag.html">Tag</a> num_tag, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> start=0, bool define_sparse=false)</td></tr>
<tr class="memdesc:a9787ba8c75b41b76b89aeeae2e8aefad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate all elements beginning with start and put numeration to data associated with num_tag for all elements with given type mask.  <a href="classINMOST_1_1Mesh.html#a9787ba8c75b41b76b89aeeae2e8aefad">More...</a><br /></td></tr>
<tr class="separator:a9787ba8c75b41b76b89aeeae2e8aefad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc8c51bea6707ccedc76dba47ea0d48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a5dc8c51bea6707ccedc76dba47ea0d48">Enumerate</a> (const HandleType *h, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> num, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;num_tag, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> start=0, bool define_sparse=true)</td></tr>
<tr class="memdesc:a5dc8c51bea6707ccedc76dba47ea0d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate all elements beginning with start and put numeration to data associated with num_tag.  <a href="classINMOST_1_1Mesh.html#a5dc8c51bea6707ccedc76dba47ea0d48">More...</a><br /></td></tr>
<tr class="separator:a5dc8c51bea6707ccedc76dba47ea0d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e7888589b79355fa273ad67c8c9bb5"><td class="memTemplParams" colspan="2">template&lt;typename EType &gt; </td></tr>
<tr class="memitem:a92e7888589b79355fa273ad67c8c9bb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a92e7888589b79355fa273ad67c8c9bb5">Enumerate</a> (const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; EType &gt; &amp;elements, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;num_tag, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> start=0, bool define_sparse=true)</td></tr>
<tr class="memdesc:a92e7888589b79355fa273ad67c8c9bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate all elements beginning with start and put numeration to data associated with num_tag.  <a href="classINMOST_1_1Mesh.html#a92e7888589b79355fa273ad67c8c9bb5">More...</a><br /></td></tr>
<tr class="separator:a92e7888589b79355fa273ad67c8c9bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0239ff055f17c76ba19ef8a169b14962"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a0239ff055f17c76ba19ef8a169b14962">EnumerateSet</a> (const <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> &amp;set, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;num_tag, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> start=0, bool define_sparse=true)</td></tr>
<tr class="memdesc:a0239ff055f17c76ba19ef8a169b14962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate all elements in the set.  <a href="classINMOST_1_1Mesh.html#a0239ff055f17c76ba19ef8a169b14962">More...</a><br /></td></tr>
<tr class="separator:a0239ff055f17c76ba19ef8a169b14962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc118e878e2cce11985e7384f18700fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#acc118e878e2cce11985e7384f18700fa">TotalNumberOf</a> (ElementType mask)</td></tr>
<tr class="memdesc:acc118e878e2cce11985e7384f18700fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of all physical elements, it excludes ghost copies.  <a href="classINMOST_1_1Mesh.html#acc118e878e2cce11985e7384f18700fa">More...</a><br /></td></tr>
<tr class="separator:acc118e878e2cce11985e7384f18700fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90d3db6596d5de6f7ddfd7f72af600f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ab90d3db6596d5de6f7ddfd7f72af600f">Integrate</a> (<a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> input)</td></tr>
<tr class="memdesc:ab90d3db6596d5de6f7ddfd7f72af600f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate real value over all processors.  <a href="classINMOST_1_1Mesh.html#ab90d3db6596d5de6f7ddfd7f72af600f">More...</a><br /></td></tr>
<tr class="separator:ab90d3db6596d5de6f7ddfd7f72af600f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbcad49ef308bede1aa65fcfed626ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#adcbcad49ef308bede1aa65fcfed626ce">Integrate</a> (<a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> input)</td></tr>
<tr class="memdesc:adcbcad49ef308bede1aa65fcfed626ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate unsigned integer value over all processors.  <a href="classINMOST_1_1Mesh.html#adcbcad49ef308bede1aa65fcfed626ce">More...</a><br /></td></tr>
<tr class="separator:adcbcad49ef308bede1aa65fcfed626ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541bea07883f3afa0be27748edb479ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a541bea07883f3afa0be27748edb479ff">Integrate</a> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> input)</td></tr>
<tr class="memdesc:a541bea07883f3afa0be27748edb479ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate integer value over all processors.  <a href="classINMOST_1_1Mesh.html#a541bea07883f3afa0be27748edb479ff">More...</a><br /></td></tr>
<tr class="separator:a541bea07883f3afa0be27748edb479ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab155a28f4b6cbff9d1bc4f6a4808b337"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ab155a28f4b6cbff9d1bc4f6a4808b337">Integrate</a> (<a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> *input, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> size)</td></tr>
<tr class="memdesc:ab155a28f4b6cbff9d1bc4f6a4808b337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate an array of real values over all processors.  <a href="classINMOST_1_1Mesh.html#ab155a28f4b6cbff9d1bc4f6a4808b337">More...</a><br /></td></tr>
<tr class="separator:ab155a28f4b6cbff9d1bc4f6a4808b337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c854cf5da98bb9b8525fc00ff4ca70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a28c854cf5da98bb9b8525fc00ff4ca70">Integrate</a> (<a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> *input, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> size)</td></tr>
<tr class="memdesc:a28c854cf5da98bb9b8525fc00ff4ca70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate an array of unsigned integer values over all processors.  <a href="classINMOST_1_1Mesh.html#a28c854cf5da98bb9b8525fc00ff4ca70">More...</a><br /></td></tr>
<tr class="separator:a28c854cf5da98bb9b8525fc00ff4ca70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9066868f109c3dc264ed03c174e54560"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a9066868f109c3dc264ed03c174e54560">Integrate</a> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> *input, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> size)</td></tr>
<tr class="memdesc:a9066868f109c3dc264ed03c174e54560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate an array of integer values over all processors.  <a href="classINMOST_1_1Mesh.html#a9066868f109c3dc264ed03c174e54560">More...</a><br /></td></tr>
<tr class="separator:a9066868f109c3dc264ed03c174e54560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1eacb17ae889557d9d9d32d7b61ed0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#abb1eacb17ae889557d9d9d32d7b61ed0">Integrate</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;t, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> entry, ElementType mask)</td></tr>
<tr class="memdesc:abb1eacb17ae889557d9d9d32d7b61ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate data corresponding to tag between all processors.  <a href="classINMOST_1_1Mesh.html#abb1eacb17ae889557d9d9d32d7b61ed0">More...</a><br /></td></tr>
<tr class="separator:abb1eacb17ae889557d9d9d32d7b61ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac1be80eb3f359e6d2834f212131200"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a8ac1be80eb3f359e6d2834f212131200">ExclusiveSum</a> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> input)</td></tr>
<tr class="memdesc:a8ac1be80eb3f359e6d2834f212131200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute sum of integer values for all processors with rank lower then current, excluding current processor.  <a href="classINMOST_1_1Mesh.html#a8ac1be80eb3f359e6d2834f212131200">More...</a><br /></td></tr>
<tr class="separator:a8ac1be80eb3f359e6d2834f212131200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96a60285bb08c4cce56f0dbc0a19b24"><td class="memItemLeft" align="right" valign="top"><a id="aa96a60285bb08c4cce56f0dbc0a19b24"></a>
<a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ExclusiveSum</b> (<a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> input)</td></tr>
<tr class="separator:aa96a60285bb08c4cce56f0dbc0a19b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a95b3b375dde1ba544ec0689ce1610f"><td class="memItemLeft" align="right" valign="top"><a id="a2a95b3b375dde1ba544ec0689ce1610f"></a>
<a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AggregateMax</b> (<a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> input)</td></tr>
<tr class="separator:a2a95b3b375dde1ba544ec0689ce1610f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473a5c93ff000e34b8c07eb1ec9947a1"><td class="memItemLeft" align="right" valign="top"><a id="a473a5c93ff000e34b8c07eb1ec9947a1"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AggregateMax</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> input)</td></tr>
<tr class="separator:a473a5c93ff000e34b8c07eb1ec9947a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960d01f5998bf963bbf1ecbd01324831"><td class="memItemLeft" align="right" valign="top"><a id="a960d01f5998bf963bbf1ecbd01324831"></a>
<a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AggregateMax</b> (<a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> input)</td></tr>
<tr class="separator:a960d01f5998bf963bbf1ecbd01324831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68a56474720952a4ad903c13592ae91"><td class="memItemLeft" align="right" valign="top"><a id="ac68a56474720952a4ad903c13592ae91"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AggregateMax</b> (<a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> *input, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> size)</td></tr>
<tr class="separator:ac68a56474720952a4ad903c13592ae91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5947b4110e79b47aa67e0712b196a4a"><td class="memItemLeft" align="right" valign="top"><a id="ae5947b4110e79b47aa67e0712b196a4a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AggregateMax</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> *input, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> size)</td></tr>
<tr class="separator:ae5947b4110e79b47aa67e0712b196a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b457f9256ad25ee5d8ef956f9e52b2a"><td class="memItemLeft" align="right" valign="top"><a id="a5b457f9256ad25ee5d8ef956f9e52b2a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AggregateMax</b> (<a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> *input, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> size)</td></tr>
<tr class="separator:a5b457f9256ad25ee5d8ef956f9e52b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0254be27cba68276e88ed5a271c68923"><td class="memItemLeft" align="right" valign="top"><a id="a0254be27cba68276e88ed5a271c68923"></a>
<a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AggregateMin</b> (<a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> input)</td></tr>
<tr class="separator:a0254be27cba68276e88ed5a271c68923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb226c1d50f08f73a7394990131d6d2"><td class="memItemLeft" align="right" valign="top"><a id="a8bb226c1d50f08f73a7394990131d6d2"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AggregateMin</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> input)</td></tr>
<tr class="separator:a8bb226c1d50f08f73a7394990131d6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf505887cc692644afb3df94b3f784b"><td class="memItemLeft" align="right" valign="top"><a id="aaaf505887cc692644afb3df94b3f784b"></a>
<a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AggregateMin</b> (<a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> input)</td></tr>
<tr class="separator:aaaf505887cc692644afb3df94b3f784b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4cdf5ed689fc7cd79175a4336efaf4"><td class="memItemLeft" align="right" valign="top"><a id="a5d4cdf5ed689fc7cd79175a4336efaf4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AggregateMin</b> (<a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> *input, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> size)</td></tr>
<tr class="separator:a5d4cdf5ed689fc7cd79175a4336efaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e9a3326bf8254a7d8a45563a0838f9"><td class="memItemLeft" align="right" valign="top"><a id="a85e9a3326bf8254a7d8a45563a0838f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AggregateMin</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> *input, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> size)</td></tr>
<tr class="separator:a85e9a3326bf8254a7d8a45563a0838f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b9c0cdf3c8c951ca6081ecb889df60"><td class="memItemLeft" align="right" valign="top"><a id="a52b9c0cdf3c8c951ca6081ecb889df60"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AggregateMin</b> (<a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> *input, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> size)</td></tr>
<tr class="separator:a52b9c0cdf3c8c951ca6081ecb889df60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5691f394480da7e21c5099e313df03e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a5691f394480da7e21c5099e313df03e0">RecomputeParallelStorage</a> (ElementType mask)</td></tr>
<tr class="memdesc:a5691f394480da7e21c5099e313df03e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regather ghost and shared element sets for data exchange.  <a href="classINMOST_1_1Mesh.html#a5691f394480da7e21c5099e313df03e0">More...</a><br /></td></tr>
<tr class="separator:a5691f394480da7e21c5099e313df03e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e47aee230b989eacc29fbfe6edfe305"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a3e47aee230b989eacc29fbfe6edfe305">SortParallelStorage</a> (ElementType mask)</td></tr>
<tr class="memdesc:a3e47aee230b989eacc29fbfe6edfe305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort parallel storage.  <a href="classINMOST_1_1Mesh.html#a3e47aee230b989eacc29fbfe6edfe305">More...</a><br /></td></tr>
<tr class="separator:a3e47aee230b989eacc29fbfe6edfe305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa08bcccce1d1af7afc2eb14890670d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a1fa08bcccce1d1af7afc2eb14890670d">RecordParallelStorage</a> (ElementType mask)</td></tr>
<tr class="memdesc:a1fa08bcccce1d1af7afc2eb14890670d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs parallel storage into xml log files.  <a href="classINMOST_1_1Mesh.html#a1fa08bcccce1d1af7afc2eb14890670d">More...</a><br /></td></tr>
<tr class="separator:a1fa08bcccce1d1af7afc2eb14890670d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3acf2a90e25699a64e1f7b4125eaf7"><td class="memItemLeft" align="right" valign="top">ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a9c3acf2a90e25699a64e1f7b4125eaf7">SynchronizeElementType</a> (ElementType etype)</td></tr>
<tr class="memdesc:a9c3acf2a90e25699a64e1f7b4125eaf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize bitwise mask of element types between processors.  <a href="classINMOST_1_1Mesh.html#a9c3acf2a90e25699a64e1f7b4125eaf7">More...</a><br /></td></tr>
<tr class="separator:a9c3acf2a90e25699a64e1f7b4125eaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7a825072f54b260caa0e8da8877647"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a8c7a825072f54b260caa0e8da8877647">SynchronizeMarker</a> (MarkerType marker, ElementType mask, SyncBitOp op)</td></tr>
<tr class="memdesc:a8c7a825072f54b260caa0e8da8877647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize marker on elements between processors using provided operation.  <a href="classINMOST_1_1Mesh.html#a8c7a825072f54b260caa0e8da8877647">More...</a><br /></td></tr>
<tr class="separator:a8c7a825072f54b260caa0e8da8877647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf04ac6f3ad821c5dfa45153488ff583"><td class="memItemLeft" align="right" valign="top"><a id="aaf04ac6f3ad821c5dfa45153488ff583"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Barrier</b> ()</td></tr>
<tr class="separator:aaf04ac6f3ad821c5dfa45153488ff583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf9564fe8f57e292e7c2267fbe588d6"><td class="memItemLeft" align="right" valign="top"><a id="aecf9564fe8f57e292e7c2267fbe588d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>BeginSequentialCode</b> ()</td></tr>
<tr class="separator:aecf9564fe8f57e292e7c2267fbe588d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f44fe4031bbe9b68ae0764f4b6d43a"><td class="memItemLeft" align="right" valign="top"><a id="aa4f44fe4031bbe9b68ae0764f4b6d43a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EndSequentialCode</b> ()</td></tr>
<tr class="separator:aa4f44fe4031bbe9b68ae0764f4b6d43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabf73e2a6cbc58b2ae995f29e39e283"><td class="memItemLeft" align="right" valign="top"><a id="aeabf73e2a6cbc58b2ae995f29e39e283"></a>
<a class="el" href="classINMOST_1_1Element.html">Element</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ElementByLocalIDNum</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> etypenum, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid)</td></tr>
<tr class="separator:aeabf73e2a6cbc58b2ae995f29e39e283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d09a55b27ac2f0f500400648ca38ee"><td class="memItemLeft" align="right" valign="top"><a id="aa9d09a55b27ac2f0f500400648ca38ee"></a>
<a class="el" href="classINMOST_1_1Element.html">Element</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ElementByLocalID</b> (ElementType etype, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid)</td></tr>
<tr class="separator:aa9d09a55b27ac2f0f500400648ca38ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2304ca5cb8a374ecc6b0b5f0f900e349"><td class="memItemLeft" align="right" valign="top"><a id="a2304ca5cb8a374ecc6b0b5f0f900e349"></a>
<a class="el" href="classINMOST_1_1Element.html">Element</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ElementByHandle</b> (HandleType h)</td></tr>
<tr class="separator:a2304ca5cb8a374ecc6b0b5f0f900e349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fa9b00b50bb588514b167f88cc8fc5"><td class="memItemLeft" align="right" valign="top"><a id="a35fa9b00b50bb588514b167f88cc8fc5"></a>
HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>NextHandle</b> (HandleType h) const</td></tr>
<tr class="separator:a35fa9b00b50bb588514b167f88cc8fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33fddf8bf5487c5c3ba079d4050844d"><td class="memItemLeft" align="right" valign="top"><a id="ae33fddf8bf5487c5c3ba079d4050844d"></a>
HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>PrevHandle</b> (HandleType h) const</td></tr>
<tr class="separator:ae33fddf8bf5487c5c3ba079d4050844d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbddd94dfc840150580f6f7624636dea"><td class="memItemLeft" align="right" valign="top"><a id="afbddd94dfc840150580f6f7624636dea"></a>
HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>NextHandle</b> (HandleType h, ElementType mask) const</td></tr>
<tr class="separator:afbddd94dfc840150580f6f7624636dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8757e77c0994f592420ca8dc9e3f50"><td class="memItemLeft" align="right" valign="top"><a id="a4d8757e77c0994f592420ca8dc9e3f50"></a>
HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>PrevHandle</b> (HandleType h, ElementType mask) const</td></tr>
<tr class="separator:a4d8757e77c0994f592420ca8dc9e3f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae034909340641090873c99446aaf4794"><td class="memItemLeft" align="right" valign="top"><a id="ae034909340641090873c99446aaf4794"></a>
HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>FirstHandle</b> () const</td></tr>
<tr class="separator:ae034909340641090873c99446aaf4794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d67067878f87466b0f35cfd6491785f"><td class="memItemLeft" align="right" valign="top"><a id="a3d67067878f87466b0f35cfd6491785f"></a>
HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>LastHandle</b> () const</td></tr>
<tr class="separator:a3d67067878f87466b0f35cfd6491785f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac918753d45202c7353f25aaf7f82ca0c"><td class="memItemLeft" align="right" valign="top"><a id="ac918753d45202c7353f25aaf7f82ca0c"></a>
HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>FirstHandle</b> (ElementType etype) const</td></tr>
<tr class="separator:ac918753d45202c7353f25aaf7f82ca0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbdbaf6b570153b4b809a0d5aae0bfd"><td class="memItemLeft" align="right" valign="top"><a id="accbdbaf6b570153b4b809a0d5aae0bfd"></a>
HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>LastHandle</b> (ElementType etype) const</td></tr>
<tr class="separator:accbdbaf6b570153b4b809a0d5aae0bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83562665b8922806e475fa75f79a9b69"><td class="memItemLeft" align="right" valign="top"><a id="a83562665b8922806e475fa75f79a9b69"></a>
<a class="el" href="classINMOST_1_1Node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NodeByLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid)</td></tr>
<tr class="separator:a83562665b8922806e475fa75f79a9b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318f86a5b9807fa73d7e1ffe493fb1d0"><td class="memItemLeft" align="right" valign="top"><a id="a318f86a5b9807fa73d7e1ffe493fb1d0"></a>
<a class="el" href="classINMOST_1_1Edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EdgeByLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid)</td></tr>
<tr class="separator:a318f86a5b9807fa73d7e1ffe493fb1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7e83bc5a26c47443dd5ae701747ccf"><td class="memItemLeft" align="right" valign="top"><a id="aec7e83bc5a26c47443dd5ae701747ccf"></a>
<a class="el" href="classINMOST_1_1Face.html">Face</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FaceByLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid)</td></tr>
<tr class="separator:aec7e83bc5a26c47443dd5ae701747ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d502f77d8d56014a67e1715f8628c0f"><td class="memItemLeft" align="right" valign="top"><a id="a0d502f77d8d56014a67e1715f8628c0f"></a>
<a class="el" href="classINMOST_1_1Cell.html">Cell</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CellByLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid)</td></tr>
<tr class="separator:a0d502f77d8d56014a67e1715f8628c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2af21e0963cd29ae7f809e6e2939719"><td class="memItemLeft" align="right" valign="top"><a id="af2af21e0963cd29ae7f809e6e2939719"></a>
<a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EsetByLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid)</td></tr>
<tr class="separator:af2af21e0963cd29ae7f809e6e2939719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc08d97aef6582fa4fbd388b336be85"><td class="memItemLeft" align="right" valign="top"><a id="a0fc08d97aef6582fa4fbd388b336be85"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NodeNextLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const</td></tr>
<tr class="separator:a0fc08d97aef6582fa4fbd388b336be85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac441e884c3cdd77de7119b506ab2fca"><td class="memItemLeft" align="right" valign="top"><a id="aac441e884c3cdd77de7119b506ab2fca"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EdgeNextLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const</td></tr>
<tr class="separator:aac441e884c3cdd77de7119b506ab2fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e6d0dc915da61bdb9839ca77f868d8"><td class="memItemLeft" align="right" valign="top"><a id="ab1e6d0dc915da61bdb9839ca77f868d8"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FaceNextLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const</td></tr>
<tr class="separator:ab1e6d0dc915da61bdb9839ca77f868d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaada87a5c3dcb4ba5b18daf476c65c4"><td class="memItemLeft" align="right" valign="top"><a id="acaada87a5c3dcb4ba5b18daf476c65c4"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CellNextLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const</td></tr>
<tr class="separator:acaada87a5c3dcb4ba5b18daf476c65c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a810355632a91f535f46b9c17007cf"><td class="memItemLeft" align="right" valign="top"><a id="a23a810355632a91f535f46b9c17007cf"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EsetNextLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const</td></tr>
<tr class="separator:a23a810355632a91f535f46b9c17007cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dac465a82f63da254535aea1ce8812c"><td class="memItemLeft" align="right" valign="top"><a id="a0dac465a82f63da254535aea1ce8812c"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NodePrevLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const</td></tr>
<tr class="separator:a0dac465a82f63da254535aea1ce8812c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8248b8a70785ac3c52330cedd9b2dfd8"><td class="memItemLeft" align="right" valign="top"><a id="a8248b8a70785ac3c52330cedd9b2dfd8"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EdgePrevLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const</td></tr>
<tr class="separator:a8248b8a70785ac3c52330cedd9b2dfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bd7841f71f6c5a4d9de327c5e1d39b"><td class="memItemLeft" align="right" valign="top"><a id="a21bd7841f71f6c5a4d9de327c5e1d39b"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FacePrevLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const</td></tr>
<tr class="separator:a21bd7841f71f6c5a4d9de327c5e1d39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc08b080700c5ed7a418b417b295761"><td class="memItemLeft" align="right" valign="top"><a id="a3cc08b080700c5ed7a418b417b295761"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CellPrevLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const</td></tr>
<tr class="separator:a3cc08b080700c5ed7a418b417b295761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c61e6b22b9135fea3f41ad2d110ff6"><td class="memItemLeft" align="right" valign="top"><a id="a19c61e6b22b9135fea3f41ad2d110ff6"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EsetPrevLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const</td></tr>
<tr class="separator:a19c61e6b22b9135fea3f41ad2d110ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab728424a57dd621def1c0c3956e63e"><td class="memItemLeft" align="right" valign="top"><a id="a7ab728424a57dd621def1c0c3956e63e"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NodeLastLocalID</b> () const</td></tr>
<tr class="separator:a7ab728424a57dd621def1c0c3956e63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8f2cc2d627c2e10cd4cc04f0647479"><td class="memItemLeft" align="right" valign="top"><a id="adb8f2cc2d627c2e10cd4cc04f0647479"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EdgeLastLocalID</b> () const</td></tr>
<tr class="separator:adb8f2cc2d627c2e10cd4cc04f0647479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd141944b81ea38f9d8691ec587296aa"><td class="memItemLeft" align="right" valign="top"><a id="acd141944b81ea38f9d8691ec587296aa"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FaceLastLocalID</b> () const</td></tr>
<tr class="separator:acd141944b81ea38f9d8691ec587296aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ef5f232170d7d9a42b46a0dfcb50bf"><td class="memItemLeft" align="right" valign="top"><a id="ae6ef5f232170d7d9a42b46a0dfcb50bf"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CellLastLocalID</b> () const</td></tr>
<tr class="separator:ae6ef5f232170d7d9a42b46a0dfcb50bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa50373c4f32e836f6a8fafc8e38216"><td class="memItemLeft" align="right" valign="top"><a id="a7aa50373c4f32e836f6a8fafc8e38216"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EsetLastLocalID</b> () const</td></tr>
<tr class="separator:a7aa50373c4f32e836f6a8fafc8e38216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0727987f575c7d81aefff77bba70d571"><td class="memItemLeft" align="right" valign="top"><a id="a0727987f575c7d81aefff77bba70d571"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LastLocalIDNum</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> n) const</td></tr>
<tr class="separator:a0727987f575c7d81aefff77bba70d571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376ccb3186924fc7b13b12d62483c0fe"><td class="memItemLeft" align="right" valign="top"><a id="a376ccb3186924fc7b13b12d62483c0fe"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NextLocalID</b> (ElementType etype, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const</td></tr>
<tr class="separator:a376ccb3186924fc7b13b12d62483c0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36c8fdb8e8ba6263d966f75d80475bc"><td class="memItemLeft" align="right" valign="top"><a id="ae36c8fdb8e8ba6263d966f75d80475bc"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PrevLocalID</b> (ElementType etype, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const</td></tr>
<tr class="separator:ae36c8fdb8e8ba6263d966f75d80475bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510c43fbba6d83a6371abdd6da666b96"><td class="memItemLeft" align="right" valign="top"><a id="a510c43fbba6d83a6371abdd6da666b96"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FirstLocalID</b> (ElementType etype) const</td></tr>
<tr class="separator:a510c43fbba6d83a6371abdd6da666b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf43f60cb88e544be72bdc2883e47e8b"><td class="memItemLeft" align="right" valign="top"><a id="aaf43f60cb88e544be72bdc2883e47e8b"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LastLocalID</b> (ElementType etype) const</td></tr>
<tr class="separator:aaf43f60cb88e544be72bdc2883e47e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac083c071471dc8154ec969750cb076eb"><td class="memItemLeft" align="right" valign="top"><a id="ac083c071471dc8154ec969750cb076eb"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NextLocalIDIter</b> (ElementType etype, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const</td></tr>
<tr class="separator:ac083c071471dc8154ec969750cb076eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac004439a53a7678d9db05d0d4e9f65a7"><td class="memItemLeft" align="right" valign="top"><a id="ac004439a53a7678d9db05d0d4e9f65a7"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PrevLocalIDIter</b> (ElementType etype, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const</td></tr>
<tr class="separator:ac004439a53a7678d9db05d0d4e9f65a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072c924274165d5900f98e69684a01df"><td class="memItemLeft" align="right" valign="top"><a id="a072c924274165d5900f98e69684a01df"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LastLocalIDThr</b> (ElementType etype) const</td></tr>
<tr class="separator:a072c924274165d5900f98e69684a01df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86f26a26d6ac58b25a2d8adf69c83d0"><td class="memItemLeft" align="right" valign="top"><a id="ac86f26a26d6ac58b25a2d8adf69c83d0"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FirstLocalIDThr</b> (ElementType etype) const</td></tr>
<tr class="separator:ac86f26a26d6ac58b25a2d8adf69c83d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2164a5f228ae466d424a89d28fdde0"><td class="memItemLeft" align="right" valign="top"><a id="aef2164a5f228ae466d424a89d28fdde0"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NumberOfSets</b> () const</td></tr>
<tr class="separator:aef2164a5f228ae466d424a89d28fdde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9970337108742e295de6ff2db5cba591"><td class="memItemLeft" align="right" valign="top"><a id="a9970337108742e295de6ff2db5cba591"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NumberOfCells</b> () const</td></tr>
<tr class="separator:a9970337108742e295de6ff2db5cba591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f7ac213ccc8ac43f8ead516ebbad12"><td class="memItemLeft" align="right" valign="top"><a id="a81f7ac213ccc8ac43f8ead516ebbad12"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NumberOfFaces</b> () const</td></tr>
<tr class="separator:a81f7ac213ccc8ac43f8ead516ebbad12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41ce14fa3f4531a0e4fe0b45bc916fd"><td class="memItemLeft" align="right" valign="top"><a id="ae41ce14fa3f4531a0e4fe0b45bc916fd"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NumberOfEdges</b> () const</td></tr>
<tr class="separator:ae41ce14fa3f4531a0e4fe0b45bc916fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af389458cf33a8492047e2c4108435cda"><td class="memItemLeft" align="right" valign="top"><a id="af389458cf33a8492047e2c4108435cda"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NumberOfNodes</b> () const</td></tr>
<tr class="separator:af389458cf33a8492047e2c4108435cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e8cf1e7bc5d6cfef254631a8a88ba8"><td class="memItemLeft" align="right" valign="top"><a id="a24e8cf1e7bc5d6cfef254631a8a88ba8"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NumberOfElements</b> () const</td></tr>
<tr class="separator:a24e8cf1e7bc5d6cfef254631a8a88ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc27d99b6513cdd40a1f632a8ef4174"><td class="memItemLeft" align="right" valign="top"><a id="aafc27d99b6513cdd40a1f632a8ef4174"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NumberOfAll</b> () const</td></tr>
<tr class="separator:aafc27d99b6513cdd40a1f632a8ef4174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6187cd8a8e331ec0dc3c934baca45b67"><td class="memItemLeft" align="right" valign="top"><a id="a6187cd8a8e331ec0dc3c934baca45b67"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NumberOf</b> (ElementType t) const</td></tr>
<tr class="separator:a6187cd8a8e331ec0dc3c934baca45b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee057ff8894f5920556eea758f45a05"><td class="memItemLeft" align="right" valign="top"><a id="aaee057ff8894f5920556eea758f45a05"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorStorage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aaee057ff8894f5920556eea758f45a05">Begin</a> (ElementType Types)</td></tr>
<tr class="memdesc:aaee057ff8894f5920556eea758f45a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">These iterators skip invalid elements but don't skip modified elements. <br /></td></tr>
<tr class="separator:aaee057ff8894f5920556eea758f45a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4075ba5683113b9da966ee8254c9c98"><td class="memItemLeft" align="right" valign="top"><a id="ab4075ba5683113b9da966ee8254c9c98"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorStorage</a>&#160;</td><td class="memItemRight" valign="bottom"><b>End</b> ()</td></tr>
<tr class="separator:ab4075ba5683113b9da966ee8254c9c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5885febfabd0c64ca2147f2508c676ae"><td class="memItemLeft" align="right" valign="top"><a id="a5885febfabd0c64ca2147f2508c676ae"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorElement</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BeginElement</b> (ElementType Types)</td></tr>
<tr class="separator:a5885febfabd0c64ca2147f2508c676ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceafaeeef67b517d363d19249c9aae7"><td class="memItemLeft" align="right" valign="top"><a id="a7ceafaeeef67b517d363d19249c9aae7"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorElement</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EndElement</b> ()</td></tr>
<tr class="separator:a7ceafaeeef67b517d363d19249c9aae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e1a950b5a5f7ad600d55226023b7c9"><td class="memItemLeft" align="right" valign="top"><a id="aa5e1a950b5a5f7ad600d55226023b7c9"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BeginSet</b> ()</td></tr>
<tr class="separator:aa5e1a950b5a5f7ad600d55226023b7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f6929baaaf379644dddef6c42fef76"><td class="memItemLeft" align="right" valign="top"><a id="a00f6929baaaf379644dddef6c42fef76"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EndSet</b> ()</td></tr>
<tr class="separator:a00f6929baaaf379644dddef6c42fef76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7a5c1d76ed3816d0167adac44d0a24"><td class="memItemLeft" align="right" valign="top"><a id="a0c7a5c1d76ed3816d0167adac44d0a24"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorCell</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BeginCell</b> ()</td></tr>
<tr class="separator:a0c7a5c1d76ed3816d0167adac44d0a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00d0cd949a89a3bf9ff0802d5292e82"><td class="memItemLeft" align="right" valign="top"><a id="ad00d0cd949a89a3bf9ff0802d5292e82"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorCell</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EndCell</b> ()</td></tr>
<tr class="separator:ad00d0cd949a89a3bf9ff0802d5292e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b92935c9e005193abf21f24f701fa07"><td class="memItemLeft" align="right" valign="top"><a id="a8b92935c9e005193abf21f24f701fa07"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorFace</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BeginFace</b> ()</td></tr>
<tr class="separator:a8b92935c9e005193abf21f24f701fa07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5324c63941c77b2fc4654e5c2774b845"><td class="memItemLeft" align="right" valign="top"><a id="a5324c63941c77b2fc4654e5c2774b845"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorFace</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EndFace</b> ()</td></tr>
<tr class="separator:a5324c63941c77b2fc4654e5c2774b845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5215f1e7a43a336c68819a92780b89d5"><td class="memItemLeft" align="right" valign="top"><a id="a5215f1e7a43a336c68819a92780b89d5"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorEdge</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BeginEdge</b> ()</td></tr>
<tr class="separator:a5215f1e7a43a336c68819a92780b89d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f40383f4780d877be0291b5d1c4c85"><td class="memItemLeft" align="right" valign="top"><a id="ac2f40383f4780d877be0291b5d1c4c85"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorEdge</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EndEdge</b> ()</td></tr>
<tr class="separator:ac2f40383f4780d877be0291b5d1c4c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab832696d5dfd3340153dedb5dc86974d"><td class="memItemLeft" align="right" valign="top"><a id="ab832696d5dfd3340153dedb5dc86974d"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BeginNode</b> ()</td></tr>
<tr class="separator:ab832696d5dfd3340153dedb5dc86974d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424e61945ab061054cf896db3831d7ec"><td class="memItemLeft" align="right" valign="top"><a id="a424e61945ab061054cf896db3831d7ec"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EndNode</b> ()</td></tr>
<tr class="separator:a424e61945ab061054cf896db3831d7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c75e9dee2c400225a6095e45489ac1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a07c75e9dee2c400225a6095e45489ac1">SetFileOption</a> (std::string, std::string)</td></tr>
<tr class="memdesc:a07c75e9dee2c400225a6095e45489ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set file option.  <a href="classINMOST_1_1Mesh.html#a07c75e9dee2c400225a6095e45489ac1">More...</a><br /></td></tr>
<tr class="separator:a07c75e9dee2c400225a6095e45489ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38db202489d5f698ca52c9a61db206b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aa38db202489d5f698ca52c9a61db206b">GetFileOption</a> (std::string key) const</td></tr>
<tr class="memdesc:aa38db202489d5f698ca52c9a61db206b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current option corresponding to key.  <a href="classINMOST_1_1Mesh.html#aa38db202489d5f698ca52c9a61db206b">More...</a><br /></td></tr>
<tr class="separator:aa38db202489d5f698ca52c9a61db206b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a87be01328bed5563d7131b7c2bcec"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ab6a87be01328bed5563d7131b7c2bcec">TagOptions</a> (std::string name) const</td></tr>
<tr class="memdesc:ab6a87be01328bed5563d7131b7c2bcec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect file options related to records <a class="el" href="classINMOST_1_1Tag.html" title="This class provides the access to the individual mesh datum and general information about it.">Tag</a>:TAGNAME.  <a href="classINMOST_1_1Mesh.html#ab6a87be01328bed5563d7131b7c2bcec">More...</a><br /></td></tr>
<tr class="separator:ab6a87be01328bed5563d7131b7c2bcec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b2fb5c70a173bd63045d0f5402236c"><td class="memItemLeft" align="right" valign="top"><a id="af6b2fb5c70a173bd63045d0f5402236c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#af6b2fb5c70a173bd63045d0f5402236c">CheckLoadSkip</a> (std::string name, const std::set&lt; std::string &gt; &amp;noload, const std::set&lt; std::string &gt; &amp;loadonly) const</td></tr>
<tr class="memdesc:af6b2fb5c70a173bd63045d0f5402236c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if tag loading should be skipped. <br /></td></tr>
<tr class="separator:af6b2fb5c70a173bd63045d0f5402236c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1af65f40760f61bb12bfaee7b6d14e"><td class="memItemLeft" align="right" valign="top"><a id="a5f1af65f40760f61bb12bfaee7b6d14e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a5f1af65f40760f61bb12bfaee7b6d14e">CheckSaveSkip</a> (std::string name, const std::set&lt; std::string &gt; &amp;noload, const std::set&lt; std::string &gt; &amp;loadonly) const</td></tr>
<tr class="memdesc:a5f1af65f40760f61bb12bfaee7b6d14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if tag saving should be skipped. <br /></td></tr>
<tr class="separator:a5f1af65f40760f61bb12bfaee7b6d14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfd481d638b2d2d72193b4b8fa159a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a5dfd481d638b2d2d72193b4b8fa159a4">Load</a> (std::string File)</td></tr>
<tr class="memdesc:a5dfd481d638b2d2d72193b4b8fa159a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acceptable file formats for reading.  <a href="classINMOST_1_1Mesh.html#a5dfd481d638b2d2d72193b4b8fa159a4">More...</a><br /></td></tr>
<tr class="separator:a5dfd481d638b2d2d72193b4b8fa159a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb0e4377df3d6dd4386a42cc4fa47ec"><td class="memItemLeft" align="right" valign="top"><a id="a5fb0e4377df3d6dd4386a42cc4fa47ec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LoadMSH</b> (std::string File)</td></tr>
<tr class="separator:a5fb0e4377df3d6dd4386a42cc4fa47ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3854e8588ed8ffabf38efe97149b8019"><td class="memItemLeft" align="right" valign="top"><a id="a3854e8588ed8ffabf38efe97149b8019"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LoadECL</b> (std::string File)</td></tr>
<tr class="separator:a3854e8588ed8ffabf38efe97149b8019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29938e7c153853fe5562663213ce434b"><td class="memItemLeft" align="right" valign="top"><a id="a29938e7c153853fe5562663213ce434b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LoadXML</b> (std::string File)</td></tr>
<tr class="separator:a29938e7c153853fe5562663213ce434b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68374d712e572ae6366492a2395debe0"><td class="memItemLeft" align="right" valign="top"><a id="a68374d712e572ae6366492a2395debe0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LoadPMF</b> (std::string File)</td></tr>
<tr class="separator:a68374d712e572ae6366492a2395debe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ebf2d57e6e977fb117ac5c9d8c4c8d"><td class="memItemLeft" align="right" valign="top"><a id="a26ebf2d57e6e977fb117ac5c9d8c4c8d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LoadVTK</b> (std::string File)</td></tr>
<tr class="separator:a26ebf2d57e6e977fb117ac5c9d8c4c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9e29bab92d145169d1a7b449a5e861"><td class="memItemLeft" align="right" valign="top"><a id="aba9e29bab92d145169d1a7b449a5e861"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LoadVTU</b> (std::string File)</td></tr>
<tr class="separator:aba9e29bab92d145169d1a7b449a5e861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d456e4eedd34aa3e7d7cc865101e758"><td class="memItemLeft" align="right" valign="top"><a id="a7d456e4eedd34aa3e7d7cc865101e758"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LoadPVTK</b> (std::string File)</td></tr>
<tr class="separator:a7d456e4eedd34aa3e7d7cc865101e758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c62d48779962ef60747a06f0c9d0ff"><td class="memItemLeft" align="right" valign="top"><a id="af3c62d48779962ef60747a06f0c9d0ff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LoadPVTU</b> (std::string File)</td></tr>
<tr class="separator:af3c62d48779962ef60747a06f0c9d0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18db46ea8551a45e776924bcbf4cf5fc"><td class="memItemLeft" align="right" valign="top"><a id="a18db46ea8551a45e776924bcbf4cf5fc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LoadMKF</b> (std::string File)</td></tr>
<tr class="separator:a18db46ea8551a45e776924bcbf4cf5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12ba58210b79c61e64a74c389cd11f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ac12ba58210b79c61e64a74c389cd11f6">Save</a> (std::string File)</td></tr>
<tr class="memdesc:ac12ba58210b79c61e64a74c389cd11f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acceptable file formats for writing.  <a href="classINMOST_1_1Mesh.html#ac12ba58210b79c61e64a74c389cd11f6">More...</a><br /></td></tr>
<tr class="separator:ac12ba58210b79c61e64a74c389cd11f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60cb0d2cc273031de62f71c7a3a4a4c"><td class="memItemLeft" align="right" valign="top"><a id="aa60cb0d2cc273031de62f71c7a3a4a4c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SaveXML</b> (std::string File)</td></tr>
<tr class="separator:aa60cb0d2cc273031de62f71c7a3a4a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed71e57f8c425734001a50f4f7d394c"><td class="memItemLeft" align="right" valign="top"><a id="a7ed71e57f8c425734001a50f4f7d394c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SavePMF</b> (std::string File)</td></tr>
<tr class="separator:a7ed71e57f8c425734001a50f4f7d394c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e21ac5265b971b38ea056b5781616e"><td class="memItemLeft" align="right" valign="top"><a id="a05e21ac5265b971b38ea056b5781616e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SaveVTK</b> (std::string File)</td></tr>
<tr class="separator:a05e21ac5265b971b38ea056b5781616e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe0ea7b322b4a390e2043ff9048f5a6"><td class="memItemLeft" align="right" valign="top"><a id="a0fe0ea7b322b4a390e2043ff9048f5a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SaveVTU</b> (std::string File)</td></tr>
<tr class="separator:a0fe0ea7b322b4a390e2043ff9048f5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04d69ff24c7f4d66aab9500d1c6038b"><td class="memItemLeft" align="right" valign="top"><a id="aa04d69ff24c7f4d66aab9500d1c6038b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SavePVTK</b> (std::string File)</td></tr>
<tr class="separator:aa04d69ff24c7f4d66aab9500d1c6038b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ec8f8c4a74963413b905796c631b2f"><td class="memItemLeft" align="right" valign="top"><a id="a54ec8f8c4a74963413b905796c631b2f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SavePVTU</b> (std::string File)</td></tr>
<tr class="separator:a54ec8f8c4a74963413b905796c631b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad358f03b9a540320af07bc45f795984f"><td class="memItemLeft" align="right" valign="top"><a id="ad358f03b9a540320af07bc45f795984f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SaveGMV</b> (std::string File)</td></tr>
<tr class="separator:ad358f03b9a540320af07bc45f795984f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ed94fed9a6ebc229a814c562c2a683"><td class="memItemLeft" align="right" valign="top"><a id="a61ed94fed9a6ebc229a814c562c2a683"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isParallelFileFormat</b> (std::string File)</td></tr>
<tr class="separator:a61ed94fed9a6ebc229a814c562c2a683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863cff186a84a9f233d33b62260d1c87"><td class="memItemLeft" align="right" valign="top"><a id="a863cff186a84a9f233d33b62260d1c87"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RepairGeometricTags</b> ()</td></tr>
<tr class="separator:a863cff186a84a9f233d33b62260d1c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe076b47ac144837a2a34614a03f3d6"><td class="memItemLeft" align="right" valign="top"><a id="a7fe076b47ac144837a2a34614a03f3d6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HideGeometricData</b> (GeometricData type, ElementType mask)</td></tr>
<tr class="separator:a7fe076b47ac144837a2a34614a03f3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab686403729b9b26c8a089429149c0f95"><td class="memItemLeft" align="right" valign="top"><a id="ab686403729b9b26c8a089429149c0f95"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ShowGeometricData</b> (GeometricData type, ElementType mask)</td></tr>
<tr class="separator:ab686403729b9b26c8a089429149c0f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05258a2df2245f94700407c0e51e5559"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a05258a2df2245f94700407c0e51e5559">FacesOrientation</a> (const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Face.html">Face</a> &gt; &amp;faces, MarkerType rev)</td></tr>
<tr class="memdesc:a05258a2df2245f94700407c0e51e5559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks face with the orientation direction by marker.  <a href="classINMOST_1_1Mesh.html#a05258a2df2245f94700407c0e51e5559">More...</a><br /></td></tr>
<tr class="separator:a05258a2df2245f94700407c0e51e5559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc09a4fc3332816c8310094580603cf"><td class="memItemLeft" align="right" valign="top"><a id="a2bc09a4fc3332816c8310094580603cf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>FacesOrientation</b> (const HandleType *faces, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> size, MarkerType rev, bool check_convexity=true, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> start=0)</td></tr>
<tr class="separator:a2bc09a4fc3332816c8310094580603cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1623b91d79fd2407fdf85002f96ca5"><td class="memItemLeft" align="right" valign="top"><a id="aeb1623b91d79fd2407fdf85002f96ca5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CollectCentroidsNormals</b> (const HandleType *faces, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> size, <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> *x, <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> *n)</td></tr>
<tr class="separator:aeb1623b91d79fd2407fdf85002f96ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa183171e2fe1cef14916e28aafc72491"><td class="memItemLeft" align="right" valign="top"><a id="aa183171e2fe1cef14916e28aafc72491"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>CheckConvexity</b> (const <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> *x, const <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> *n, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> size) const</td></tr>
<tr class="separator:aa183171e2fe1cef14916e28aafc72491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59df7ea85d076cdda4a48bbd8b9d1169"><td class="memItemLeft" align="right" valign="top"><a id="a59df7ea85d076cdda4a48bbd8b9d1169"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>CheckConvexity</b> (const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Face.html">Face</a> &gt; &amp;faces)</td></tr>
<tr class="separator:a59df7ea85d076cdda4a48bbd8b9d1169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b972dc303e9b321325667ceb84a9be0"><td class="memItemLeft" align="right" valign="top"><a id="a0b972dc303e9b321325667ceb84a9be0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>CheckConvexity</b> (const HandleType *faces, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> size)</td></tr>
<tr class="separator:a0b972dc303e9b321325667ceb84a9be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ff8ea3298e7ff39ccffdaaa1ebef58"><td class="memItemLeft" align="right" valign="top"><a id="af4ff8ea3298e7ff39ccffdaaa1ebef58"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PrepareGeometricData</b> (GeomParam table)</td></tr>
<tr class="separator:af4ff8ea3298e7ff39ccffdaaa1ebef58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04aaadf5c297568d18cd9a23df11535a"><td class="memItemLeft" align="right" valign="top"><a id="a04aaadf5c297568d18cd9a23df11535a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveGeometricData</b> (GeomParam table)</td></tr>
<tr class="separator:a04aaadf5c297568d18cd9a23df11535a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a2e7eb6e15d05e808f31f61d8cde08"><td class="memItemLeft" align="right" valign="top"><a id="a83a2e7eb6e15d05e808f31f61d8cde08"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HaveGeometricData</b> (GeometricData type, ElementType mask) const</td></tr>
<tr class="separator:a83a2e7eb6e15d05e808f31f61d8cde08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3baaeba7978ddf3449399428e8d4e11a"><td class="memItemLeft" align="right" valign="top"><a id="a3baaeba7978ddf3449399428e8d4e11a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GetGeometricData</b> (HandleType e, GeometricData type, <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> *ret)</td></tr>
<tr class="separator:a3baaeba7978ddf3449399428e8d4e11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b4e4bcb75d19832963c4211ad880b5"><td class="memItemLeft" align="right" valign="top"><a id="a10b4e4bcb75d19832963c4211ad880b5"></a>
const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetGeometricTag</b> (GeometricData type) const</td></tr>
<tr class="separator:a10b4e4bcb75d19832963c4211ad880b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b96eedd197fb3c574477e5d303dc696"><td class="memItemLeft" align="right" valign="top"><a id="a6b96eedd197fb3c574477e5d303dc696"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TestClosure</b> (const HandleType *elements, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> num) const</td></tr>
<tr class="separator:a6b96eedd197fb3c574477e5d303dc696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe976b702bcc86662c1551df5ed26a8"><td class="memItemLeft" align="right" valign="top"><a id="a8fe976b702bcc86662c1551df5ed26a8"></a>
<a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Face.html">Face</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GatherBoundaryFaces</b> ()</td></tr>
<tr class="separator:a8fe976b702bcc86662c1551df5ed26a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a1985acd5676d83a8f5d9aa6b0e927"><td class="memItemLeft" align="right" valign="top"><a id="a89a1985acd5676d83a8f5d9aa6b0e927"></a>
<a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Face.html">Face</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GatherInteriorFaces</b> ()</td></tr>
<tr class="separator:a89a1985acd5676d83a8f5d9aa6b0e927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fac7af473402381cb2b967f4ae057c"><td class="memItemLeft" align="right" valign="top"><a id="a28fac7af473402381cb2b967f4ae057c"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CountBoundaryFaces</b> ()</td></tr>
<tr class="separator:a28fac7af473402381cb2b967f4ae057c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89ada8254d449794ab4f55815963ecb"><td class="memItemLeft" align="right" valign="top"><a id="af89ada8254d449794ab4f55815963ecb"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CountInteriorFaces</b> ()</td></tr>
<tr class="separator:af89ada8254d449794ab4f55815963ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c37578b501567112f44032844be8023"><td class="memItemLeft" align="right" valign="top"><a id="a7c37578b501567112f44032844be8023"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>FixEdgeOrder</b> (HandleType *edges, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> nedges) const</td></tr>
<tr class="separator:a7c37578b501567112f44032844be8023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1263ae4c38b01550f28ee6f502d75246"><td class="memItemLeft" align="right" valign="top"><a id="a1263ae4c38b01550f28ee6f502d75246"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RecomputeGeometricData</b> (HandleType e)</td></tr>
<tr class="separator:a1263ae4c38b01550f28ee6f502d75246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9165b2a02f28e059155620f0573cf2"><td class="memItemLeft" align="right" valign="top"><a id="a6c9165b2a02f28e059155620f0573cf2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RecomputeGeometricData</b> (HandleType e, GeometricData d)</td></tr>
<tr class="separator:a6c9165b2a02f28e059155620f0573cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0232da075275a354c6b5d162b02e6dd2"><td class="memItemLeft" align="right" valign="top"><a id="a0232da075275a354c6b5d162b02e6dd2"></a>
Element::GeometricType&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeGeometricType</b> (ElementType element_type, const HandleType *lower_adjacent, INMOST_DATA_ENUM_TYPE lower_adjacent_size)</td></tr>
<tr class="separator:a0232da075275a354c6b5d162b02e6dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4179160ff41a6a94a7423fc9034f3a6"><td class="memItemLeft" align="right" valign="top"><a id="ae4179160ff41a6a94a7423fc9034f3a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeCentroid</b> (<a class="el" href="classINMOST_1_1Element.html">Element</a> e, <a class="el" href="classINMOST_1_1TagRealArray.html">TagRealArray</a> coords, <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> *x) const</td></tr>
<tr class="separator:ae4179160ff41a6a94a7423fc9034f3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ec688150f115ee3648305f8d90894e"><td class="memItemLeft" align="right" valign="top"><a id="a91ec688150f115ee3648305f8d90894e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeBarycenter</b> (<a class="el" href="classINMOST_1_1Element.html">Element</a> e, <a class="el" href="classINMOST_1_1TagRealArray.html">TagRealArray</a> coords, <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> *x) const</td></tr>
<tr class="separator:a91ec688150f115ee3648305f8d90894e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94736553caadc69094877f535713213d"><td class="memItemLeft" align="right" valign="top"><a id="a94736553caadc69094877f535713213d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeNormal</b> (<a class="el" href="classINMOST_1_1Element.html">Element</a> e, <a class="el" href="classINMOST_1_1TagRealArray.html">TagRealArray</a> coords, <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> *n) const</td></tr>
<tr class="separator:a94736553caadc69094877f535713213d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a505b0b717ab3ea10c8673e3540ab38"><td class="memItemLeft" align="right" valign="top"><a id="a0a505b0b717ab3ea10c8673e3540ab38"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeMeasure</b> (<a class="el" href="classINMOST_1_1Element.html">Element</a> e, <a class="el" href="classINMOST_1_1TagRealArray.html">TagRealArray</a> coords, <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> &amp;m) const</td></tr>
<tr class="separator:a0a505b0b717ab3ea10c8673e3540ab38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320fba541df903801da3ddb1a9b718bb"><td class="memItemLeft" align="right" valign="top"><a id="a320fba541df903801da3ddb1a9b718bb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeCentroid</b> (<a class="el" href="classINMOST_1_1Element.html">Element</a> e, <a class="el" href="classINMOST_1_1TagVariableArray.html">TagVariableArray</a> coords, <a class="el" href="classINMOST_1_1multivar__expression.html">variable</a> *x) const</td></tr>
<tr class="separator:a320fba541df903801da3ddb1a9b718bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188b0a93bd7f70f3057c1e1b320450f6"><td class="memItemLeft" align="right" valign="top"><a id="a188b0a93bd7f70f3057c1e1b320450f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeBarycenter</b> (<a class="el" href="classINMOST_1_1Element.html">Element</a> e, <a class="el" href="classINMOST_1_1TagVariableArray.html">TagVariableArray</a> coords, <a class="el" href="classINMOST_1_1multivar__expression.html">variable</a> *x) const</td></tr>
<tr class="separator:a188b0a93bd7f70f3057c1e1b320450f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54897b1644bc980767df5e62cb0c271e"><td class="memItemLeft" align="right" valign="top"><a id="a54897b1644bc980767df5e62cb0c271e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeNormal</b> (<a class="el" href="classINMOST_1_1Element.html">Element</a> e, <a class="el" href="classINMOST_1_1TagVariableArray.html">TagVariableArray</a> coords, <a class="el" href="classINMOST_1_1multivar__expression.html">variable</a> *n) const</td></tr>
<tr class="separator:a54897b1644bc980767df5e62cb0c271e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa481d1581538b3d824f5dbf5ba16989f"><td class="memItemLeft" align="right" valign="top"><a id="aa481d1581538b3d824f5dbf5ba16989f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeMeasure</b> (<a class="el" href="classINMOST_1_1Element.html">Element</a> e, <a class="el" href="classINMOST_1_1TagVariableArray.html">TagVariableArray</a> coords, <a class="el" href="classINMOST_1_1multivar__expression.html">variable</a> &amp;m) const</td></tr>
<tr class="separator:aa481d1581538b3d824f5dbf5ba16989f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55554909d705c0084077dbaf9c49c509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a55554909d705c0084077dbaf9c49c509">WachspressInterpolation2D</a> (const <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> *x, const <a class="el" href="classINMOST_1_1Face.html">Face</a> &amp;f, std::map&lt; HandleType, <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> &gt; &amp;nodes_stencil) const</td></tr>
<tr class="memdesc:a55554909d705c0084077dbaf9c49c509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute node-centered interpolation on 2d face for point.  <a href="classINMOST_1_1Mesh.html#a55554909d705c0084077dbaf9c49c509">More...</a><br /></td></tr>
<tr class="separator:a55554909d705c0084077dbaf9c49c509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00c3c0062cb8b87e5f5a9e61d03a9de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ad00c3c0062cb8b87e5f5a9e61d03a9de">WachspressInterpolation3D</a> (const <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> *x, const <a class="el" href="classINMOST_1_1Cell.html">Cell</a> &amp;c, std::map&lt; HandleType, <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> &gt; &amp;nodes_stencil) const</td></tr>
<tr class="memdesc:ad00c3c0062cb8b87e5f5a9e61d03a9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute node-centered interpolation on 3d cell for point Point should be inside cell or on its boundary.  <a href="classINMOST_1_1Mesh.html#ad00c3c0062cb8b87e5f5a9e61d03a9de">More...</a><br /></td></tr>
<tr class="separator:ad00c3c0062cb8b87e5f5a9e61d03a9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722acc2cd2e4c231d512dc81b70b47ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a722acc2cd2e4c231d512dc81b70b47ca">MarkBoundaryFaces</a> (MarkerType boundary_marker)</td></tr>
<tr class="memdesc:a722acc2cd2e4c231d512dc81b70b47ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets marker for all the faces that have only one neighbouring cell, works correctly in parallel environment.  <a href="classINMOST_1_1Mesh.html#a722acc2cd2e4c231d512dc81b70b47ca">More...</a><br /></td></tr>
<tr class="separator:a722acc2cd2e4c231d512dc81b70b47ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efb0a61a91538bba5e5d49e5a992362"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a4efb0a61a91538bba5e5d49e5a992362">MarkNormalOrientation</a> (MarkerType mrk)</td></tr>
<tr class="memdesc:a4efb0a61a91538bba5e5d49e5a992362"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function should be used to detect normal inversion on ghost interfaces with respect to normal orientation on owner of the interface.  <a href="classINMOST_1_1Mesh.html#a4efb0a61a91538bba5e5d49e5a992362">More...</a><br /></td></tr>
<tr class="separator:a4efb0a61a91538bba5e5d49e5a992362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25c2244369c7652879c1ef931606bfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ac25c2244369c7652879c1ef931606bfc">isMeshModified</a> () const</td></tr>
<tr class="memdesc:ac25c2244369c7652879c1ef931606bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether code runs between Mesh::BeginModification, Mesh::EndModification scope.  <a href="classINMOST_1_1Mesh.html#ac25c2244369c7652879c1ef931606bfc">More...</a><br /></td></tr>
<tr class="separator:ac25c2244369c7652879c1ef931606bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46279eca87296de66a9718b4f05cb2e2"><td class="memItemLeft" align="right" valign="top"><a id="a46279eca87296de66a9718b4f05cb2e2"></a>
MarkerType&#160;</td><td class="memItemRight" valign="bottom"><b>HideMarker</b> () const</td></tr>
<tr class="separator:a46279eca87296de66a9718b4f05cb2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9a453703413174df0e0a1586302e21"><td class="memItemLeft" align="right" valign="top"><a id="afd9a453703413174df0e0a1586302e21"></a>
MarkerType&#160;</td><td class="memItemRight" valign="bottom"><b>NewMarker</b> () const</td></tr>
<tr class="separator:afd9a453703413174df0e0a1586302e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e166635d01a25087f7a11b84c3633a6"><td class="memItemLeft" align="right" valign="top"><a id="a7e166635d01a25087f7a11b84c3633a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SwapModification</b> (bool recompute_geometry)</td></tr>
<tr class="separator:a7e166635d01a25087f7a11b84c3633a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0c0ff2608666651ef66adc1c143352"><td class="memItemLeft" align="right" valign="top"><a id="aef0c0ff2608666651ef66adc1c143352"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>BeginModification</b> ()</td></tr>
<tr class="separator:aef0c0ff2608666651ef66adc1c143352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f53070855f3503b2f4cefc16cedd6a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a1f53070855f3503b2f4cefc16cedd6a0">ApplyModification</a> ()</td></tr>
<tr class="memdesc:a1f53070855f3503b2f4cefc16cedd6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">After this function any link to deleted element will be replaced by InvalidHandle().  <a href="classINMOST_1_1Mesh.html#a1f53070855f3503b2f4cefc16cedd6a0">More...</a><br /></td></tr>
<tr class="separator:a1f53070855f3503b2f4cefc16cedd6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60274817b98e76ec5a411f0c3df2a76b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a60274817b98e76ec5a411f0c3df2a76b">ResolveModification</a> ()</td></tr>
<tr class="memdesc:a60274817b98e76ec5a411f0c3df2a76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is not yet implemented.  <a href="classINMOST_1_1Mesh.html#a60274817b98e76ec5a411f0c3df2a76b">More...</a><br /></td></tr>
<tr class="separator:a60274817b98e76ec5a411f0c3df2a76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1dacf6bdaf0654c5a2ad5d2d6e57966"><td class="memItemLeft" align="right" valign="top"><a id="ac1dacf6bdaf0654c5a2ad5d2d6e57966"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EndModification</b> ()</td></tr>
<tr class="separator:ac1dacf6bdaf0654c5a2ad5d2d6e57966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa001c602d501db8497af2eb4d01fd95b"><td class="memItemLeft" align="right" valign="top"><a id="aa001c602d501db8497af2eb4d01fd95b"></a>
<a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getNext</b> (const HandleType *arr, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> size, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> k, MarkerType marker) const</td></tr>
<tr class="separator:aa001c602d501db8497af2eb4d01fd95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41563d111df7229666e79b320a6c93bd"><td class="memItemLeft" align="right" valign="top"><a id="a41563d111df7229666e79b320a6c93bd"></a>
<a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Count</b> (const HandleType *arr, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> size, MarkerType marker) const</td></tr>
<tr class="separator:a41563d111df7229666e79b320a6c93bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad13d793944c7bbd1699e27ebcc078ee"><td class="memItemLeft" align="right" valign="top"><a id="aad13d793944c7bbd1699e27ebcc078ee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EquilibrateGhost</b> ()</td></tr>
<tr class="separator:aad13d793944c7bbd1699e27ebcc078ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15464edb409ccaacc512fea774aaa7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ab15464edb409ccaacc512fea774aaa7d">CheckCentroids</a> (std::string file, int line)</td></tr>
<tr class="memdesc:ab15464edb409ccaacc512fea774aaa7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that centroids of ghost and shared elements match to each other.  <a href="classINMOST_1_1Mesh.html#ab15464edb409ccaacc512fea774aaa7d">More...</a><br /></td></tr>
<tr class="separator:ab15464edb409ccaacc512fea774aaa7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f83c226d5d74bcd9f54418592836fca"><td class="memItemLeft" align="right" valign="top"><a id="a0f83c226d5d74bcd9f54418592836fca"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a0f83c226d5d74bcd9f54418592836fca">CheckProcsSorted</a> (std::string file, int line)</td></tr>
<tr class="memdesc:a0f83c226d5d74bcd9f54418592836fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that processors are sorted on every element. <br /></td></tr>
<tr class="separator:a0f83c226d5d74bcd9f54418592836fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bd4434c332d01378ab77fe67c45767"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a64bd4434c332d01378ab77fe67c45767">CheckGhostSharedCount</a> (std::string file, int line, ElementType etype=ESET|CELL|FACE|EDGE|NODE)</td></tr>
<tr class="memdesc:a64bd4434c332d01378ab77fe67c45767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that number of ghost and shared elements match to each other.  <a href="classINMOST_1_1Mesh.html#a64bd4434c332d01378ab77fe67c45767">More...</a><br /></td></tr>
<tr class="separator:a64bd4434c332d01378ab77fe67c45767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa8f4dd50e8b7c8c8606ea9043e485c"><td class="memItemLeft" align="right" valign="top"><a id="adfa8f4dd50e8b7c8c8606ea9043e485c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#adfa8f4dd50e8b7c8c8606ea9043e485c">CheckOwners</a> (std::string file, int line)</td></tr>
<tr class="memdesc:adfa8f4dd50e8b7c8c8606ea9043e485c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let ghost elements send processors list to master elements and see if they match. <br /></td></tr>
<tr class="separator:adfa8f4dd50e8b7c8c8606ea9043e485c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b01d4557ab7aa6a648cf06f177f7c43"><td class="memItemLeft" align="right" valign="top"><a id="a6b01d4557ab7aa6a648cf06f177f7c43"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a6b01d4557ab7aa6a648cf06f177f7c43">CheckGIDs</a> (std::string file, int line, ElementType mask=NODE|EDGE|FACE|CELL|ESET)</td></tr>
<tr class="memdesc:a6b01d4557ab7aa6a648cf06f177f7c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let ghost elements send global ids to master elements and see if they match. <br /></td></tr>
<tr class="separator:a6b01d4557ab7aa6a648cf06f177f7c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da8be5e6b25ae2e7a059f68f9874a73"><td class="memItemLeft" align="right" valign="top"><a id="a1da8be5e6b25ae2e7a059f68f9874a73"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a1da8be5e6b25ae2e7a059f68f9874a73">CheckProcessors</a> ()</td></tr>
<tr class="memdesc:a1da8be5e6b25ae2e7a059f68f9874a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let ghost elements send owner processor to master elements and see if they match. <br /></td></tr>
<tr class="separator:a1da8be5e6b25ae2e7a059f68f9874a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42aefad25fc68c852384ed73cb498abb"><td class="memItemLeft" align="right" valign="top"><a id="a42aefad25fc68c852384ed73cb498abb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a42aefad25fc68c852384ed73cb498abb">CheckSetLinks</a> (std::string file, int line)</td></tr>
<tr class="memdesc:a42aefad25fc68c852384ed73cb498abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that there are no invalid links in sets. <br /></td></tr>
<tr class="separator:a42aefad25fc68c852384ed73cb498abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55549e9d46cd92e2f3122e1516f3c9fd"><td class="memItemLeft" align="right" valign="top">TopologyCheck&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a55549e9d46cd92e2f3122e1516f3c9fd">BeginTopologyCheck</a> (ElementType etype, const HandleType *adj, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> num)</td></tr>
<tr class="memdesc:a55549e9d46cd92e2f3122e1516f3c9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allows you to perform some topological checks before you create an element.  <a href="classINMOST_1_1Mesh.html#a55549e9d46cd92e2f3122e1516f3c9fd">More...</a><br /></td></tr>
<tr class="separator:a55549e9d46cd92e2f3122e1516f3c9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97177e1b6f8fe810eb5d072fb378b22e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a97177e1b6f8fe810eb5d072fb378b22e">EndTopologyCheck</a> (HandleType e, TopologyCheck begin_check)</td></tr>
<tr class="memdesc:a97177e1b6f8fe810eb5d072fb378b22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs some topological checks after construction of element.  <a href="classINMOST_1_1Mesh.html#a97177e1b6f8fe810eb5d072fb378b22e">More...</a><br /></td></tr>
<tr class="separator:a97177e1b6f8fe810eb5d072fb378b22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93dcc86ea21e59c9f32e61b901fcffa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Tag.html">Tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#af93dcc86ea21e59c9f32e61b901fcffa">TopologyErrorTag</a> () const</td></tr>
<tr class="memdesc:af93dcc86ea21e59c9f32e61b901fcffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will return tag by which you can retrieve error mark to any element on which topology check failed.  <a href="classINMOST_1_1Mesh.html#af93dcc86ea21e59c9f32e61b901fcffa">More...</a><br /></td></tr>
<tr class="separator:af93dcc86ea21e59c9f32e61b901fcffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8779484218dd10a3752a6d71e83baf"><td class="memItemLeft" align="right" valign="top"><a id="a6a8779484218dd10a3752a6d71e83baf"></a>
TopologyCheck&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a6a8779484218dd10a3752a6d71e83baf">GetTopologyCheck</a> (TopologyCheck mask=ENUMUNDEF) const</td></tr>
<tr class="memdesc:a6a8779484218dd10a3752a6d71e83baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve currently set topology checks. <br /></td></tr>
<tr class="separator:a6a8779484218dd10a3752a6d71e83baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f578239d7b369ad4b1edb69eea24d2"><td class="memItemLeft" align="right" valign="top"><a id="af9f578239d7b369ad4b1edb69eea24d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#af9f578239d7b369ad4b1edb69eea24d2">SetTopologyCheck</a> (TopologyCheck mask)</td></tr>
<tr class="memdesc:af9f578239d7b369ad4b1edb69eea24d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set topology checks. <br /></td></tr>
<tr class="separator:af9f578239d7b369ad4b1edb69eea24d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374a56ae3bdae9e54030c72538836c09"><td class="memItemLeft" align="right" valign="top"><a id="a374a56ae3bdae9e54030c72538836c09"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a374a56ae3bdae9e54030c72538836c09">RemTopologyCheck</a> (TopologyCheck mask)</td></tr>
<tr class="memdesc:a374a56ae3bdae9e54030c72538836c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove topology checks. <br /></td></tr>
<tr class="separator:a374a56ae3bdae9e54030c72538836c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac6bf21484fbe477cde2234ddef555e"><td class="memItemLeft" align="right" valign="top"><a id="a5ac6bf21484fbe477cde2234ddef555e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a5ac6bf21484fbe477cde2234ddef555e">SetTopologyError</a> (TopologyCheck mask)</td></tr>
<tr class="memdesc:a5ac6bf21484fbe477cde2234ddef555e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will turn mesh into the state indicating that some topology error occurred. <br /></td></tr>
<tr class="separator:a5ac6bf21484fbe477cde2234ddef555e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2289b9ef2f0a2972bb88edcc47b1e3f"><td class="memItemLeft" align="right" valign="top"><a id="ab2289b9ef2f0a2972bb88edcc47b1e3f"></a>
TopologyCheck&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ab2289b9ef2f0a2972bb88edcc47b1e3f">GetTopologyError</a> (TopologyCheck mask=ENUMUNDEF) const</td></tr>
<tr class="memdesc:ab2289b9ef2f0a2972bb88edcc47b1e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve topology error state, this indicates that some error have occurred. <br /></td></tr>
<tr class="separator:ab2289b9ef2f0a2972bb88edcc47b1e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4d3c7dd08bd37844494d08adf8ac2f"><td class="memItemLeft" align="right" valign="top"><a id="a1d4d3c7dd08bd37844494d08adf8ac2f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a1d4d3c7dd08bd37844494d08adf8ac2f">ClearTopologyError</a> (TopologyCheck mask=ENUMUNDEF)</td></tr>
<tr class="memdesc:a1d4d3c7dd08bd37844494d08adf8ac2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Revert mesh to clean topology error state. <br /></td></tr>
<tr class="separator:a1d4d3c7dd08bd37844494d08adf8ac2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49994e93f25513716f352933f5c0599"><td class="memItemLeft" align="right" valign="top"><a id="ae49994e93f25513716f352933f5c0599"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SortHandles</b> (HandleType *h, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> num)</td></tr>
<tr class="separator:ae49994e93f25513716f352933f5c0599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8cfa72de874bd9a17fb0067ac8d515"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a9f8cfa72de874bd9a17fb0067ac8d515">SortByGlobalID</a> (HandleType *h, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> num)</td></tr>
<tr class="separator:a9f8cfa72de874bd9a17fb0067ac8d515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf437cdac03540f905a0d0b1be0b878"><td class="memItemLeft" align="right" valign="top"><a id="a3bf437cdac03540f905a0d0b1be0b878"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a3bf437cdac03540f905a0d0b1be0b878">GetMeshName</a> ()</td></tr>
<tr class="memdesc:a3bf437cdac03540f905a0d0b1be0b878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the name of the current mesh. <br /></td></tr>
<tr class="separator:a3bf437cdac03540f905a0d0b1be0b878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f169d19d15a755129c0f0fc53561e4"><td class="memItemLeft" align="right" valign="top"><a id="a22f169d19d15a755129c0f0fc53561e4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a22f169d19d15a755129c0f0fc53561e4">SetMeshName</a> (std::string new_name)</td></tr>
<tr class="memdesc:a22f169d19d15a755129c0f0fc53561e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Be careful changing mesh name if you have already established remote links. <br /></td></tr>
<tr class="separator:a22f169d19d15a755129c0f0fc53561e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classINMOST_1_1TagManager"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classINMOST_1_1TagManager')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classINMOST_1_1TagManager.html">INMOST::TagManager</a></td></tr>
<tr class="memitem:affcef8566c35b5497190884343a076bf inherit pub_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="affcef8566c35b5497190884343a076bf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1TagManager.html#affcef8566c35b5497190884343a076bf">HaveTag</a> (std::string name) const</td></tr>
<tr class="memdesc:affcef8566c35b5497190884343a076bf inherit pub_methods_classINMOST_1_1TagManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check existence of a data tag by it's name. <br /></td></tr>
<tr class="separator:affcef8566c35b5497190884343a076bf inherit pub_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e21150213a8d67b38606c46fd93081 inherit pub_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="a57e21150213a8d67b38606c46fd93081"></a>
<a class="el" href="classINMOST_1_1Tag.html">Tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1TagManager.html#a57e21150213a8d67b38606c46fd93081">GetTag</a> (std::string name) const</td></tr>
<tr class="memdesc:a57e21150213a8d67b38606c46fd93081 inherit pub_methods_classINMOST_1_1TagManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a data tag by it's name. <br /></td></tr>
<tr class="separator:a57e21150213a8d67b38606c46fd93081 inherit pub_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be2c2d7f117269c4738a9cc46111418 inherit pub_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="a9be2c2d7f117269c4738a9cc46111418"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1TagManager.html#a9be2c2d7f117269c4738a9cc46111418">ListTagNames</a> (std::vector&lt; std::string &gt; &amp;list) const</td></tr>
<tr class="memdesc:a9be2c2d7f117269c4738a9cc46111418 inherit pub_methods_classINMOST_1_1TagManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve names for all the tags present on the mesh. <br /></td></tr>
<tr class="separator:a9be2c2d7f117269c4738a9cc46111418 inherit pub_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85b7509d389191f59772bf5defc931b inherit pub_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="ac85b7509d389191f59772bf5defc931b"></a>
<a class="el" href="classINMOST_1_1Tag.html">Tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1TagManager.html#ac85b7509d389191f59772bf5defc931b">CreateTag</a> (<a class="el" href="classINMOST_1_1Mesh.html">Mesh</a> *m, std::string name, DataType dtype, ElementType etype, ElementType sparse, INMOST_DATA_ENUM_TYPE size=ENUMUNDEF)</td></tr>
<tr class="memdesc:ac85b7509d389191f59772bf5defc931b inherit pub_methods_classINMOST_1_1TagManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create tag with prescribed attributes. <br /></td></tr>
<tr class="separator:ac85b7509d389191f59772bf5defc931b inherit pub_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abdbb43891f82ef98421d2b2f2e1c36 inherit pub_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="a5abdbb43891f82ef98421d2b2f2e1c36"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1TagManager.html#a5abdbb43891f82ef98421d2b2f2e1c36">ElementDefined</a> (<a class="el" href="classINMOST_1_1Tag.html">Tag</a> const &amp;tag, ElementType etype) const</td></tr>
<tr class="memdesc:a5abdbb43891f82ef98421d2b2f2e1c36 inherit pub_methods_classINMOST_1_1TagManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the tag was defined on certain elements. <br /></td></tr>
<tr class="separator:a5abdbb43891f82ef98421d2b2f2e1c36 inherit pub_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290660533818b6126594c8fa5115b2be inherit pub_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="a290660533818b6126594c8fa5115b2be"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1TagManager.html#a290660533818b6126594c8fa5115b2be">RenameTag</a> (std::string oldname, std::string newname)</td></tr>
<tr class="memdesc:a290660533818b6126594c8fa5115b2be inherit pub_methods_classINMOST_1_1TagManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change tag name. <br /></td></tr>
<tr class="separator:a290660533818b6126594c8fa5115b2be inherit pub_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classINMOST_1_1Storage"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classINMOST_1_1Storage')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classINMOST_1_1Storage.html">INMOST::Storage</a></td></tr>
<tr class="memitem:adf1bf5a77779751b057db0d2a1d5defc inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="adf1bf5a77779751b057db0d2a1d5defc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Storage</b> (const <a class="el" href="classINMOST_1_1Storage.html">Storage</a> &amp;other)</td></tr>
<tr class="separator:adf1bf5a77779751b057db0d2a1d5defc inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54484f34481cbd2583588f7ca502521 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="ab54484f34481cbd2583588f7ca502521"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Storage</b> (<a class="el" href="classINMOST_1_1Mesh.html">Mesh</a> *mesh, HandleType handle)</td></tr>
<tr class="separator:ab54484f34481cbd2583588f7ca502521 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd7d01b2f05bf061ba8439fd1d25599 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a9fd7d01b2f05bf061ba8439fd1d25599"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a9fd7d01b2f05bf061ba8439fd1d25599">Storage</a> (<a class="el" href="classINMOST_1_1Mesh.html">Mesh</a> *mesh, HandleType *handle)</td></tr>
<tr class="memdesc:a9fd7d01b2f05bf061ba8439fd1d25599 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor allows for remote handle modification. <br /></td></tr>
<tr class="separator:a9fd7d01b2f05bf061ba8439fd1d25599 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156c939c83d6854e1efaa29c1c38dddb inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a156c939c83d6854e1efaa29c1c38dddb"></a>
<a class="el" href="classINMOST_1_1Storage.html">Storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a156c939c83d6854e1efaa29c1c38dddb">operator=</a> (<a class="el" href="classINMOST_1_1Storage.html">Storage</a> const &amp;other)</td></tr>
<tr class="memdesc:a156c939c83d6854e1efaa29c1c38dddb inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there is a link to handle provided (automatically by <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a> and <a class="el" href="classINMOST_1_1Storage_1_1reference__array.html" title="Storage type for representing arrays of Element references.">reference_array</a>), then remote handle value will be modified. <br /></td></tr>
<tr class="separator:a156c939c83d6854e1efaa29c1c38dddb inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391292da4950361793876e5104e55985 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a391292da4950361793876e5104e55985"></a>
__INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classINMOST_1_1Storage.html">Storage</a> &amp;other) const</td></tr>
<tr class="separator:a391292da4950361793876e5104e55985 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae700c8348caef383d24f329df7c60641 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="ae700c8348caef383d24f329df7c60641"></a>
__INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classINMOST_1_1Storage.html">Storage</a> &amp;other) const</td></tr>
<tr class="separator:ae700c8348caef383d24f329df7c60641 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5c4384df1001693d4b74cb8993f986 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a6c5c4384df1001693d4b74cb8993f986"></a>
__INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classINMOST_1_1Storage.html">Storage</a> &amp;other) const</td></tr>
<tr class="separator:a6c5c4384df1001693d4b74cb8993f986 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ad49971831616d7d61ec7a7c478124 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="aa2ad49971831616d7d61ec7a7c478124"></a>
__INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classINMOST_1_1Storage.html">Storage</a> &amp;other) const</td></tr>
<tr class="separator:aa2ad49971831616d7d61ec7a7c478124 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073a75721d3ab3d0227939031a387b18 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a073a75721d3ab3d0227939031a387b18"></a>
__INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classINMOST_1_1Storage.html">Storage</a> &amp;other) const</td></tr>
<tr class="separator:a073a75721d3ab3d0227939031a387b18 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8650c5b4c330ead51c47a3bba46514 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a0b8650c5b4c330ead51c47a3bba46514"></a>
__INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classINMOST_1_1Storage.html">Storage</a> &amp;other) const</td></tr>
<tr class="separator:a0b8650c5b4c330ead51c47a3bba46514 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e60eb00c11f362cf521f92a94ca4f2 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="aa3e60eb00c11f362cf521f92a94ca4f2"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html">Storage</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>operator-&gt;</b> ()</td></tr>
<tr class="separator:aa3e60eb00c11f362cf521f92a94ca4f2 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f960856c2bb3d13411b428801feb5e9 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a7f960856c2bb3d13411b428801feb5e9"></a>
__INLINE const <a class="el" href="classINMOST_1_1Storage.html">Storage</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>operator-&gt;</b> () const</td></tr>
<tr class="separator:a7f960856c2bb3d13411b428801feb5e9 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c957f80e61bf090e0aff23a9d5a59e inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="aa7c957f80e61bf090e0aff23a9d5a59e"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html">Storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>self</b> ()</td></tr>
<tr class="separator:aa7c957f80e61bf090e0aff23a9d5a59e inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa4766983755aab20da91a1fdf517af inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a9fa4766983755aab20da91a1fdf517af"></a>
__INLINE const <a class="el" href="classINMOST_1_1Storage.html">Storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>self</b> () const</td></tr>
<tr class="separator:a9fa4766983755aab20da91a1fdf517af inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf24cc0b3c8bd4ff1e9ec6745aa1a7a2 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top">__INLINE <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#abf24cc0b3c8bd4ff1e9ec6745aa1a7a2">Real</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="memdesc:abf24cc0b3c8bd4ff1e9ec6745aa1a7a2 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve real value associated with <a class="el" href="classINMOST_1_1Tag.html" title="This class provides the access to the individual mesh datum and general information about it.">Tag</a>.  <a href="classINMOST_1_1Storage.html#abf24cc0b3c8bd4ff1e9ec6745aa1a7a2">More...</a><br /></td></tr>
<tr class="separator:abf24cc0b3c8bd4ff1e9ec6745aa1a7a2 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a47d1cc19bc47d5852278b195a7097 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top">__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a10a47d1cc19bc47d5852278b195a7097">Integer</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="memdesc:a10a47d1cc19bc47d5852278b195a7097 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve integer value associated with <a class="el" href="classINMOST_1_1Tag.html" title="This class provides the access to the individual mesh datum and general information about it.">Tag</a>.  <a href="classINMOST_1_1Storage.html#a10a47d1cc19bc47d5852278b195a7097">More...</a><br /></td></tr>
<tr class="separator:a10a47d1cc19bc47d5852278b195a7097 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3155dac6532a98496dbdce82b747099 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top">__INLINE <a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#ac3155dac6532a98496dbdce82b747099">Bulk</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="memdesc:ac3155dac6532a98496dbdce82b747099 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve one byte of abstract data associated with <a class="el" href="classINMOST_1_1Tag.html" title="This class provides the access to the individual mesh datum and general information about it.">Tag</a>.  <a href="classINMOST_1_1Storage.html#ac3155dac6532a98496dbdce82b747099">More...</a><br /></td></tr>
<tr class="separator:ac3155dac6532a98496dbdce82b747099 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0d7442b82b4b22816aacc0fe2c8244 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top">__INLINE <a class="el" href="classINMOST_1_1Storage.html#a8674802045ec170a3c9d0e3281545b54">reference</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a7a0d7442b82b4b22816aacc0fe2c8244">Reference</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="memdesc:a7a0d7442b82b4b22816aacc0fe2c8244 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve <a class="el" href="classINMOST_1_1Element.html">Element</a> reference associated with <a class="el" href="classINMOST_1_1Tag.html" title="This class provides the access to the individual mesh datum and general information about it.">Tag</a>.  <a href="classINMOST_1_1Storage.html#a7a0d7442b82b4b22816aacc0fe2c8244">More...</a><br /></td></tr>
<tr class="separator:a7a0d7442b82b4b22816aacc0fe2c8244 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2d9e40095bbe1e04b7156386a6c548 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top">__INLINE <a class="el" href="classINMOST_1_1Storage.html#a211e235d55d933c5dc3f7040e0b50504">remote_reference</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#abb2d9e40095bbe1e04b7156386a6c548">RemoteReference</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="memdesc:abb2d9e40095bbe1e04b7156386a6c548 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve remote <a class="el" href="classINMOST_1_1Element.html">Element</a> reference associated with <a class="el" href="classINMOST_1_1Tag.html" title="This class provides the access to the individual mesh datum and general information about it.">Tag</a>.  <a href="classINMOST_1_1Storage.html#abb2d9e40095bbe1e04b7156386a6c548">More...</a><br /></td></tr>
<tr class="separator:abb2d9e40095bbe1e04b7156386a6c548 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd79be7aceabbf793cf6b72f2e905974 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top">__INLINE <a class="el" href="classINMOST_1_1Storage.html#a430e5358d435befb38169beef593527e">real_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#acd79be7aceabbf793cf6b72f2e905974">RealArray</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="memdesc:acd79be7aceabbf793cf6b72f2e905974 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve array of real values associated with <a class="el" href="classINMOST_1_1Tag.html" title="This class provides the access to the individual mesh datum and general information about it.">Tag</a>.  <a href="classINMOST_1_1Storage.html#acd79be7aceabbf793cf6b72f2e905974">More...</a><br /></td></tr>
<tr class="separator:acd79be7aceabbf793cf6b72f2e905974 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880b8edd620319cd355139e36de8cb1b inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top">__INLINE <a class="el" href="classINMOST_1_1Storage.html#a4d1637367f0487eb778894b57fc94647">integer_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a880b8edd620319cd355139e36de8cb1b">IntegerArray</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="memdesc:a880b8edd620319cd355139e36de8cb1b inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve array of integer values associated with <a class="el" href="classINMOST_1_1Tag.html" title="This class provides the access to the individual mesh datum and general information about it.">Tag</a>.  <a href="classINMOST_1_1Storage.html#a880b8edd620319cd355139e36de8cb1b">More...</a><br /></td></tr>
<tr class="separator:a880b8edd620319cd355139e36de8cb1b inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632ab6c8fd1cc8177b72b6c1f78e4e01 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top">__INLINE <a class="el" href="classINMOST_1_1Storage.html#a6e49b2a38cb55dd59529bd23e8b1b852">bulk_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a632ab6c8fd1cc8177b72b6c1f78e4e01">BulkArray</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="memdesc:a632ab6c8fd1cc8177b72b6c1f78e4e01 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve abstract data associated with <a class="el" href="classINMOST_1_1Tag.html" title="This class provides the access to the individual mesh datum and general information about it.">Tag</a> as a series of bytes.  <a href="classINMOST_1_1Storage.html#a632ab6c8fd1cc8177b72b6c1f78e4e01">More...</a><br /></td></tr>
<tr class="separator:a632ab6c8fd1cc8177b72b6c1f78e4e01 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b77ea5ae3f7de65ea1e476ab28c2cb inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top">__INLINE <a class="el" href="classINMOST_1_1Storage_1_1reference__array.html">reference_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#ac0b77ea5ae3f7de65ea1e476ab28c2cb">ReferenceArray</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="memdesc:ac0b77ea5ae3f7de65ea1e476ab28c2cb inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve array of <a class="el" href="classINMOST_1_1Element.html">Element</a> references associated with <a class="el" href="classINMOST_1_1Tag.html" title="This class provides the access to the individual mesh datum and general information about it.">Tag</a>.  <a href="classINMOST_1_1Storage.html#ac0b77ea5ae3f7de65ea1e476ab28c2cb">More...</a><br /></td></tr>
<tr class="separator:ac0b77ea5ae3f7de65ea1e476ab28c2cb inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e4b5c2a5618eb2fb49c3d5b58e752c inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top">__INLINE <a class="el" href="classINMOST_1_1Storage_1_1remote__reference__array.html">remote_reference_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a78e4b5c2a5618eb2fb49c3d5b58e752c">RemoteReferenceArray</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="memdesc:a78e4b5c2a5618eb2fb49c3d5b58e752c inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve array of <a class="el" href="classINMOST_1_1Element.html">Element</a> references associated with <a class="el" href="classINMOST_1_1Tag.html" title="This class provides the access to the individual mesh datum and general information about it.">Tag</a>.  <a href="classINMOST_1_1Storage.html#a78e4b5c2a5618eb2fb49c3d5b58e752c">More...</a><br /></td></tr>
<tr class="separator:a78e4b5c2a5618eb2fb49c3d5b58e752c inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8264019b75e64fb657295a1b797d6d3c inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a8264019b75e64fb657295a1b797d6d3c"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#a430e5358d435befb38169beef593527e">real_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RealArrayDF</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:a8264019b75e64fb657295a1b797d6d3c inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ea2c0240dd9a087fe0dfa4f6a14802 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="ae3ea2c0240dd9a087fe0dfa4f6a14802"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#a4d1637367f0487eb778894b57fc94647">integer_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>IntegerArrayDF</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:ae3ea2c0240dd9a087fe0dfa4f6a14802 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54baf555d86177071b9955456f187c38 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a54baf555d86177071b9955456f187c38"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#a6e49b2a38cb55dd59529bd23e8b1b852">bulk_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BulkArrayDF</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:a54baf555d86177071b9955456f187c38 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002ce6286d881d62c16a2e1774056a2a inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a002ce6286d881d62c16a2e1774056a2a"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage_1_1reference__array.html">reference_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ReferenceArrayDF</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:a002ce6286d881d62c16a2e1774056a2a inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3dd7de51f6ffa1d9ba814a363220950 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="af3dd7de51f6ffa1d9ba814a363220950"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage_1_1remote__reference__array.html">remote_reference_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RemoteReferenceArrayDF</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:af3dd7de51f6ffa1d9ba814a363220950 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e638a9a133ce57bea24c4603fc23cb inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a95e638a9a133ce57bea24c4603fc23cb"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>RealDF</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:a95e638a9a133ce57bea24c4603fc23cb inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76944786c948a63a62c8828860a27669 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a76944786c948a63a62c8828860a27669"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>IntegerDF</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:a76944786c948a63a62c8828860a27669 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d581cd014c03069ca33954537696f0c inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a8d581cd014c03069ca33954537696f0c"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>BulkDF</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:a8d581cd014c03069ca33954537696f0c inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4115577e4a00836d19534887d72f5e53 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a4115577e4a00836d19534887d72f5e53"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#a8674802045ec170a3c9d0e3281545b54">reference</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ReferenceDF</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:a4115577e4a00836d19534887d72f5e53 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330ae87164a175104aed67d29e23691e inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a330ae87164a175104aed67d29e23691e"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#a211e235d55d933c5dc3f7040e0b50504">remote_reference</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>RemoteReferenceDF</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:a330ae87164a175104aed67d29e23691e inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4409609f748049677e394fa794028904 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a4409609f748049677e394fa794028904"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#a430e5358d435befb38169beef593527e">real_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RealArrayDV</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:a4409609f748049677e394fa794028904 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace40606e08400eb1993a28de9d764661 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="ace40606e08400eb1993a28de9d764661"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#a4d1637367f0487eb778894b57fc94647">integer_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>IntegerArrayDV</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:ace40606e08400eb1993a28de9d764661 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed894d97273cf9265d4e22b6632fe985 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="aed894d97273cf9265d4e22b6632fe985"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#a6e49b2a38cb55dd59529bd23e8b1b852">bulk_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BulkArrayDV</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:aed894d97273cf9265d4e22b6632fe985 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079ba949219e97c8e48e0a0c4e9ff333 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a079ba949219e97c8e48e0a0c4e9ff333"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage_1_1reference__array.html">reference_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ReferenceArrayDV</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:a079ba949219e97c8e48e0a0c4e9ff333 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f97f822e29e6ab81ace80d40f2d482 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a27f97f822e29e6ab81ace80d40f2d482"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage_1_1remote__reference__array.html">remote_reference_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RemoteReferenceArrayDV</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:a27f97f822e29e6ab81ace80d40f2d482 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42e5fc1ae603649573dfa356e0a4f5a inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="aa42e5fc1ae603649573dfa356e0a4f5a"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>RealDV</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:aa42e5fc1ae603649573dfa356e0a4f5a inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf12ccfe28ab09d280fbb569905d1e06 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="aaf12ccfe28ab09d280fbb569905d1e06"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>IntegerDV</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:aaf12ccfe28ab09d280fbb569905d1e06 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d32aa003195c00113369dc22bab177 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a97d32aa003195c00113369dc22bab177"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>BulkDV</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:a97d32aa003195c00113369dc22bab177 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871d611933429482ca067b819efddcf7 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a871d611933429482ca067b819efddcf7"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#a8674802045ec170a3c9d0e3281545b54">reference</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ReferenceDV</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:a871d611933429482ca067b819efddcf7 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18909c581de94341cf6963c97ea7266 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="ad18909c581de94341cf6963c97ea7266"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#a211e235d55d933c5dc3f7040e0b50504">remote_reference</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>RemoteReferenceDV</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:ad18909c581de94341cf6963c97ea7266 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b1237168340b0a4856ee66ce334653 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a56b1237168340b0a4856ee66ce334653"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#a26add298824745e27a977a633d436c21">var</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a56b1237168340b0a4856ee66ce334653">Variable</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="memdesc:a56b1237168340b0a4856ee66ce334653 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve variable reference associated with <a class="el" href="classINMOST_1_1Tag.html" title="This class provides the access to the individual mesh datum and general information about it.">Tag</a>. <br /></td></tr>
<tr class="separator:a56b1237168340b0a4856ee66ce334653 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ba223f6874188ab6c09b5e287b2d75 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a63ba223f6874188ab6c09b5e287b2d75"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#a26add298824745e27a977a633d436c21">var</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>VariableDF</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:a63ba223f6874188ab6c09b5e287b2d75 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a4e7957172c8cd5140318aa190b518 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a51a4e7957172c8cd5140318aa190b518"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#a26add298824745e27a977a633d436c21">var</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>VariableDV</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:a51a4e7957172c8cd5140318aa190b518 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b688a7ce3347e249a8f3adb875a958 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a37b688a7ce3347e249a8f3adb875a958"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#a7412664cc3faf19cdaf391a97ac46b59">var_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a37b688a7ce3347e249a8f3adb875a958">VariableArray</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="memdesc:a37b688a7ce3347e249a8f3adb875a958 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve array of variables associated with <a class="el" href="classINMOST_1_1Tag.html" title="This class provides the access to the individual mesh datum and general information about it.">Tag</a>. <br /></td></tr>
<tr class="separator:a37b688a7ce3347e249a8f3adb875a958 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9ef13e874627bd5dee06b3fdb1e92d inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a8f9ef13e874627bd5dee06b3fdb1e92d"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#a7412664cc3faf19cdaf391a97ac46b59">var_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>VariableArrayDF</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:a8f9ef13e874627bd5dee06b3fdb1e92d inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01c1ff99bc91b417099dc81bcc4a1fd inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="ab01c1ff99bc91b417099dc81bcc4a1fd"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#a7412664cc3faf19cdaf391a97ac46b59">var_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>VariableArrayDV</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:ab01c1ff99bc91b417099dc81bcc4a1fd inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae060a1c2af74121797f08f52a652ea3b inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top">__INLINE INMOST_DATA_ENUM_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#ae060a1c2af74121797f08f52a652ea3b">GetDataSize</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="memdesc:ae060a1c2af74121797f08f52a652ea3b inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the data length associated with <a class="el" href="classINMOST_1_1Tag.html" title="This class provides the access to the individual mesh datum and general information about it.">Tag</a>.  <a href="classINMOST_1_1Storage.html#ae060a1c2af74121797f08f52a652ea3b">More...</a><br /></td></tr>
<tr class="separator:ae060a1c2af74121797f08f52a652ea3b inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f7bf9539a9f25bf58f0896fa298b86 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top">__INLINE INMOST_DATA_ENUM_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a47f7bf9539a9f25bf58f0896fa298b86">GetDataCapacity</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="memdesc:a47f7bf9539a9f25bf58f0896fa298b86 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the structure required to represent the data on current element.  <a href="classINMOST_1_1Storage.html#a47f7bf9539a9f25bf58f0896fa298b86">More...</a><br /></td></tr>
<tr class="separator:a47f7bf9539a9f25bf58f0896fa298b86 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8a5d59a38cf31dfe528d850f86c42f inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top">__INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#abd8a5d59a38cf31dfe528d850f86c42f">SetDataSize</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, INMOST_DATA_ENUM_TYPE new_size) const</td></tr>
<tr class="memdesc:abd8a5d59a38cf31dfe528d850f86c42f inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the length of data associated with <a class="el" href="classINMOST_1_1Tag.html" title="This class provides the access to the individual mesh datum and general information about it.">Tag</a>.  <a href="classINMOST_1_1Storage.html#abd8a5d59a38cf31dfe528d850f86c42f">More...</a><br /></td></tr>
<tr class="separator:abd8a5d59a38cf31dfe528d850f86c42f inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6a6e21d9bad49b1eb2ee31858898f1 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top">__INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#abd6a6e21d9bad49b1eb2ee31858898f1">GetData</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, INMOST_DATA_ENUM_TYPE shift, INMOST_DATA_ENUM_TYPE size, void *data) const</td></tr>
<tr class="memdesc:abd6a6e21d9bad49b1eb2ee31858898f1 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract part of the data associated with <a class="el" href="classINMOST_1_1Tag.html" title="This class provides the access to the individual mesh datum and general information about it.">Tag</a>.  <a href="classINMOST_1_1Storage.html#abd6a6e21d9bad49b1eb2ee31858898f1">More...</a><br /></td></tr>
<tr class="separator:abd6a6e21d9bad49b1eb2ee31858898f1 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1eef9279de824a6053a7436e354d02e inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="ae1eef9279de824a6053a7436e354d02e"></a>
__INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>SetData</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, INMOST_DATA_ENUM_TYPE shift, INMOST_DATA_ENUM_TYPE size, const void *data) const</td></tr>
<tr class="separator:ae1eef9279de824a6053a7436e354d02e inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5531b1e49ebbe395c166c1951981d5e8 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a5531b1e49ebbe395c166c1951981d5e8"></a>
__INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>DelData</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="separator:a5531b1e49ebbe395c166c1951981d5e8 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95e71b3a69fca424dd64d193987a33e inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="ae95e71b3a69fca424dd64d193987a33e"></a>
__INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#ae95e71b3a69fca424dd64d193987a33e">DelSparseData</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="memdesc:ae95e71b3a69fca424dd64d193987a33e inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates space allocated for sparse data, frees variable array if necessary. <br /></td></tr>
<tr class="separator:ae95e71b3a69fca424dd64d193987a33e inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364d157fd859778ccd94fde546c69152 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a364d157fd859778ccd94fde546c69152"></a>
__INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a364d157fd859778ccd94fde546c69152">DelDenseData</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="memdesc:a364d157fd859778ccd94fde546c69152 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees variable array or fills field with zeroes. <br /></td></tr>
<tr class="separator:a364d157fd859778ccd94fde546c69152 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec013f00d5c7947a1a8542859821c06c inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="aec013f00d5c7947a1a8542859821c06c"></a>
__INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#aec013f00d5c7947a1a8542859821c06c">HaveData</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const</td></tr>
<tr class="memdesc:aec013f00d5c7947a1a8542859821c06c inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if any data is associated with <a class="el" href="classINMOST_1_1Tag.html" title="This class provides the access to the individual mesh datum and general information about it.">Tag</a>. <br /></td></tr>
<tr class="separator:aec013f00d5c7947a1a8542859821c06c inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf18a004a7963990562eef3d9431be0 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="acdf18a004a7963990562eef3d9431be0"></a>
__INLINE ElementType&#160;</td><td class="memItemRight" valign="bottom"><b>GetElementType</b> () const</td></tr>
<tr class="separator:acdf18a004a7963990562eef3d9431be0 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d46873c8ced3b0e45e730d68351d5b6 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a4d46873c8ced3b0e45e730d68351d5b6"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetElementNum</b> () const</td></tr>
<tr class="separator:a4d46873c8ced3b0e45e730d68351d5b6 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a0247ab75e1420c2d1c70facbd7596 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="ab8a0247ab75e1420c2d1c70facbd7596"></a>
__INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>SetMarker</b> (MarkerType n) const</td></tr>
<tr class="separator:ab8a0247ab75e1420c2d1c70facbd7596 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df5606bba14e24707d38d8107f97e8e inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a5df5606bba14e24707d38d8107f97e8e"></a>
__INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetMarker</b> (MarkerType n) const</td></tr>
<tr class="separator:a5df5606bba14e24707d38d8107f97e8e inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e690b691da6bb1e181edb3b0fb148c inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a23e690b691da6bb1e181edb3b0fb148c"></a>
__INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>RemMarker</b> (MarkerType n) const</td></tr>
<tr class="separator:a23e690b691da6bb1e181edb3b0fb148c inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7aaceae2bb30baf9b67cf3cc9df72c4 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="ae7aaceae2bb30baf9b67cf3cc9df72c4"></a>
__INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>SetPrivateMarker</b> (MarkerType n) const</td></tr>
<tr class="separator:ae7aaceae2bb30baf9b67cf3cc9df72c4 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed066a108b1c498a6934254ea35b495 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a9ed066a108b1c498a6934254ea35b495"></a>
__INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetPrivateMarker</b> (MarkerType n) const</td></tr>
<tr class="separator:a9ed066a108b1c498a6934254ea35b495 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501c0c85eb2cebd7e82052c5361ba47c inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a501c0c85eb2cebd7e82052c5361ba47c"></a>
__INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>RemPrivateMarker</b> (MarkerType n) const</td></tr>
<tr class="separator:a501c0c85eb2cebd7e82052c5361ba47c inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa890033328116674bbb7ee5721c20835 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="aa890033328116674bbb7ee5721c20835"></a>
__INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>ClearMarkerSpace</b> () const</td></tr>
<tr class="separator:aa890033328116674bbb7ee5721c20835 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07fea7d83c26a0421c19e20ab841575 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="aa07fea7d83c26a0421c19e20ab841575"></a>
__INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>GetMarkerSpace</b> (<a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a> copy[MarkerFields]) const</td></tr>
<tr class="separator:aa07fea7d83c26a0421c19e20ab841575 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f9a36248b05ca15fcf279d43a69bce inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="af1f9a36248b05ca15fcf279d43a69bce"></a>
__INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>SetMarkerSpace</b> (<a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a> source[MarkerFields]) const</td></tr>
<tr class="separator:af1f9a36248b05ca15fcf279d43a69bce inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5615ae38a02cd5e1a85677eee2bc8565 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a5615ae38a02cd5e1a85677eee2bc8565"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LocalID</b> () const</td></tr>
<tr class="separator:a5615ae38a02cd5e1a85677eee2bc8565 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f246bc5452bcfeff8742ffb2d985d7 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="ae7f246bc5452bcfeff8742ffb2d985d7"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#ae7f246bc5452bcfeff8742ffb2d985d7">DataLocalID</a> () const</td></tr>
<tr class="memdesc:ae7f246bc5452bcfeff8742ffb2d985d7 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">This number is guaranteed to be between 0 and Mesh::NumberOf(type of element) after Mesh::ReorderEmpty. <br /></td></tr>
<tr class="separator:ae7f246bc5452bcfeff8742ffb2d985d7 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3c27e69d1d740c07d697f6617b48c0 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a9b3c27e69d1d740c07d697f6617b48c0"></a>
__INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValid</b> () const</td></tr>
<tr class="separator:a9b3c27e69d1d740c07d697f6617b48c0 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc46083fffb67e518e49fc096a7f571a inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="adc46083fffb67e518e49fc096a7f571a"></a>
__INLINE <a class="el" href="classINMOST_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetMeshLink</b> () const</td></tr>
<tr class="separator:adc46083fffb67e518e49fc096a7f571a inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ed3dcadc1d83f66001ed61405cfa9b inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a48ed3dcadc1d83f66001ed61405cfa9b"></a>
__INLINE HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>GetHandle</b> () const</td></tr>
<tr class="separator:a48ed3dcadc1d83f66001ed61405cfa9b inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5dff8b568ac083696c22bdd75b6c29 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="adf5dff8b568ac083696c22bdd75b6c29"></a>
__INLINE <a class="el" href="classINMOST_1_1Element.html">Element</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getAsElement</b> () const</td></tr>
<tr class="separator:adf5dff8b568ac083696c22bdd75b6c29 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdac03982f3cb2b5d34cd917a8ae1ab inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="adcdac03982f3cb2b5d34cd917a8ae1ab"></a>
__INLINE <a class="el" href="classINMOST_1_1Node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getAsNode</b> () const</td></tr>
<tr class="separator:adcdac03982f3cb2b5d34cd917a8ae1ab inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b1659193fbd6b87dd856ffe558038f inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a14b1659193fbd6b87dd856ffe558038f"></a>
__INLINE <a class="el" href="classINMOST_1_1Edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getAsEdge</b> () const</td></tr>
<tr class="separator:a14b1659193fbd6b87dd856ffe558038f inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4c625209ddc63c658cc70e2de97abc inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a6e4c625209ddc63c658cc70e2de97abc"></a>
__INLINE <a class="el" href="classINMOST_1_1Face.html">Face</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getAsFace</b> () const</td></tr>
<tr class="separator:a6e4c625209ddc63c658cc70e2de97abc inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f16f6c4c2dfa39f25b2dabdbef4a8ae inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a2f16f6c4c2dfa39f25b2dabdbef4a8ae"></a>
__INLINE <a class="el" href="classINMOST_1_1Cell.html">Cell</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getAsCell</b> () const</td></tr>
<tr class="separator:a2f16f6c4c2dfa39f25b2dabdbef4a8ae inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a18519426e3adbdd5b647d6eec1980 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a95a18519426e3adbdd5b647d6eec1980"></a>
__INLINE <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getAsSet</b> () const</td></tr>
<tr class="separator:a95a18519426e3adbdd5b647d6eec1980 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8f9d7e81c502fc9e03c6cfa60452a28d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a8f9d7e81c502fc9e03c6cfa60452a28d">Initialize</a> (int *argc, char ***argv)</td></tr>
<tr class="memdesc:a8f9d7e81c502fc9e03c6cfa60452a28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial initialization.  <a href="classINMOST_1_1Mesh.html#a8f9d7e81c502fc9e03c6cfa60452a28d">More...</a><br /></td></tr>
<tr class="separator:a8f9d7e81c502fc9e03c6cfa60452a28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf6bb86a72902ecc3d3442b059f2b10"><td class="memItemLeft" align="right" valign="top"><a id="aadf6bb86a72902ecc3d3442b059f2b10"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aadf6bb86a72902ecc3d3442b059f2b10">Finalize</a> ()</td></tr>
<tr class="memdesc:aadf6bb86a72902ecc3d3442b059f2b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes operation with MPI, recommended to call, otherwise MPI may produce warnings. <br /></td></tr>
<tr class="separator:aadf6bb86a72902ecc3d3442b059f2b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17e2a78fbfd231e164c9f96fec86556"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ad17e2a78fbfd231e164c9f96fec86556">CopyData</a> (<a class="el" href="classINMOST_1_1Element.html">Element</a> a, <a class="el" href="classINMOST_1_1Element.html">Element</a> b)</td></tr>
<tr class="memdesc:ad17e2a78fbfd231e164c9f96fec86556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all the data from b to a (a = b).  <a href="classINMOST_1_1Mesh.html#ad17e2a78fbfd231e164c9f96fec86556">More...</a><br /></td></tr>
<tr class="separator:ad17e2a78fbfd231e164c9f96fec86556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd58ecd43735511c5d65c41d6fbde35"><td class="memItemLeft" align="right" valign="top"><a id="a9bd58ecd43735511c5d65c41d6fbde35"></a>
static <a class="el" href="classINMOST_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a9bd58ecd43735511c5d65c41d6fbde35">GetMesh</a> (std::string name)</td></tr>
<tr class="memdesc:a9bd58ecd43735511c5d65c41d6fbde35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find mesh by name. <br /></td></tr>
<tr class="separator:a9bd58ecd43735511c5d65c41d6fbde35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af1072d7bb765c6b49c18b3a1fe802920"><td class="memItemLeft" align="right" valign="top"><a id="af1072d7bb765c6b49c18b3a1fe802920"></a>
<a class="el" href="classINMOST_1_1Tag.html">Tag</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tag_sendto</b></td></tr>
<tr class="separator:af1072d7bb765c6b49c18b3a1fe802920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcf95384384d8116d3e0885aa756acd"><td class="memItemLeft" align="right" valign="top"><a id="acfcf95384384d8116d3e0885aa756acd"></a>
<a class="el" href="classINMOST_1_1Tag.html">Tag</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tag_processors</b></td></tr>
<tr class="separator:acfcf95384384d8116d3e0885aa756acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classINMOST_1_1TagManager"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classINMOST_1_1TagManager')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classINMOST_1_1TagManager.html">INMOST::TagManager</a></td></tr>
<tr class="memitem:a6c89e8450f65055147301406d7f9c437 inherit pro_types_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="a6c89e8450f65055147301406d7f9c437"></a>
typedef <a class="el" href="classINMOST_1_1chunk__array.html">chunk_array</a>&lt; INMOST_DATA_ENUM_TYPE, chunk_bits_empty &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>empty_data</b></td></tr>
<tr class="separator:a6c89e8450f65055147301406d7f9c437 inherit pro_types_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7915f5a3e87fe36e14e9766d1437369 inherit pro_types_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="ab7915f5a3e87fe36e14e9766d1437369"></a>
typedef <a class="el" href="classINMOST_1_1chunk__array.html">chunk_array</a>&lt; <a class="el" href="classINMOST_1_1Tag.html">Tag</a>, chunk_bits_tags &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tag_array_type</b></td></tr>
<tr class="separator:ab7915f5a3e87fe36e14e9766d1437369 inherit pro_types_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5a035bf2ee39c0fb8417b0b290a26b inherit pro_types_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="acc5a035bf2ee39c0fb8417b0b290a26b"></a>
typedef <a class="el" href="classINMOST_1_1chunk__bulk__array.html">chunk_bulk_array</a>&lt; chunk_bits_elems &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>dense_sub_type</b></td></tr>
<tr class="separator:acc5a035bf2ee39c0fb8417b0b290a26b inherit pro_types_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab902478524db02c3a078a874830f7e61 inherit pro_types_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="ab902478524db02c3a078a874830f7e61"></a>
typedef <a class="el" href="classINMOST_1_1chunk__array.html">chunk_array</a>&lt; <a class="el" href="classINMOST_1_1chunk__bulk__array.html">dense_sub_type</a>, chunk_bits_dense &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>dense_data_array_type</b></td></tr>
<tr class="separator:ab902478524db02c3a078a874830f7e61 inherit pro_types_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580e8cfe488c581a007d7108a27d5718 inherit pro_types_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="a580e8cfe488c581a007d7108a27d5718"></a>
typedef <a class="el" href="classINMOST_1_1array.html">array</a>&lt; <a class="el" href="structINMOST_1_1TagManager_1_1sparse__sub__record.html">sparse_sub_record</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>sparse_sub_type</b></td></tr>
<tr class="separator:a580e8cfe488c581a007d7108a27d5718 inherit pro_types_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d8c18c51b82ff914061a3a13b16444 inherit pro_types_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="a36d8c18c51b82ff914061a3a13b16444"></a>
typedef <a class="el" href="classINMOST_1_1chunk__array.html">chunk_array</a>&lt; <a class="el" href="classINMOST_1_1array.html">sparse_sub_type</a>, chunk_bits_elems &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>sparse_data_array_type</b></td></tr>
<tr class="separator:a36d8c18c51b82ff914061a3a13b16444 inherit pro_types_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6516013a33fc678ce51ee7a9566ffc9b inherit pro_types_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="a6516013a33fc678ce51ee7a9566ffc9b"></a>
typedef <a class="el" href="classINMOST_1_1chunk__array.html">chunk_array</a>&lt; INMOST_DATA_INTEGER_TYPE, chunk_bits_elems &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>back_links_type</b></td></tr>
<tr class="separator:a6516013a33fc678ce51ee7a9566ffc9b inherit pro_types_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083c5b8cf529631c183d8663e69e6527 inherit pro_types_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="a083c5b8cf529631c183d8663e69e6527"></a>
typedef tag_array_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>tag_iterator</b></td></tr>
<tr class="separator:a083c5b8cf529631c183d8663e69e6527 inherit pro_types_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ab39af175e4d73ca4b9a9a7915401a inherit pro_types_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="a84ab39af175e4d73ca4b9a9a7915401a"></a>
typedef tag_array_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>tag_const_iterator</b></td></tr>
<tr class="separator:a84ab39af175e4d73ca4b9a9a7915401a inherit pro_types_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classINMOST_1_1TagManager"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classINMOST_1_1TagManager')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classINMOST_1_1TagManager.html">INMOST::TagManager</a></td></tr>
<tr class="memitem:a74c7e50f03649a1b5041f524d0421079 inherit pro_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="a74c7e50f03649a1b5041f524d0421079"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TagManager</b> (const <a class="el" href="classINMOST_1_1TagManager.html">TagManager</a> &amp;other)</td></tr>
<tr class="separator:a74c7e50f03649a1b5041f524d0421079 inherit pro_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab128149e17df47b9ebfdb8c4997a46c4 inherit pro_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="ab128149e17df47b9ebfdb8c4997a46c4"></a>
<a class="el" href="classINMOST_1_1TagManager.html">TagManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classINMOST_1_1TagManager.html">TagManager</a> const &amp;other)</td></tr>
<tr class="separator:ab128149e17df47b9ebfdb8c4997a46c4 inherit pro_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a6f61fd31686e47ddda096cd5a458b inherit pro_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="a60a6f61fd31686e47ddda096cd5a458b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1TagManager.html#a60a6f61fd31686e47ddda096cd5a458b">ReallocateData</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;t, INMOST_DATA_INTEGER_TYPE etypenum, INMOST_DATA_ENUM_TYPE new_size)</td></tr>
<tr class="memdesc:a60a6f61fd31686e47ddda096cd5a458b inherit pro_methods_classINMOST_1_1TagManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrink or enlarge arrays for a dense data. <br /></td></tr>
<tr class="separator:a60a6f61fd31686e47ddda096cd5a458b inherit pro_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397a04c1c4545b1152a438acc432f952 inherit pro_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="a397a04c1c4545b1152a438acc432f952"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1TagManager.html#a397a04c1c4545b1152a438acc432f952">ReallocateData</a> (INMOST_DATA_INTEGER_TYPE etypenum, INMOST_DATA_ENUM_TYPE new_size)</td></tr>
<tr class="memdesc:a397a04c1c4545b1152a438acc432f952 inherit pro_methods_classINMOST_1_1TagManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate all the data for all the tags. <br /></td></tr>
<tr class="separator:a397a04c1c4545b1152a438acc432f952 inherit pro_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4251b73c8dee9e45e0bacc4e245bc89f inherit pro_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="a4251b73c8dee9e45e0bacc4e245bc89f"></a>
__INLINE <a class="el" href="classINMOST_1_1array.html">sparse_sub_type</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1TagManager.html#a4251b73c8dee9e45e0bacc4e245bc89f">GetSparseData</a> (int etypenum, int local_id) const</td></tr>
<tr class="memdesc:a4251b73c8dee9e45e0bacc4e245bc89f inherit pro_methods_classINMOST_1_1TagManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve substructure for representation of the sparse data without permission for modification. <br /></td></tr>
<tr class="separator:a4251b73c8dee9e45e0bacc4e245bc89f inherit pro_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95230b841496e62ea1a645b3d1336ce inherit pro_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="ab95230b841496e62ea1a645b3d1336ce"></a>
__INLINE <a class="el" href="classINMOST_1_1array.html">sparse_sub_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1TagManager.html#ab95230b841496e62ea1a645b3d1336ce">GetSparseData</a> (int etypenum, int local_id)</td></tr>
<tr class="memdesc:ab95230b841496e62ea1a645b3d1336ce inherit pro_methods_classINMOST_1_1TagManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve substructure for representation of the sparse data. <br /></td></tr>
<tr class="separator:ab95230b841496e62ea1a645b3d1336ce inherit pro_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad177601bd7da9094add24a958e64ce72 inherit pro_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="ad177601bd7da9094add24a958e64ce72"></a>
__INLINE <a class="el" href="classINMOST_1_1chunk__bulk__array.html">dense_sub_type</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1TagManager.html#ad177601bd7da9094add24a958e64ce72">GetDenseData</a> (int pos) const</td></tr>
<tr class="memdesc:ad177601bd7da9094add24a958e64ce72 inherit pro_methods_classINMOST_1_1TagManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve substructure for representation of the dense data without permission for modification. <br /></td></tr>
<tr class="separator:ad177601bd7da9094add24a958e64ce72 inherit pro_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98cc766513cd82c1f0a99c78c5b8528 inherit pro_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="af98cc766513cd82c1f0a99c78c5b8528"></a>
__INLINE <a class="el" href="classINMOST_1_1chunk__bulk__array.html">dense_sub_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1TagManager.html#af98cc766513cd82c1f0a99c78c5b8528">GetDenseData</a> (int pos)</td></tr>
<tr class="memdesc:af98cc766513cd82c1f0a99c78c5b8528 inherit pro_methods_classINMOST_1_1TagManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve substructure for representation of the dense data. <br /></td></tr>
<tr class="separator:af98cc766513cd82c1f0a99c78c5b8528 inherit pro_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classINMOST_1_1TagManager"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classINMOST_1_1TagManager')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classINMOST_1_1TagManager.html">INMOST::TagManager</a></td></tr>
<tr class="memitem:a3646206503d7c8bc5a7d1ab2f2550798 inherit pro_static_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="a3646206503d7c8bc5a7d1ab2f2550798"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1TagManager.html#a3646206503d7c8bc5a7d1ab2f2550798">CopyData</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;t, void *adata, const void *bdata)</td></tr>
<tr class="memdesc:a3646206503d7c8bc5a7d1ab2f2550798 inherit pro_static_methods_classINMOST_1_1TagManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from one element to another. <br /></td></tr>
<tr class="separator:a3646206503d7c8bc5a7d1ab2f2550798 inherit pro_static_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41305bccd3e4be8bfd5ff0b8246c807 inherit pro_static_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="aa41305bccd3e4be8bfd5ff0b8246c807"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1TagManager.html#aa41305bccd3e4be8bfd5ff0b8246c807">DestroyVariableData</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;t, void *adata)</td></tr>
<tr class="memdesc:aa41305bccd3e4be8bfd5ff0b8246c807 inherit pro_static_methods_classINMOST_1_1TagManager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy data that represents array of variable size. <br /></td></tr>
<tr class="separator:aa41305bccd3e4be8bfd5ff0b8246c807 inherit pro_static_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classINMOST_1_1TagManager"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classINMOST_1_1TagManager')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classINMOST_1_1TagManager.html">INMOST::TagManager</a></td></tr>
<tr class="memitem:ac92171533d42711a11684c52f6dfa737 inherit pro_attribs_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="ac92171533d42711a11684c52f6dfa737"></a>
<a class="el" href="classINMOST_1_1chunk__array.html">tag_array_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tags</b></td></tr>
<tr class="separator:ac92171533d42711a11684c52f6dfa737 inherit pro_attribs_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f6cb319ebef941d38a8e2c8f17db94 inherit pro_attribs_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="ac6f6cb319ebef941d38a8e2c8f17db94"></a>
<a class="el" href="classINMOST_1_1chunk__array.html">empty_data</a>&#160;</td><td class="memItemRight" valign="bottom"><b>empty_dense_data</b></td></tr>
<tr class="separator:ac6f6cb319ebef941d38a8e2c8f17db94 inherit pro_attribs_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf73c1edda087f369ef969b64e6d9a1 inherit pro_attribs_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="abaf73c1edda087f369ef969b64e6d9a1"></a>
<a class="el" href="classINMOST_1_1chunk__array.html">dense_data_array_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dense_data</b></td></tr>
<tr class="separator:abaf73c1edda087f369ef969b64e6d9a1 inherit pro_attribs_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493f6fc832feac0acf6f3385e512e6d2 inherit pro_attribs_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="a493f6fc832feac0acf6f3385e512e6d2"></a>
<a class="el" href="classINMOST_1_1chunk__array.html">sparse_data_array_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sparse_data</b> [NUM_ELEMENT_TYPS]</td></tr>
<tr class="separator:a493f6fc832feac0acf6f3385e512e6d2 inherit pro_attribs_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413cc0a0b344c37ba283207eb8264f46 inherit pro_attribs_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a id="a413cc0a0b344c37ba283207eb8264f46"></a>
<a class="el" href="classINMOST_1_1chunk__array.html">back_links_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>back_links</b> [NUM_ELEMENT_TYPS]</td></tr>
<tr class="separator:a413cc0a0b344c37ba283207eb8264f46 inherit pro_attribs_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classINMOST_1_1Storage"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classINMOST_1_1Storage')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classINMOST_1_1Storage.html">INMOST::Storage</a></td></tr>
<tr class="memitem:a3a9a0f8e226821c92b8e5c253e4474be inherit pro_attribs_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a3a9a0f8e226821c92b8e5c253e4474be"></a>
HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>handle</b></td></tr>
<tr class="separator:a3a9a0f8e226821c92b8e5c253e4474be inherit pro_attribs_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f2ee75267f3c967db30b79558360a5 inherit pro_attribs_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a id="a14f2ee75267f3c967db30b79558360a5"></a>
HandleType *&#160;</td><td class="memItemRight" valign="bottom"><b>handle_link</b></td></tr>
<tr class="separator:a14f2ee75267f3c967db30b79558360a5 inherit pro_attribs_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1f53070855f3503b2f4cefc16cedd6a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f53070855f3503b2f4cefc16cedd6a0">&#9670;&nbsp;</a></span>ApplyModification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ApplyModification </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>After this function any link to deleted element will be replaced by InvalidHandle(). </p>
<p>This will modify DATA_REFERENCE tags and contents of sets, so that all deleted elements are not referenced anymore. If you have any tags of type DATA_REMOTE_REFERENCE on current mesh linking to the elements of the current mesh or there are other meshes that possess tags of type DATA_REMOTE_REFERENCE and link elements on the current mesh, you should check that there are no links to deleted elements manually with Element::Old(). </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000038">Todo:</a></b></dt><dd><ol type="1">
<li>maybe instead of forming set of deleted elements and subtracting set from other sets it is better to remove each modified element (done, check and compare)</li>
<li>parent/child elements in set would not be replaced or reconnected, this may lead to wrong behavior (done, check and compare) </li>
</ol>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Element::Old </dd></dl>

</div>
</div>
<a id="ae39e30b11f35de81d2a9b8451ef87391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39e30b11f35de81d2a9b8451ef87391">&#9670;&nbsp;</a></span>AssignGlobalID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::AssignGlobalID </td>
          <td>(</td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign unique numbers to elements. </p>
<p>Internally this will create Mesh::GlobalIDTag and make call to Element::GlobalID and <a class="el" href="classINMOST_1_1Mesh.html#ab9f84a185381a0096fc358e7e2ff5db7" title="Retrieve global id of the element with right of modification (dangerous to modify).">Mesh::GlobalID</a> functions valid. Internally this will also set have_global_id variable that will indicate that all the comparisons in parallel algorithms should be performed using global identificators instead of centroids which is faster.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000031">Todo:</a></b></dt><dd><ol type="1">
<li>invoking function before loading mesh will not renew global identificators after load but would not unset have_global_id either. There are probably too many places when global ids may become invalid but no flag will be set. It may be benefitial to set such flags along with updating geometrical data which seems to be maintained fairly well during mesh modification </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a2922f80c6c522500a887fe115cf5271d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2922f80c6c522500a887fe115cf5271d">&#9670;&nbsp;</a></span>BeginTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE iteratorTag INMOST::Mesh::BeginTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first tag defined on the mesh. </p>
<p>For safety while iterating through tags you should check for validity of the tag </p><dl class="section return"><dt>Returns</dt><dd>first tag </dd></dl>

</div>
</div>
<a id="a55549e9d46cd92e2f3122e1516f3c9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55549e9d46cd92e2f3122e1516f3c9fd">&#9670;&nbsp;</a></span>BeginTopologyCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TopologyCheck INMOST::Mesh::BeginTopologyCheck </td>
          <td>(</td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>etype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HandleType *&#160;</td>
          <td class="paramname"><em>adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allows you to perform some topological checks before you create an element. </p>
<p>Function is used internally by CreateEdge, CreateFace, CreateCell functions If you perform topological checks on your own, you'd probably better turn off checks before calling CreateXXX functions. Note that check for duplicates within mesh is performed by <a class="el" href="classINMOST_1_1Mesh.html#a97fd4e8639eaee4461608e33d6d10dbe" title="Retrieve upper adjacent that is shared by multiple lower adjacencies.">Mesh::FindSharedAdjacency</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000039">Todo:</a></b></dt><dd>list checks performed inside in description </dd></dl>

</div>
</div>
<a id="a9df5a8793e5cd8e38182de107d381d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df5a8793e5cd8e38182de107d381d9e">&#9670;&nbsp;</a></span>Bulk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a>&amp; INMOST::Mesh::Bulk </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference in inner representation to the first element of array of bytes. </p>
<p>Future recommendation: If variable size array was not allocated then this function will generate segmentation fault.</p>
<p>If you know that data is certanly dense and fixed or variable on elements you access then it is faster to use specialized variants of this function.</p>
<p>Reference to the data is guaranteed to be valid during mesh modification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae496bab413c4a6103ee62ae3903e95fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae496bab413c4a6103ee62ae3903e95fe">&#9670;&nbsp;</a></span>BulkArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a6e49b2a38cb55dd59529bd23e8b1b852">bulk_array</a> INMOST::Mesh::BulkArray </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array of bytes. </p>
<p>If you know that data is certanly sparse or dense on elements you access then it is faster to use variants of this function with hint data structure.</p>
<p>Array data structure is guaranteed to be valid during mesh modification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53d63f6a251db48695306180f22ff67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d63f6a251db48695306180f22ff67e">&#9670;&nbsp;</a></span>BulkArrayDF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a6e49b2a38cb55dd59529bd23e8b1b852">bulk_array</a> INMOST::Mesh::BulkArrayDF </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of bytes in dense array. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and fixed is incorrect, no checks performed in release mode (NDEBUG is set), likely to result in segfault.</p>
<p>Note that as array is fixed you shouldn't use any functions that alter size of the array as resize, erase, insert, you may use replace if initial and final size will match, in debug mode assert will fire if you try to do this in release (NDEBUG is set) it will lead to segfault.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents dense data of fixed size on given handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a042974abc70e48b9dc84714ca1a50655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042974abc70e48b9dc84714ca1a50655">&#9670;&nbsp;</a></span>BulkArrayDV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a6e49b2a38cb55dd59529bd23e8b1b852">bulk_array</a> INMOST::Mesh::BulkArrayDV </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of bytes in dense array of variable size. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and variable is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88229181252531147051badf5a05e263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88229181252531147051badf5a05e263">&#9670;&nbsp;</a></span>BulkDF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a>&amp; INMOST::Mesh::BulkDF </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference in dense array to the first element of constant size array of bytes. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and fixed is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents dense data of fixed size on given handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35a62a1c63ac51297dddabb1312f32d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a62a1c63ac51297dddabb1312f32d1">&#9670;&nbsp;</a></span>BulkDV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a>&amp; INMOST::Mesh::BulkDV </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference in dense array to the first element of variable size array of bytes. </p>
<p>Future recommendation: If array was not allocated then this function will generate segmentation fault.</p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and variable is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>TagDenseVariable </dd></dl>

</div>
</div>
<a id="ab15464edb409ccaacc512fea774aaa7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15464edb409ccaacc512fea774aaa7d">&#9670;&nbsp;</a></span>CheckCentroids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::CheckCentroids </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that centroids of ghost and shared elements match to each other. </p>
<p>Exits if does not match. </p>

</div>
</div>
<a id="a64bd4434c332d01378ab77fe67c45767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bd4434c332d01378ab77fe67c45767">&#9670;&nbsp;</a></span>CheckGhostSharedCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::CheckGhostSharedCount </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>etype</em> = <code>ESET|CELL|FACE|EDGE|NODE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that number of ghost and shared elements match to each other. </p>
<p>Exits if does not match. </p>

</div>
</div>
<a id="a887f25126d7a0fc38e238e5c2b033d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887f25126d7a0fc38e238e5c2b033d58">&#9670;&nbsp;</a></span>ComputeGeometricType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ComputeGeometricType </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recompute geometrical type of current element and set it to element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad17e2a78fbfd231e164c9f96fec86556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17e2a78fbfd231e164c9f96fec86556">&#9670;&nbsp;</a></span>CopyData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void INMOST::Mesh::CopyData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Element.html">Element</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Element.html">Element</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy all the data from b to a (a = b). </p>
<p>Except for protected data. Non-private markers are copied. Elements should be of the same type. </p>

</div>
</div>
<a id="a3d860dda768f1d8b7a1b5cd2066cb504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d860dda768f1d8b7a1b5cd2066cb504">&#9670;&nbsp;</a></span>CreateMarker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MarkerType INMOST::Mesh::CreateMarker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new marker. </p>
<p>Assert will fire in debug mode (NDEBUG not set) if you run out of space for markers, in this case you either use too many markers, then you can just increase MarkerFields variable (increasing by 1 gives you 8 more markers) or you forget to release markers after you use them.</p>
<p>In release mode (NDEBUG is set) if you run out of space for markers function will return InvalidMarker() </p><dl class="section return"><dt>Returns</dt><dd>New marker or InvalidMarker(), see description. </dd></dl>

</div>
</div>
<a id="a2edad518a07d8d9cfadf7803553a4991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2edad518a07d8d9cfadf7803553a4991">&#9670;&nbsp;</a></span>CreateNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Node.html">Node</a> INMOST::Mesh::CreateNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> *&#160;</td>
          <td class="paramname"><em>coords</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create node by given coordinates. </p>
<p>This operation would not involve searching existing nodes for node with the same coordinates. It is potentially dangerous to have nodes whose coordinates differ by less than GetEpsilon since ResolveShared algorithm would not know how to resolve parallel statuses of the elements. However this may be subject to change, if ResolveShared algorithm will be rewritten to resolve cells first by their centroids and only then resolve all the rest elements by adjacency information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>array of coordinates at least of size <a class="el" href="classINMOST_1_1Mesh.html#a7273bdff94d190cb7864059b2b02ef31" title="Get number of dimensions of mesh.">GetDimensions()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interface to created node </dd></dl>

</div>
</div>
<a id="a02d7bfbdaa069199d3f8b3c3e9e7f151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d7bfbdaa069199d3f8b3c3e9e7f151">&#9670;&nbsp;</a></span>CreateTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Tag.html">Tag</a> INMOST::Mesh::CreateTag </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataType&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>etype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>sparse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INMOST_DATA_ENUM_TYPE&#160;</td>
          <td class="paramname"><em>size</em> = <code>ENUMUNDEF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the tag by name, type and size. </p>
<p>You cannot create the tag with the same name and different type or size.</p>
<p>You may make subsequent calls to the function with the same name, same type and same size (or undefined size, then it will be deduced) but different selection of element.</p>
<p>The following recommendation is for future: When you create data of variable size, every array of data for every element will be empty at first, so before accessing it through mechanism for single-valued data (Real, Integer, Bulk, Reference) you should first resize arrays otherwise your program very likely to be halted by segmentation fault. For this case arrays are not allocated automatically from performance considerations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the tag </td></tr>
    <tr><td class="paramname">dtype</td><td>type of the tag </td></tr>
    <tr><td class="paramname">etype</td><td>the selection of elements on which the data of the tag is defined, you may use bitwise or operations to define tag on multiple types of elements, example CELL | FACE </td></tr>
    <tr><td class="paramname">sparse</td><td>the selection of elements from etype on which the tag is sparse, for example, if you know that the data is used on all cells and only on boundary faces, then you may should set etype = CELL | FACE and sparse = FACE </td></tr>
    <tr><td class="paramname">size</td><td>size of associated data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the tag that represents the data </dd></dl>

</div>
</div>
<a id="a17cea6fbb28e02e8068289475f5d0b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17cea6fbb28e02e8068289475f5d0b99">&#9670;&nbsp;</a></span>DataLocalID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> INMOST::Mesh::DataLocalID </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve position of the data position of current element. </p>
<p>After ReorderEmpty this number is guaranteed to be between 0 and NumberOf(type of element) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>local id of data </dd></dl>

</div>
</div>
<a id="afab20c754eef0006e3085dc546e893bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab20c754eef0006e3085dc546e893bb">&#9670;&nbsp;</a></span>DelData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::DelData </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove tag data from given element. </p>
<p>Removes data of variable size and sparse tag data. Clears to zero data of fixed size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle to the element </td></tr>
    <tr><td class="paramname">tag</td><td>tag that indicates the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abac72292a681f80f9f112566e3c04bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac72292a681f80f9f112566e3c04bc5">&#9670;&nbsp;</a></span>DelDenseData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::DelDenseData </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes data of variable size, clears to zero data of fixed size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle to the element </td></tr>
    <tr><td class="paramname">tag</td><td>tag that indicates the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cc7b729335ae0490f855bf560ad8553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc7b729335ae0490f855bf560ad8553">&#9670;&nbsp;</a></span>DelDenseData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::DelDenseData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes data of variable size, clears to zero data of fixed size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>link to data </td></tr>
    <tr><td class="paramname">tag</td><td>tag that indicates the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a569c516120df121980d0585deadd3634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569c516120df121980d0585deadd3634">&#9670;&nbsp;</a></span>Delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool INMOST::Mesh::Delete </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will hide element in modification state (between BeginModification and EndModification) or call Destroy in non-modification state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if true then element was deleted, otherwise it was hidden </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a2b3eaaadcd233cf11deba24d1fd64ad1" title="Hide element from mesh.">Mesh::Hide</a> </dd>
<dd>
Mesh::BeginModification </dd>
<dd>
Mesh::EndModification </dd>
<dd>
<a class="el" href="classINMOST_1_1Mesh.html#a0e2c090ee95e802c4f486a5d98fc6cb0" title="Completely destroy element from mesh.">Mesh::Destroy</a> </dd></dl>

</div>
</div>
<a id="ae43e132d6fd14903e263f00fbcffec51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43e132d6fd14903e263f00fbcffec51">&#9670;&nbsp;</a></span>DeleteTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Tag.html">Tag</a> INMOST::Mesh::DeleteTag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Tag.html">Tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em> = <code>NODE|EDGE|FACE|CELL|ESET|MESH</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the data that is represented by the tag from elements of selected type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag that indicates the data </td></tr>
    <tr><td class="paramname">mask</td><td>the selection of the elements on which the data should be removed, may be set by bitwise or operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns tag that returns false on isValid() request if all the data was removed and the tag is no more occupied, otherwise returns the tag </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Tag::isValid </dd></dl>

<p>Reimplemented from <a class="el" href="classINMOST_1_1TagManager.html#aff704532d5a261a3e6572c84f54d14c8">INMOST::TagManager</a>.</p>

</div>
</div>
<a id="a4e1a1d2343274836b3a74e615e057b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1a1d2343274836b3a74e615e057b9b">&#9670;&nbsp;</a></span>DelSparseData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool INMOST::Mesh::DelSparseData </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes data of variable size and sparse tag data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle to the element </td></tr>
    <tr><td class="paramname">tag</td><td>tag that indicates the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e2c090ee95e802c4f486a5d98fc6cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2c090ee95e802c4f486a5d98fc6cb0">&#9670;&nbsp;</a></span>Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::Destroy </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Completely destroy element from mesh. </p>
<p>This function bypass check that mesh is in modification state and will remove element immediatly. It will disconnect element from lower adjacencies and delete all the upper adjacencies that depend on current element. If you don't want upper adjacencies to be deleted you should first use Element::Disconnect function to explicitly disconnect current element and then destroy it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Element::Disconnect </dd></dl>

</div>
</div>
<a id="ae69466c97ab50182ba143df2a76d5d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69466c97ab50182ba143df2a76d5d9f">&#9670;&nbsp;</a></span>EndTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE iteratorTag INMOST::Mesh::EndTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the indicator for loop to end iteration over tags. </p>
<dl class="section return"><dt>Returns</dt><dd>the inexistent tag that is located the one position after the last tag </dd></dl>

</div>
</div>
<a id="a97177e1b6f8fe810eb5d072fb378b22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97177e1b6f8fe810eb5d072fb378b22e">&#9670;&nbsp;</a></span>EndTopologyCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool INMOST::Mesh::EndTopologyCheck </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TopologyCheck&#160;</td>
          <td class="paramname"><em>begin_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs some topological checks after construction of element. </p>
<p>Function is used internally by CreateEdge, CreateFace, CreateCell functions.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000040">Todo:</a></b></dt><dd>list checks performed inside in description. </dd></dl>

</div>
</div>
<a id="a92e7888589b79355fa273ad67c8c9bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e7888589b79355fa273ad67c8c9bb5">&#9670;&nbsp;</a></span>Enumerate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> INMOST::Mesh::Enumerate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; EType &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>num_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>define_sparse</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerate all elements beginning with start and put numeration to data associated with num_tag. </p>
<p>Collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elements</td><td>array of elements </td></tr>
    <tr><td class="paramname">num_tag</td><td>a tag that is associated with the data </td></tr>
    <tr><td class="paramname">start</td><td>starting value for enumeration </td></tr>
    <tr><td class="paramname">define_sparse</td><td>if true then function will define sparse data on elements that don't have it, otherwise it will skip those elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last value on all the processors </dd></dl>

</div>
</div>
<a id="a5dc8c51bea6707ccedc76dba47ea0d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc8c51bea6707ccedc76dba47ea0d48">&#9670;&nbsp;</a></span>Enumerate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> INMOST::Mesh::Enumerate </td>
          <td>(</td>
          <td class="paramtype">const HandleType *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>num_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>define_sparse</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate all elements beginning with start and put numeration to data associated with num_tag. </p>
<p>Collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>array of handles </td></tr>
    <tr><td class="paramname">num</td><td>number of handles </td></tr>
    <tr><td class="paramname">num_tag</td><td>a tag that is associated with the data </td></tr>
    <tr><td class="paramname">start</td><td>starting value for enumeration </td></tr>
    <tr><td class="paramname">define_sparse</td><td>if true then function will define sparse data on elements that don't have it, otherwise it will skip those elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last value on all the processors </dd></dl>

</div>
</div>
<a id="a9787ba8c75b41b76b89aeeae2e8aefad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9787ba8c75b41b76b89aeeae2e8aefad">&#9670;&nbsp;</a></span>Enumerate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> INMOST::Mesh::Enumerate </td>
          <td>(</td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Tag.html">Tag</a>&#160;</td>
          <td class="paramname"><em>num_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>define_sparse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate all elements beginning with start and put numeration to data associated with num_tag for all elements with given type mask. </p>
<p>Collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>bitwise or of types of elements </td></tr>
    <tr><td class="paramname">num_tag</td><td>a tag that is associated with the data </td></tr>
    <tr><td class="paramname">start</td><td>starting value for enumeration </td></tr>
    <tr><td class="paramname">define_sparse</td><td>if true then function will define sparse data on elements that don't have it, otherwise it will skip those elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last value on all the processors </dd></dl>

</div>
</div>
<a id="a0239ff055f17c76ba19ef8a169b14962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0239ff055f17c76ba19ef8a169b14962">&#9670;&nbsp;</a></span>EnumerateSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> INMOST::Mesh::EnumerateSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>num_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>define_sparse</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate all elements in the set. </p>
<p>Collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>handle of the set </td></tr>
    <tr><td class="paramname">num_tag</td><td>a tag that is associated with the data </td></tr>
    <tr><td class="paramname">start</td><td>starting value for enumeration </td></tr>
    <tr><td class="paramname">define_sparse</td><td>if true then function will define sparse data on elements that don't have it, otherwise it will skip those elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last value on all the processors </dd></dl>

</div>
</div>
<a id="a0f3d0cb9965d12635cc2df7ad458661a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3d0cb9965d12635cc2df7ad458661a">&#9670;&nbsp;</a></span>ExchangeData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ExchangeData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update data from Shared elements to Ghost elements. </p>
<p>For backward direction please see <a class="el" href="classINMOST_1_1Mesh.html#a2d488479041917c975b1e662d642c4a5" title="Accumulation of data from ghost elements to shared elements.">Mesh::ReduceData</a>. If you have a tag of DATA_BULK type and you store your own custom data structure in it, it is highly recommended that you provide MPI information about your structure through Tag::SetBulkDataType, this would not do any difference on homogeneous architecture, but it may help you save a lot of time and nerves in heterogeneous parallel environment.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000032">Todo:</a></b></dt><dd>see TODO in <a class="el" href="classINMOST_1_1Mesh.html#a2d488479041917c975b1e662d642c4a5" title="Accumulation of data from ghost elements to shared elements.">Mesh::ReduceData</a></dd></dl>
<p>Blocking, Collective point-2-point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a2d488479041917c975b1e662d642c4a5" title="Accumulation of data from ghost elements to shared elements.">Mesh::ReduceData</a> </dd></dl>

</div>
</div>
<a id="a48dd6dfc566d9dbdde5c1c9f819b4fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48dd6dfc566d9dbdde5c1c9f819b4fdd">&#9670;&nbsp;</a></span>ExchangeData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ExchangeData </td>
          <td>(</td>
          <td class="paramtype">const tag_set &amp;&#160;</td>
          <td class="paramname"><em>tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will perform exchange of multiple data tags. </p>
<p>Blocking, Collective point-2-point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tags</td><td>multiple tags that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35ca81c3d8a01aa6a9ce983769fa03cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ca81c3d8a01aa6a9ce983769fa03cd">&#9670;&nbsp;</a></span>ExchangeDataBegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ExchangeDataBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start asynchronous synchronization of data. </p>
<p>You should define object of type <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> that will hold temporary buffers for data. every <a class="el" href="classINMOST_1_1Mesh.html#a35ca81c3d8a01aa6a9ce983769fa03cd" title="Start asynchronous synchronization of data.">Mesh::ExchangeDataBegin</a> should be matched with <a class="el" href="classINMOST_1_1Mesh.html#a443828dada7d0fe8ebcf8040593e1ac1" title="Complete asynchronous synchronization of data.">Mesh::ExchangeDataEnd</a> with the same <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> object. After matching <a class="el" href="classINMOST_1_1Mesh.html#a443828dada7d0fe8ebcf8040593e1ac1" title="Complete asynchronous synchronization of data.">Mesh::ExchangeDataEnd</a> the <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> object may be reused If you will go out of the scope where <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> object was defined it will be deallocated and may result in segmentation fault.</p>
<p>You should also never put the same <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> object to any other <a class="el" href="classINMOST_1_1Mesh.html#a35ca81c3d8a01aa6a9ce983769fa03cd" title="Start asynchronous synchronization of data.">Mesh::ExchangeDataBegin</a> or <a class="el" href="classINMOST_1_1Mesh.html#a0597bf77b8438dc79bf791912a2b34d2" title="This function intializes data reduction.">Mesh::ReduceDataBegin</a>, until matching <a class="el" href="classINMOST_1_1Mesh.html#a443828dada7d0fe8ebcf8040593e1ac1" title="Complete asynchronous synchronization of data.">Mesh::ExchangeDataEnd</a> because it may override or reallocate buffers, internally used by MPI and remote processor will receive garbage instead of data.</p>
<p>Nonblocking, Collective point-2-point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
    <tr><td class="paramname">storage</td><td>buffer that will temporary hold sended data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a443828dada7d0fe8ebcf8040593e1ac1" title="Complete asynchronous synchronization of data.">Mesh::ExchangeDataEnd</a> </dd></dl>

</div>
</div>
<a id="a418d72493b24344d247b811bd980b3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418d72493b24344d247b811bd980b3a9">&#9670;&nbsp;</a></span>ExchangeDataBegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ExchangeDataBegin </td>
          <td>(</td>
          <td class="paramtype">const tag_set &amp;&#160;</td>
          <td class="paramname"><em>tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will initialize exchange of multiple data tags. </p>
<p>Using this function may lead to good overlapping between communication and computation.</p>
<p>Nonblocking, Collective point-2-point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tags</td><td>multiple tags that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
    <tr><td class="paramname">storage</td><td>buffer that will temporary hold sended data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a443828dada7d0fe8ebcf8040593e1ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443828dada7d0fe8ebcf8040593e1ac1">&#9670;&nbsp;</a></span>ExchangeDataEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ExchangeDataEnd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete asynchronous synchronization of data. </p>
<p>Blocking</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
    <tr><td class="paramname">storage</td><td>buffer that will temporary hold sended data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a35ca81c3d8a01aa6a9ce983769fa03cd" title="Start asynchronous synchronization of data.">Mesh::ExchangeDataBegin</a> </dd></dl>

</div>
</div>
<a id="aa49bac8c58e4e610eb4c7ec7dd9f4b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49bac8c58e4e610eb4c7ec7dd9f4b96">&#9670;&nbsp;</a></span>ExchangeDataEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ExchangeDataEnd </td>
          <td>(</td>
          <td class="paramtype">const tag_set &amp;&#160;</td>
          <td class="paramname"><em>tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will finalize exchange of multiple data tags. </p>
<p>Blocking</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tags</td><td>multiple tags that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
    <tr><td class="paramname">storage</td><td>buffer that will temporary hold sended data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e8cabff3db1f7af1b426f8e2f582752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8cabff3db1f7af1b426f8e2f582752">&#9670;&nbsp;</a></span>ExchangeGhost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ExchangeGhost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td>
          <td class="paramname"><em>layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>bridge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delete_ghost</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Form several layers of ghost cells that are adjacent through bridge elements to current cells. </p>
<p>This function acceptes any mesh topology, failure on some mesh should be considered a bug and sample example should be provided for testing purposes.</p>
<p>This function internally calculates layer by layer and invokes ExchangeMarked for each layer, you can either reproduce the algorithm on your own if you want to bypass the function and call <a class="el" href="classINMOST_1_1Mesh.html#ae44b9cfcb8964acbd710562df331a51a" title="This function realizes two algorithms: ghosting of elements and migration of elements.">Mesh::ExchangeMarked</a> directly, but then you will lose optimization in <a class="el" href="classINMOST_1_1Mesh.html#ade20ec7c8563e82bf8057bc47a3314b7" title="Migrate all the elements to the new owners prescribed in data corresponding to RedistributeTag.">Mesh::Redistribute</a>, that expects that layers are formed the same way they are formed in <a class="el" href="classINMOST_1_1Mesh.html#a9e8cabff3db1f7af1b426f8e2f582752" title="Form several layers of ghost cells that are adjacent through bridge elements to current cells.">Mesh::ExchangeGhost</a>. Internally it sets up LayersTag and BridgeTag for the mesh with provided values, which are used by <a class="el" href="classINMOST_1_1Mesh.html#ade20ec7c8563e82bf8057bc47a3314b7" title="Migrate all the elements to the new owners prescribed in data corresponding to RedistributeTag.">Mesh::Redistribute</a> but you are discouraged to override these tags since using non-matching algorithms is not tested and should be considered dangerous.</p>
<p>Nevertheless you can use this function first for layers then request any additional ghost elements by ExchangeMarked.</p>
<p>Collective point-2-point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layers</td><td>number of required layers of ghost elements </td></tr>
    <tr><td class="paramname">bridge</td><td>bitwise mask of elements for which neighbouring cells should be considered a layer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#ae44b9cfcb8964acbd710562df331a51a" title="This function realizes two algorithms: ghosting of elements and migration of elements.">Mesh::ExchangeMarked</a> </dd>
<dd>
<a class="el" href="classINMOST_1_1Mesh.html#ade20ec7c8563e82bf8057bc47a3314b7" title="Migrate all the elements to the new owners prescribed in data corresponding to RedistributeTag.">Mesh::Redistribute</a> </dd></dl>

</div>
</div>
<a id="ae44b9cfcb8964acbd710562df331a51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44b9cfcb8964acbd710562df331a51a">&#9670;&nbsp;</a></span>ExchangeMarked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ExchangeMarked </td>
          <td>(</td>
          <td class="paramtype">enum Action&#160;</td>
          <td class="paramname"><em>action</em> = <code>AGhost</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function realizes two algorithms: ghosting of elements and migration of elements. </p>
<p>ghosting:</p>
<p>Creates ghost elements at other processors prescribed in SendtoTag() performs sending and receiving of elements and all operations to keep parallel state of the mesh.</p>
<p>Given that all the data was up to date among processors all the data at the end of the algorithm will be also up to data</p>
<p>migration:</p>
<p>To correctly perform migration of elements it is necessary to set up tags besides SendToTag(), which indicates to where every element should be sent:</p><ul>
<li>tag "TEMPORARY_NEW_PROCESSORS", of type DATA_INTEGER with variable size, tells which processors will have copy of the element after migration;</li>
<li>tag "TEMPORARY_NEW_OWNER", of type DATA_INTEGER of size 1, tells which processor will have the main copy of the element.</li>
</ul>
<p>if there is no current processor in "TEMPORARY_NEW_PROCESSORS", then current processor will remove the copy of the element. All this actions are performed automatically by <a class="el" href="classINMOST_1_1Mesh.html#ade20ec7c8563e82bf8057bc47a3314b7" title="Migrate all the elements to the new owners prescribed in data corresponding to RedistributeTag.">Mesh::Redistribute</a> based on information provided in <a class="el" href="classINMOST_1_1Mesh.html#a1cd4e1b35b122a5cfc24d6d74229b81b" title="Don&#39;t put this shortcut to any function directly, as it creates tag inside assign to other object of ...">Mesh::RedistributeTag</a> which effectively contains new owner.</p>
<p>Given that all the data was up to date among processors all the data at the end of the algorithm will be also up to date</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000034">Todo:</a></b></dt><dd><ol type="1">
<li>test halo exchange algorithm (if used then change collective point-2-point to collective)</li>
<li>see TODO 2 in <a class="el" href="classINMOST_1_1Mesh.html#ade20ec7c8563e82bf8057bc47a3314b7" title="Migrate all the elements to the new owners prescribed in data corresponding to RedistributeTag.">Mesh::Redistribute</a></li>
</ol>
</dd></dl>
<p>Collective point-2-point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Mesh::SendtoTag </dd>
<dd>
<a class="el" href="classINMOST_1_1Mesh.html#ade20ec7c8563e82bf8057bc47a3314b7" title="Migrate all the elements to the new owners prescribed in data corresponding to RedistributeTag.">Mesh::Redistribute</a> </dd></dl>

</div>
</div>
<a id="ae6644fc263bfaef7dc483b2873b96cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6644fc263bfaef7dc483b2873b96cc6">&#9670;&nbsp;</a></span>ExchangeOrientedData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ExchangeOrientedData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>orient</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is similar to ExchangeData, except that it will change the orientation of recieved data upon completion for the exchanged tags, registered through AddOrientedTag. </p>
<p>The orientation marker is computed using MarkNormalOrientation and could be provided by the user. If marker is provided it is assumed to be consistent. It is computed internally if zero marker is provided.</p>
<p>Blocking, Collective point-2-point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
    <tr><td class="paramname">orient</td><td>set the marker to change the sign of oriented tags, computed internally if zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a0f3d0cb9965d12635cc2df7ad458661a" title="Update data from Shared elements to Ghost elements.">Mesh::ExchangeData</a> </dd></dl>

</div>
</div>
<a id="a9913d34884eca179c968472a0525d82b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9913d34884eca179c968472a0525d82b">&#9670;&nbsp;</a></span>ExchangeOrientedData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ExchangeOrientedData </td>
          <td>(</td>
          <td class="paramtype">const tag_set &amp;&#160;</td>
          <td class="paramname"><em>tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>orient</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is similar to ExchangeData, except that it will change the orientation of recieved data upon completion for the exchanged tags, registered through AddOrientedTag. </p>
<p>The orientation marker is computed using MarkNormalOrientation and could be provided by the user. If marker is provided it is assumed to be consistent. It is computed internally if zero marker is provided. This function allows to mix oriented and normal data.</p>
<p>Blocking, Collective point-2-point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tags</td><td>multiple tags that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ac1be80eb3f359e6d2834f212131200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac1be80eb3f359e6d2834f212131200">&#9670;&nbsp;</a></span>ExclusiveSum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> INMOST::Mesh::ExclusiveSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute sum of integer values for all processors with rank lower then current, excluding current processor. </p>
<p>Collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>value on current processor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>described sum </dd></dl>

</div>
</div>
<a id="a05258a2df2245f94700407c0e51e5559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05258a2df2245f94700407c0e51e5559">&#9670;&nbsp;</a></span>FacesOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::FacesOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Face.html">Face</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>rev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks face with the orientation direction by marker. </p>
<p>If marker is set then face is reversed. Then all faces are oriented either inside or outside of the cell. </p>

</div>
</div>
<a id="a97fd4e8639eaee4461608e33d6d10dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97fd4e8639eaee4461608e33d6d10dbe">&#9670;&nbsp;</a></span>FindSharedAdjacency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HandleType INMOST::Mesh::FindSharedAdjacency </td>
          <td>(</td>
          <td class="paramtype">const HandleType *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve upper adjacent that is shared by multiple lower adjacencies. </p>
<dl class="section return"><dt>Returns</dt><dd>handle of found element or InvalidHandle() </dd></dl>

</div>
</div>
<a id="a06563442cfd581928b1f323daa151389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06563442cfd581928b1f323daa151389">&#9670;&nbsp;</a></span>GetData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::GetData </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy inner data array of size elements to provided array beginning from shift element. </p>
<p>It is assumed that user-provided array don't overlap inner data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of element </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
    <tr><td class="paramname">shift</td><td>for which element to start to copy </td></tr>
    <tr><td class="paramname">size</td><td>how many elements to copy </td></tr>
    <tr><td class="paramname">data</td><td>user-provided array where data should be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa110839ebe411d43f2f25b3b912793a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa110839ebe411d43f2f25b3b912793a4">&#9670;&nbsp;</a></span>GetDataCapacity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INMOST_DATA_ENUM_TYPE INMOST::Mesh::GetDataCapacity </td>
          <td>(</td>
          <td class="paramtype">const INMOST_DATA_BULK_TYPE *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INMOST_DATA_ENUM_TYPE&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of bytes in data used for given type of tag. </p>
<p>Trivial for all the types except DATA_VARIABLE. </p>

</div>
</div>
<a id="a285e4114d858ae4df1232161ac62acad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285e4114d858ae4df1232161ac62acad">&#9670;&nbsp;</a></span>GetDataCapacity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INMOST_DATA_ENUM_TYPE INMOST::Mesh::GetDataCapacity </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size of the structure in bytes required to represent the data on current element. </p>
<p>This is equal to GetDataSize times <a class="el" href="classINMOST_1_1Tag.html#a630a0dbb5e99188025b68cb9355deab4" title="Amount of bytes necessary to support one record referred by the tag on one element.">Tag::GetBytesSize</a> for all the data types, except for DATA_VARIABLE, that requires a larger structure to accommodate derivatives. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of element </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a069440f8fcef7797d8bc6fee41e0069c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069440f8fcef7797d8bc6fee41e0069c">&#9670;&nbsp;</a></span>GetDataSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INMOST_DATA_ENUM_TYPE INMOST::Mesh::GetDataSize </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size of the array. </p>
<p>For variable size arrays returns current size of the array. For constant size array returns the same value that may be obtained through GetSize. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of element </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Tag::GetSize </dd></dl>

</div>
</div>
<a id="a7273bdff94d190cb7864059b2b02ef31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7273bdff94d190cb7864059b2b02ef31">&#9670;&nbsp;</a></span>GetDimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> INMOST::Mesh::GetDimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of dimensions of mesh. </p>
<p>Size of the array returned by Node::Coords will match this number. </p><dl class="section see"><dt>See also</dt><dd>Node::Coords </dd></dl>

</div>
</div>
<a id="ae3f63380ce8002b1bc5bca17d9c3161c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f63380ce8002b1bc5bca17d9c3161c">&#9670;&nbsp;</a></span>GetEpsilon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> INMOST::Mesh::GetEpsilon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve tolerance for coordinates comparison. </p>
<dl class="section return"><dt>Returns</dt><dd>real value </dd></dl>

</div>
</div>
<a id="aa38db202489d5f698ca52c9a61db206b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38db202489d5f698ca52c9a61db206b">&#9670;&nbsp;</a></span>GetFileOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string INMOST::Mesh::GetFileOption </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current option corresponding to key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>options for which options should be retrieven </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91fb28d26004e1f3c4c7aa8b291ecdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91fb28d26004e1f3c4c7aa8b291ecdab">&#9670;&nbsp;</a></span>GetMarker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE bool INMOST::Mesh::GetMarker </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the marker is set one the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">n</td><td>stores byte number and byte bit mask that represent marker </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a851aa9f4f849695e3fca2c387e3e5196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851aa9f4f849695e3fca2c387e3e5196">&#9670;&nbsp;</a></span>GetMarkerSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::GetMarkerSpace </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a>&#160;</td>
          <td class="paramname"><em>copy</em>[MarkerFields]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a copy of the bytes that store markers on the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">copy</td><td>storage to put data to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add610999b1e7a8ce4aae6b3f9528d5e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add610999b1e7a8ce4aae6b3f9528d5e1">&#9670;&nbsp;</a></span>GetMeshState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE MeshState INMOST::Mesh::GetMeshState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get parallel state of the mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>either Mesh::Serial or Mesh::Parallel </dd></dl>

</div>
</div>
<a id="a74339d3cdcf08469453ff198be689833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74339d3cdcf08469453ff198be689833">&#9670;&nbsp;</a></span>GetParallelFileStrategy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int INMOST::Mesh::GetParallelFileStrategy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve currently set parallel strategy for ".pmf" files. </p>
<dl class="section see"><dt>See also</dt><dd>Mesh::GetParallelStrategy </dd></dl>

</div>
</div>
<a id="a5223aa8af17d63c7be40027ff789df7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5223aa8af17d63c7be40027ff789df7e">&#9670;&nbsp;</a></span>GetSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> INMOST::Mesh::GetSet </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve set by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>set name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>set whose name match or InvalidHandle() </dd></dl>

</div>
</div>
<a id="ac4b96761783011c7f0c1fdad296ceb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b96761783011c7f0c1fdad296ceb31">&#9670;&nbsp;</a></span>GetStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Element::Status INMOST::Mesh::GetStatus </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve parallel status of the element. </p>
<p>If mesh is in Serial state then call always returns Element::Owned. otherwise it will return:</p><ul>
<li>Element::Owned if there is a single copy of the element on the current processor</li>
<li>Element::Shared if the main copy of the element is located on the current processor</li>
<li>Element::Ghost if current processor stores dependent copy of the element <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element::Status, see function description </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ab9f84a185381a0096fc358e7e2ff5db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f84a185381a0096fc358e7e2ff5db7">&#9670;&nbsp;</a></span>GlobalID() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&amp; INMOST::Mesh::GlobalID </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve global id of the element with right of modification (dangerous to modify). </p>
<p>Run AssignGlobalID so that tag is automatically allocated and shortcut is set within mesh, otherwise tag is not created and call will fail. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>global id </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#ae39e30b11f35de81d2a9b8451ef87391" title="Assign unique numbers to elements.">Mesh::AssignGlobalID</a> </dd></dl>

</div>
</div>
<a id="adf4d944b04580540e53d95017404788f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4d944b04580540e53d95017404788f">&#9670;&nbsp;</a></span>GlobalID() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> INMOST::Mesh::GlobalID </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve global id of the element without right of modification. </p>
<p>Run AssignGlobalID so that tag is automatically allocated and shortcut is set within mesh, otherwise tag is not created and call will fail. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>global id </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#ae39e30b11f35de81d2a9b8451ef87391" title="Assign unique numbers to elements.">Mesh::AssignGlobalID</a> </dd></dl>

</div>
</div>
<a id="a77f07de278c0d245577192b66b809118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f07de278c0d245577192b66b809118">&#9670;&nbsp;</a></span>HaveData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool INMOST::Mesh::HaveData </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether data is present on given element. </p>
<p>Always returns true for dense tag data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle to the element </td></tr>
    <tr><td class="paramname">tag</td><td>tag that indicates data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if data exists otherwise false </dd></dl>

</div>
</div>
<a id="a1d9d87c22843c13e650befe095817230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9d87c22843c13e650befe095817230">&#9670;&nbsp;</a></span>HaveGlobalID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool INMOST::Mesh::HaveGlobalID </td>
          <td>(</td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether global identificator was set on certain type of elements. </p>
<p>This function does not validate correctness of global identificators. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Single type of elements on which to test presence of global identificators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if global identificators are present on provided type of elements. </dd></dl>

</div>
</div>
<a id="a7703ed18e5fb15efe6e878acd7f2b119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7703ed18e5fb15efe6e878acd7f2b119">&#9670;&nbsp;</a></span>Hidden()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool INMOST::Mesh::Hidden </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether element is hidden. </p>
<dl class="section return"><dt>Returns</dt><dd>true if hidden </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a2b3eaaadcd233cf11deba24d1fd64ad1" title="Hide element from mesh.">Mesh::Hide</a> </dd></dl>

</div>
</div>
<a id="a2b3eaaadcd233cf11deba24d1fd64ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3eaaadcd233cf11deba24d1fd64ad1">&#9670;&nbsp;</a></span>Hide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool INMOST::Mesh::Hide </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hide element from mesh. </p>
<p>All the functions (except direct access like LowConn,HighConn or ElementSet::getElementsHandles) involving adjacencies retrieval would not return this element. Works only inside BeginModification and EndModification, on EndModification all Hidden elements are destroyed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if true then element was hidden </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Mesh::BeginModification </dd>
<dd>
Mesh::EndModification </dd></dl>

</div>
</div>
<a id="a1e7462d775868bb6ef687cef8a5198cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7462d775868bb6ef687cef8a5198cb">&#9670;&nbsp;</a></span>HighConn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1array.html">Element::adj_type</a>&amp; INMOST::Mesh::HighConn </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access directly higher order adjacencies of current element with right of modification. </p>
<p>This function gives direct access to elements and allows you to overwrite handles which is not recommended. You bypass topology checks, correct connectivity establishment and geometric data updates. If you do so then check connectivity afterwards by Element::CheckElementConnectivity for debugging purposes. Then for correct function of geometrical algorithms in order from lower modified adjacenices to upper modified adjacencies (if some element have lower adjacencies updated then it should be updated otherwise it shouldn't) call ComputeGeometricType to deduce geometric representation or force it by SetGeometricType, then for element of type CELL call RestoreCellNodes, clear current mutual connection to the nodes and establish new mutual connections from nodes returned by RestoreCellNodes; then for all elements call RecomputeGeometricData to automatically recompute all geometric quantities. Don't forget that edges of the face should be ordered for correct retrieval of nodes, otherwise <a class="el" href="classINMOST_1_1Face.html#a30cb596ee968421b17a823f6deacbcf7" title="Retrieve all the nodes of the element.">Face::getNodes</a> and <a class="el" href="classINMOST_1_1Element.html#acbf123f12127ac77740dc0b76ea1bc91" title="Retrieve all the nodes of the element.">Element::getNodes</a> for FACE in 3 dimensions or <a class="el" href="classINMOST_1_1Cell.html#a4adb861c9affdb55e5ef8892717972ad" title="Get all the nodes of the current cell.">Cell::getNodes</a> and <a class="el" href="classINMOST_1_1Element.html#acbf123f12127ac77740dc0b76ea1bc91" title="Retrieve all the nodes of the element.">Element::getNodes</a> for CELL in 2 dimensions will return garbage</p>
<ul>
<li>For NODE this returns edges that are connected to this node;</li>
<li>For EDGE this returns faces that are connected to this edge;</li>
<li>For FACE this returns cells that are connected to this face</li>
<li>For CELL this returns nodes of the cell</li>
<li>For ESET first three entries are parent, sibling, child then records represent empty positions in LowConn</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>see description </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Element::CheckElementConnectivity </dd>
<dd>
<a class="el" href="classINMOST_1_1Element.html#a7721dd76bb34cbea608045406e3e21b4" title="Connects lower adjacencies to current element.">Element::Connect</a> </dd>
<dd>
Element::Disconnect </dd>
<dd>
Mesh::SetGeometricType </dd>
<dd>
<a class="el" href="classINMOST_1_1Mesh.html#a887f25126d7a0fc38e238e5c2b033d58" title="Recompute geometrical type of current element and set it to element.">Mesh::ComputeGeometricType</a> </dd>
<dd>
Mesh::RestoreCellNodes </dd>
<dd>
Mesh::RecomputeGeometricData </dd>
<dd>
Face::FixNormalOrientation </dd>
<dd>
<a class="el" href="classINMOST_1_1Mesh.html#ad20f64a301adf9c3fafe28a8f921a791" title="Access directly lower order adjacencies of current element with right of modification.">Mesh::LowConn</a> </dd></dl>

</div>
</div>
<a id="a8f9d7e81c502fc9e03c6cfa60452a28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9d7e81c502fc9e03c6cfa60452a28d">&#9670;&nbsp;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void INMOST::Mesh::Initialize </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initial initialization. </p>
<p>Calls MPI_Initialize, if MPI was not initialized it is necessary to invoke this function if you plan to use any parallel algorithms Accepts arguments passed to console application or NULL </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>number of arguments for command line </td></tr>
    <tr><td class="paramname">argv</td><td>strings of arguments of command line </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9d44832b3e826a2b61c8e91c5457fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d44832b3e826a2b61c8e91c5457fbf">&#9670;&nbsp;</a></span>Integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&amp; INMOST::Mesh::Integer </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to inner memory location of the first element of the array of integer values. </p>
<p>Future recommendation: If variable size array was not allocated then this function will generate segmentation fault.</p>
<p>If you know that data is certanly dense and fixed or variable on elements you access then it is faster to use specialized variants of this function.</p>
<p>Reference to the data is guaranteed to be valid during mesh modification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0bbbfafae1405bd27b726bdbb4c2cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0bbbfafae1405bd27b726bdbb4c2cdd">&#9670;&nbsp;</a></span>IntegerArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a4d1637367f0487eb778894b57fc94647">integer_array</a> INMOST::Mesh::IntegerArray </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array of integer values. </p>
<p>If you know that data is certanly dense and fixed or variable on elements you access then it is faster to use specialized variants of this function. variants of this function with hint data structure.</p>
<p>Array data structure is guaranteed to be valid during mesh modification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d5351b2b6e7f7824598cb46b3c35118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5351b2b6e7f7824598cb46b3c35118">&#9670;&nbsp;</a></span>IntegerArrayDF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a4d1637367f0487eb778894b57fc94647">integer_array</a> INMOST::Mesh::IntegerArrayDF </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of integer values in dense array. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and fixed is incorrect, no checks performed in release mode (NDEBUG is set), likely to result in segfault.</p>
<p>Note that as array is fixed you shouldn't use any functions that alter size of the array as resize, erase, insert, you may use replace if initial and final size will match, in debug mode assert will fire if you try to do this in release (NDEBUG is set) it will lead to segfault.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents dense data of fixed size on given handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad74aed700689551567039dfddfbf5971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74aed700689551567039dfddfbf5971">&#9670;&nbsp;</a></span>IntegerArrayDV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a4d1637367f0487eb778894b57fc94647">integer_array</a> INMOST::Mesh::IntegerArrayDV </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of integer values in dense array of variable size. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and variable is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3dd3068d4db02871478bea86fce38945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd3068d4db02871478bea86fce38945">&#9670;&nbsp;</a></span>IntegerDF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&amp; INMOST::Mesh::IntegerDF </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to inner memory location of the first element of the array of integer values. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and fixed is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents dense data of fixed size on given handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af20ebec0bab305054c5960d7683bfcfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af20ebec0bab305054c5960d7683bfcfd">&#9670;&nbsp;</a></span>IntegerDV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&amp; INMOST::Mesh::IntegerDV </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference in dense array to the first element of variable size array of integer values. </p>
<p>Future recommendation: If array was not allocated then this function will generate segmentation fault.</p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and variable is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb1eacb17ae889557d9d9d32d7b61ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1eacb17ae889557d9d9d32d7b61ed0">&#9670;&nbsp;</a></span>Integrate() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> INMOST::Mesh::Integrate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrate data corresponding to tag between all processors. </p>
<p>Elements without the data defined on them or when entry not present will be skipped.</p>
<p>Collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>tag that correspond to data to be integrated </td></tr>
    <tr><td class="paramname">entry</td><td>in the array of data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of types of elements on which to integrate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum between all processors </dd></dl>

</div>
</div>
<a id="a28c854cf5da98bb9b8525fc00ff4ca70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c854cf5da98bb9b8525fc00ff4ca70">&#9670;&nbsp;</a></span>Integrate() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::Integrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrate an array of unsigned integer values over all processors. </p>
<p>Collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>An array of values on current processor. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum over all processors. </dd></dl>

</div>
</div>
<a id="adcbcad49ef308bede1aa65fcfed626ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbcad49ef308bede1aa65fcfed626ce">&#9670;&nbsp;</a></span>Integrate() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> INMOST::Mesh::Integrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrate unsigned integer value over all processors. </p>
<p>Collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Value on current processor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum over all processors </dd></dl>

</div>
</div>
<a id="a9066868f109c3dc264ed03c174e54560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9066868f109c3dc264ed03c174e54560">&#9670;&nbsp;</a></span>Integrate() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::Integrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrate an array of integer values over all processors. </p>
<p>Collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>An array of values on current processor. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum over all processors. </dd></dl>

</div>
</div>
<a id="a541bea07883f3afa0be27748edb479ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a541bea07883f3afa0be27748edb479ff">&#9670;&nbsp;</a></span>Integrate() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> INMOST::Mesh::Integrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrate integer value over all processors. </p>
<p>Collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Value on current processor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum over all processors </dd></dl>

</div>
</div>
<a id="ab155a28f4b6cbff9d1bc4f6a4808b337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab155a28f4b6cbff9d1bc4f6a4808b337">&#9670;&nbsp;</a></span>Integrate() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::Integrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrate an array of real values over all processors. </p>
<p>Collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>An array of values on current processor. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum over all processors. </dd></dl>

</div>
</div>
<a id="ab90d3db6596d5de6f7ddfd7f72af600f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90d3db6596d5de6f7ddfd7f72af600f">&#9670;&nbsp;</a></span>Integrate() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> INMOST::Mesh::Integrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a>&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrate real value over all processors. </p>
<p>Collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Value on current processor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum over all processors </dd></dl>

</div>
</div>
<a id="ac25c2244369c7652879c1ef931606bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25c2244369c7652879c1ef931606bfc">&#9670;&nbsp;</a></span>isMeshModified()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool INMOST::Mesh::isMeshModified </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether code runs between Mesh::BeginModification, Mesh::EndModification scope. </p>
<p>In case mesh is modified, on element construction Mesh::TieElements will always place elements to the end of the array as a result all the newly created elements will be iterated after current or hidden elements. </p>

</div>
</div>
<a id="a5dfd481d638b2d2d72193b4b8fa159a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dfd481d638b2d2d72193b4b8fa159a4">&#9670;&nbsp;</a></span>Load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::Load </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>File</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acceptable file formats for reading. </p>
<ul>
<li>".vtk" - legacy vtk format for unstructured grid</li>
<li>".pvtk" - legacy parallel vtk format</li>
<li>".gmv" - format acceptable by general mesh viewer</li>
<li>".msh" - gmsh generator format</li>
<li>".grdecl" - eclipse format (under construction)</li>
<li>".grid" - mesh format by Mohammad Karimi-Fard</li>
<li>".pmf" - internal parallel portable binary format, saves all features</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">File</td><td>path to the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000036">Todo:</a></b></dt><dd><ol type="1">
<li>When loading mesh with the same tag name but different type or size, load will fail.</li>
<li>When loading tags in internal format should remember definition and sparsity masks for subsequent data loading. This will cure the case when tags were already previously defined on mesh with different masks and data will be read incorrectly. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="ad20f64a301adf9c3fafe28a8f921a791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20f64a301adf9c3fafe28a8f921a791">&#9670;&nbsp;</a></span>LowConn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1array.html">Element::adj_type</a>&amp; INMOST::Mesh::LowConn </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access directly lower order adjacencies of current element with right of modification. </p>
<p>This function gives direct access to elements and allows you to overwrite handles. If you are going to overwrite them then read recommendations in description for HighConn function.</p><ul>
<li>For NODE this returns cells that are connected to this node;</li>
<li>For EDGE this returns nodes of the edge</li>
<li>For FACE this returns edges of the face</li>
<li>For CELL this returns faces of the cell</li>
<li>For ESET handles of the elements that this set contain <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>see description </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a1e7462d775868bb6ef687cef8a5198cb" title="Access directly higher order adjacencies of current element with right of modification.">Mesh::HighConn</a> </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a722acc2cd2e4c231d512dc81b70b47ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722acc2cd2e4c231d512dc81b70b47ca">&#9670;&nbsp;</a></span>MarkBoundaryFaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::MarkBoundaryFaces </td>
          <td>(</td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>boundary_marker</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets marker for all the faces that have only one neighbouring cell, works correctly in parallel environment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundary_marker</td><td>Non-private marker that will indicate boundary faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4efb0a61a91538bba5e5d49e5a992362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4efb0a61a91538bba5e5d49e5a992362">&#9670;&nbsp;</a></span>MarkNormalOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::MarkNormalOrientation </td>
          <td>(</td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>mrk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function should be used to detect normal inversion on ghost interfaces with respect to normal orientation on owner of the interface. </p>
<p>Due to automatic control over normal orientation in the grid, it may happen that some ghost faces have different orientation rather then face on owner processor. It may happen that some data depends on normal orientation, then one should be aware on a local processor orientation may be different from owner value, then the data may have incorrect sign. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mrk</td><td>Non-private marker that will indicate inverted normals </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a473a038fc2a9f9ba422dc17ea60114a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473a038fc2a9f9ba422dc17ea60114a0">&#9670;&nbsp;</a></span>New()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool INMOST::Mesh::New </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether element is new. </p>
<p>Works only in modification state (between BeginModification and EndModification), when you create elements all of them are marked. </p><dl class="section return"><dt>Returns</dt><dd>true if new </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Mesh::BeginModification </dd>
<dd>
Mesh::EndModification </dd></dl>

</div>
</div>
<a id="a1e44c6e0e39783512dd18424e21d3d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e44c6e0e39783512dd18424e21d3d8d">&#9670;&nbsp;</a></span>NumberOfTags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> INMOST::Mesh::NumberOfTags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the total number of valid tags. </p>
<dl class="section return"><dt>Returns</dt><dd>returns the number of valid tags </dd></dl>

</div>
</div>
<a id="afa084c637bc9f6850ed77fbb7778d404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa084c637bc9f6850ed77fbb7778d404">&#9670;&nbsp;</a></span>Real()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a>&amp; INMOST::Mesh::Real </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to inner memory location of the first element of the array of real values. </p>
<p>Future recommendation: If variable size array was not allocated then this function will generate segmentation fault.</p>
<p>If you know that data is certanly dense and fixed or variable on elements you access then it is faster to use specialized variants of this function.</p>
<p>Reference to the data is guaranteed to be valid during mesh modification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a90e88bbdedcf71c3226f3dc94da66807" title="Returns a reference to inner memory location of the first element of the array of real values.">Mesh::RealDF</a> </dd>
<dd>
<a class="el" href="classINMOST_1_1Mesh.html#a679a4a6ed4e4508126919b8fc8fea27a" title="Returns a reference in dense array to the first element of variable size array of real values.">Mesh::RealDV</a> </dd></dl>

</div>
</div>
<a id="a06bdd4e7c0d26750ca0aa40e03fc7d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06bdd4e7c0d26750ca0aa40e03fc7d4c">&#9670;&nbsp;</a></span>RealArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a430e5358d435befb38169beef593527e">real_array</a> INMOST::Mesh::RealArray </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array of real values. </p>
<p>If you know that data is certanly dense on elements you access then it is faster to use variants of this function with hint data structure.</p>
<p>Array data structure is guaranteed to be valid during mesh modification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8527fa3c2f6ece108b5abce389566365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8527fa3c2f6ece108b5abce389566365">&#9670;&nbsp;</a></span>RealArrayDF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a430e5358d435befb38169beef593527e">real_array</a> INMOST::Mesh::RealArrayDF </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of real values in dense array. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and fixed is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<p>Note that as array is fixed you shouldn't use any functions that alter size of the array as resize, erase, insert, you may use replace if initial and final size will match, in debug mode assert will fire if you try to do this in release (NDEBUG is set) it will lead to segfault.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents dense data of fixed size on given handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7a5f7d22e5b9f7c01b9741719b853dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a5f7d22e5b9f7c01b9741719b853dc">&#9670;&nbsp;</a></span>RealArrayDV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a430e5358d435befb38169beef593527e">real_array</a> INMOST::Mesh::RealArrayDV </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of real values in dense array of variable size. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and variable is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90e88bbdedcf71c3226f3dc94da66807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e88bbdedcf71c3226f3dc94da66807">&#9670;&nbsp;</a></span>RealDF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a>&amp; INMOST::Mesh::RealDF </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to inner memory location of the first element of the array of real values. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and fixed is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a679a4a6ed4e4508126919b8fc8fea27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679a4a6ed4e4508126919b8fc8fea27a">&#9670;&nbsp;</a></span>RealDV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a>&amp; INMOST::Mesh::RealDV </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference in dense array to the first element of variable size array of real values. </p>
<p>Future recommendation: If array was not allocated (resized) then this function will generate segmentation fault.</p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and variable is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5691f394480da7e21c5099e313df03e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5691f394480da7e21c5099e313df03e0">&#9670;&nbsp;</a></span>RecomputeParallelStorage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::RecomputeParallelStorage </td>
          <td>(</td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Regather ghost and shared element sets for data exchange. </p>
<p>This function will be quite useful if you change statuses of elements or modify mesh on your own bypassing internal algorithms.</p>
<p>No action will be performed if USE_PARALLEL_STORAGE is not set in <a class="el" href="inmost__common_8h_source.html">inmost_common.h</a>, since all the elements are computed during exchange phase.</p>
<p>Generally this is not needed if you use high-level algorithms for mesh modification or mesh redistribution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Bitwise mask of element types for which to recompute the parallel storage. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Mesh::BeginModification </dd>
<dd>
Mesh::EndModification </dd>
<dd>
<a class="el" href="classINMOST_1_1Mesh.html#ae44b9cfcb8964acbd710562df331a51a" title="This function realizes two algorithms: ghosting of elements and migration of elements.">Mesh::ExchangeMarked</a> </dd>
<dd>
<a class="el" href="classINMOST_1_1Mesh.html#a5cb95f1e8d6b7987496fc8276c86cf3a" title="Delete some ghost cells provided in array.">Mesh::RemoveGhostElements</a> </dd></dl>

</div>
</div>
<a id="a1fa08bcccce1d1af7afc2eb14890670d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa08bcccce1d1af7afc2eb14890670d">&#9670;&nbsp;</a></span>RecordParallelStorage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::RecordParallelStorage </td>
          <td>(</td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs parallel storage into xml log files. </p>
<p>USE_PARALLEL_STORAGE and USE_PARALLEL_WRITE_TIME should be activated in <a class="el" href="inmost__common_8h_source.html">inmost_common.h</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Bitwise mask of element types for which to log the parallel storage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade20ec7c8563e82bf8057bc47a3314b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade20ec7c8563e82bf8057bc47a3314b7">&#9670;&nbsp;</a></span>Redistribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::Redistribute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Migrate all the elements to the new owners prescribed in data corresponding to RedistributeTag. </p>
<p>This will perform all the actions to send mesh elements and data and reproduce new mesh partitions on remote elements and correctly resolve parallel state of the mesh. If you have previously prescribed number of layers through ExchangeGhost, then minimal number of actions will be performed to reproduce layers of ghost elements without involving removal of all ghost elements.</p>
<p>Internally function sets up following data on elements using provided information:</p><ul>
<li>"TEMPORARY_NEW_PROCESSORS" - new set processors that contain copy of the element</li>
<li>"TEMPORARY_NEW_OWNER" - new owner for each processor (effectively RedistributeTag)</li>
</ul>
<p>Action of this function regarding restoration of layers of ghost elements in the case you have modified mesh without involving <a class="el" href="classINMOST_1_1Mesh.html#a60274817b98e76ec5a411f0c3df2a76b" title="This function is not yet implemented.">Mesh::ResolveModification</a> is yet to be tested and should be considered dangerous.</p>
<p>If you have output from Zoltan or ParMetis for cells of the mesh then just write this output to RedistributeTag and call <a class="el" href="classINMOST_1_1Mesh.html#ade20ec7c8563e82bf8057bc47a3314b7" title="Migrate all the elements to the new owners prescribed in data corresponding to RedistributeTag.">Mesh::Redistribute</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000035">Todo:</a></b></dt><dd><ol type="1">
<li>introduce "TEMPORARY_KEEP_GHOSTED" tag that will store processors on which copy of element should be kept, internally just merge it with "TEMPORARY_NEW_PROCESSORS" tag this will allow user to control ghosting of certain elements and not to invoke ExchangeMarked every time after Redistribute. This is probably already done using Mesh::SendtoTag, because function fills it without clearing and ExchangeMarked performs initial action based on SendtoTag, it is due to check that SendtoTag is properly merged with "TEMPORARY_NEW_PROCESSORS" before call to ExchangeMarked and received elements are not deleted by accident.</li>
<li>let user provide any integer tag as input without involving RedistributeTag</li>
</ol>
</dd></dl>
<p>Collective point-2-point.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a1cd4e1b35b122a5cfc24d6d74229b81b" title="Don&#39;t put this shortcut to any function directly, as it creates tag inside assign to other object of ...">Mesh::RedistributeTag</a> </dd>
<dd>
<a class="el" href="classINMOST_1_1Mesh.html#a9e8cabff3db1f7af1b426f8e2f582752" title="Form several layers of ghost cells that are adjacent through bridge elements to current cells.">Mesh::ExchangeGhost</a> </dd></dl>

</div>
</div>
<a id="a2d488479041917c975b1e662d642c4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d488479041917c975b1e662d642c4a5">&#9670;&nbsp;</a></span>ReduceData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ReduceData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceOperation&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accumulation of data from ghost elements to shared elements. </p>
<p>Accumulation is performed based on user-provided function. When processor - owner of the element receives data addressed to this element then it calls user-defined op function. Since there may be multiple ghost elements per one shared element, function may be called multiple times.</p>
<p>Several examples of reduction functions may be found within the parallel.cpp source.</p>
<p>Remember that the result will be up to date only on the owner processor of the element. You will have to run <a class="el" href="classINMOST_1_1Mesh.html#a0f3d0cb9965d12635cc2df7ad458661a" title="Update data from Shared elements to Ghost elements.">Mesh::ExchangeData</a> to make the data up to date among all of the processors.</p>
<p>If you have a tag of DATA_BULK type and you store your own custom data structure in it, it is highly recommended that you provide MPI information about your structure through Tag::SetBulkDataType, this would not do any difference on homogeneous architecture, but it may help you save a lot of time and nerves in heterogeneous parallel environment.</p>
<p>Exchanging tags of DATA_REFERENCE is not implemented, TODO 14. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000033">Todo:</a></b></dt><dd><ol type="1">
<li>Exchanging DATA_REFERENCE,DATA_REMOTE_REFERENCE tags not implemented, this is due to the absence of any conclusion</li>
</ol>
<ul>
<li>on how it should behave: either only search within elements owned by the other processor and establish references and set InvalidHandle() to elements that are not found (fairly easy, will involve search operations to check against owned elements for similar entry, efficient implementation will require bounding search trees (see TODO 49);</li>
<li>or: send all the referenced elements through PackElementsData and establish all the links within elements reproduced by UnpackElementsData (UnpackElementsData calls UnpackTagData with set of unpacked elements using which it will be very comfortable to establish references on remote processor). Drawback is that exchanging laplacian operator in such a manner should result in the whole grid being shared among all the processors.</li>
</ul>
</dd></dl>
<p>Blocking, Collective point-2-point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
    <tr><td class="paramname">op</td><td>user-defined operation on received data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a0f3d0cb9965d12635cc2df7ad458661a" title="Update data from Shared elements to Ghost elements.">Mesh::ExchangeData</a> </dd></dl>

</div>
</div>
<a id="a831a8bab953c4d8aa102e58bac81c25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831a8bab953c4d8aa102e58bac81c25f">&#9670;&nbsp;</a></span>ReduceData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ReduceData </td>
          <td>(</td>
          <td class="paramtype">const tag_set &amp;&#160;</td>
          <td class="paramname"><em>tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceOperation&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will perform reduction of multiple data tags. </p>
<p>Note that function will be the same for all tags, you can differentiate behavior of function depending on tag name (may be expensive).</p>
<p>Blocking, collective point-2-point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tags</td><td>multiple tags that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
    <tr><td class="paramname">op</td><td>user-defined operation on received data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0597bf77b8438dc79bf791912a2b34d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0597bf77b8438dc79bf791912a2b34d2">&#9670;&nbsp;</a></span>ReduceDataBegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ReduceDataBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function intializes data reduction. </p>
<p>Read recommendations about exchange_storage object in <a class="el" href="classINMOST_1_1Mesh.html#a35ca81c3d8a01aa6a9ce983769fa03cd" title="Start asynchronous synchronization of data.">Mesh::ExchangeDataBegin</a></p>
<p>Nonblocking, Collective point-2-point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
    <tr><td class="paramname">storage</td><td>buffer that will temporary hold sended data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a2d488479041917c975b1e662d642c4a5" title="Accumulation of data from ghost elements to shared elements.">Mesh::ReduceData</a> </dd>
<dd>
<a class="el" href="classINMOST_1_1Mesh.html#a35ca81c3d8a01aa6a9ce983769fa03cd" title="Start asynchronous synchronization of data.">Mesh::ExchangeDataBegin</a> </dd></dl>

</div>
</div>
<a id="a71c5b8a155e89d182f18e26dbe4b8670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c5b8a155e89d182f18e26dbe4b8670">&#9670;&nbsp;</a></span>ReduceDataBegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ReduceDataBegin </td>
          <td>(</td>
          <td class="paramtype">const tag_set &amp;&#160;</td>
          <td class="paramname"><em>tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will initialize reduction of multiple data tags. </p>
<p>Nonblocking, collective point-2-point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tags</td><td>multiple tags that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
    <tr><td class="paramname">storage</td><td>buffer that will temporary hold sended data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8273226d8ab6e54baba5db22107df37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8273226d8ab6e54baba5db22107df37">&#9670;&nbsp;</a></span>ReduceDataEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ReduceDataEnd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceOperation&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function completes data reduction. </p>
<p>Read <a class="el" href="classINMOST_1_1Mesh.html#a2d488479041917c975b1e662d642c4a5" title="Accumulation of data from ghost elements to shared elements.">Mesh::ReduceData</a> for information about op function</p>
<p>Blocking</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
    <tr><td class="paramname">storage</td><td>buffer that will temporary hold sended data </td></tr>
    <tr><td class="paramname">op</td><td>user-defined operation on received data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a2d488479041917c975b1e662d642c4a5" title="Accumulation of data from ghost elements to shared elements.">Mesh::ReduceData</a> </dd></dl>

</div>
</div>
<a id="aabf4380aa2878e72cf399f97598dcebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf4380aa2878e72cf399f97598dcebe">&#9670;&nbsp;</a></span>ReduceDataEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ReduceDataEnd </td>
          <td>(</td>
          <td class="paramtype">const tag_set &amp;&#160;</td>
          <td class="paramname"><em>tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceOperation&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will finalize exchange of multiple data tags. </p>
<p>Blocking</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tags</td><td>multiple tags that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
    <tr><td class="paramname">storage</td><td>buffer that will temporary hold sended data </td></tr>
    <tr><td class="paramname">op</td><td>user-defined operation on received data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfa8b2f65d63edbbed90d865ab6f5314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa8b2f65d63edbbed90d865ab6f5314">&#9670;&nbsp;</a></span>Reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a8674802045ec170a3c9d0e3281545b54">reference</a>&amp; INMOST::Mesh::Reference </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference in an inner representation to the first element of array of element handles. </p>
<p>Future recommendation: If variable size array was not allocated then this function will generate segmentation fault.</p>
<p>If you know that data is certanly dense and fixed or variable on elements you access then it is faster to use specialized variants of this function.</p>
<p>Reference to the data is guaranteed to be valid during mesh modification.</p>
<p>Using handle you can construct objects of type <a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes.">Storage</a>, <a class="el" href="classINMOST_1_1Element.html">Element</a>, <a class="el" href="classINMOST_1_1Node.html">Node</a>, <a class="el" href="classINMOST_1_1Edge.html">Edge</a>, <a class="el" href="classINMOST_1_1Face.html" title="An interface for elements of type FACE.">Face</a>, <a class="el" href="classINMOST_1_1Cell.html" title="An interface for elements of type CELL.">Cell</a>, <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> by calling their constructor with pointer to mesh and handle as arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac211da4cbe1dc33394c9b725b64b1e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac211da4cbe1dc33394c9b725b64b1e86">&#9670;&nbsp;</a></span>ReferenceArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage_1_1reference__array.html">reference_array</a> INMOST::Mesh::ReferenceArray </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array of element handles. </p>
<p>If you know that data is certanly sparse or dense on elements you access then it is faster to use variants of this function with hint data structure.</p>
<p>The class reference_array that is used to represent array of elements stores handles inside but accessing them through square scopes [] or by arrow -&gt; in iterator will automatically form object of type <a class="el" href="classINMOST_1_1Element.html">Element</a>. If you are not sure that stored handles are valid, you should either check that by Element::isValid (involves deep check) or test handle against InvalidHandle (simple check). To obtain handle you may use reference_array::at function or dereference * operator for iterator. If you need custom object like <a class="el" href="classINMOST_1_1Node.html">Node</a>, <a class="el" href="classINMOST_1_1Edge.html">Edge</a>, <a class="el" href="classINMOST_1_1Face.html" title="An interface for elements of type FACE.">Face</a>, <a class="el" href="classINMOST_1_1Cell.html" title="An interface for elements of type CELL.">Cell</a> or <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> you may use Element::getAsNode, Element::getAsEdge, Element::getAsFace, Element::getAsCell and Element::getAsSet functions.</p>
<p>Array data structure is guaranteed to be valid during mesh modification. If you delete elements by <a class="el" href="classINMOST_1_1Mesh.html#a569c516120df121980d0585deadd3634" title="This function will hide element in modification state (between BeginModification and EndModification)...">Mesh::Delete</a> or <a class="el" href="classINMOST_1_1Element.html#ab07dd77f97d0c81c90b62cdcecdcf2a9" title="Remove element from mesh.">Element::Delete</a> all the references are also will be valid and reverted to InvalidHandle on <a class="el" href="classINMOST_1_1Mesh.html#a1f53070855f3503b2f4cefc16cedd6a0" title="After this function any link to deleted element will be replaced by InvalidHandle().">Mesh::ApplyModification</a>. If you use <a class="el" href="classINMOST_1_1Mesh.html#a0e2c090ee95e802c4f486a5d98fc6cb0" title="Completely destroy element from mesh.">Mesh::Destroy</a> to delete mesh elements or you delete elements not within modification state then references may become either invalid but not testable against InvalidHandle (situation may be tested by Element::isValid or Mesh::isValidHandle) or reference may be reused by another element. If you mix deletion and construction of elements then there is no way to resolve this situation, except if you have created only one element, then it may be retrieved by Mesh::LastHandle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>InvalidHandle </dd>
<dd>
Element::isValid </dd>
<dd>
Element::getAsNode </dd>
<dd>
Element::getAsEdge </dd>
<dd>
Element::getAsFace </dd>
<dd>
Element::getAsCell </dd>
<dd>
Element::getAsSet </dd></dl>

</div>
</div>
<a id="a92ba4c935940111e2c9584a9cc96fe6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ba4c935940111e2c9584a9cc96fe6f">&#9670;&nbsp;</a></span>ReferenceArrayDF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage_1_1reference__array.html">reference_array</a> INMOST::Mesh::ReferenceArrayDF </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of element handles in dense array. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and fixed is incorrect, no checks performed in release mode (NDEBUG is set), likely to result in segfault.</p>
<p>Note that as array is fixed you shouldn't use any functions that alter size of the array as resize, erase, insert, you may use replace if initial and final size will match, in debug mode assert will fire if you try to do this in release (NDEBUG is set) it will lead to segfault.</p>
<p>The class reference_array that is used to represent array of elements stores handles inside but accessing them through square scopes [] or by arrow -&gt; in iterator will automatically form object of type <a class="el" href="classINMOST_1_1Element.html">Element</a>. If you are not sure that stored handles are valid, you should either check that by Element::isValid (involves deep check) or test handle against InvalidHandle (simple check). To obtain handle you may use reference_array::at function or dereference * operator for iterator. If you need custom object like <a class="el" href="classINMOST_1_1Node.html">Node</a>, <a class="el" href="classINMOST_1_1Edge.html">Edge</a>, <a class="el" href="classINMOST_1_1Face.html" title="An interface for elements of type FACE.">Face</a>, <a class="el" href="classINMOST_1_1Cell.html" title="An interface for elements of type CELL.">Cell</a> or <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> you may use Element::getAsNode, Element::getAsEdge, Element::getAsFace, Element::getAsCell and Element::getAsSet functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents dense data of fixed size on given handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>InvalidHandle </dd>
<dd>
Element::isValid </dd>
<dd>
Element::getAsNode </dd>
<dd>
Element::getAsEdge </dd>
<dd>
Element::getAsFace </dd>
<dd>
Element::getAsCell </dd>
<dd>
Element::getAsSet </dd></dl>

</div>
</div>
<a id="aa2a8c6f6d53a863be14b2c137de4eff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a8c6f6d53a863be14b2c137de4eff5">&#9670;&nbsp;</a></span>ReferenceArrayDV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage_1_1reference__array.html">reference_array</a> INMOST::Mesh::ReferenceArrayDV </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of element handles in dense array of variable size. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and variable is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<p>The class reference_array that is used to represent array of elements stores handles inside but accessing them through square scopes [] or by arrow -&gt; in iterator will automatically form object of type <a class="el" href="classINMOST_1_1Element.html">Element</a>. If you are not sure that stored handles are valid, you should either check that by Element::isValid (involves deep check) or test handle against InvalidHandle (simple check). To obtain handle you may use reference_array::at function or dereference * operator for iterator. If you need custom object like <a class="el" href="classINMOST_1_1Node.html">Node</a>, <a class="el" href="classINMOST_1_1Edge.html">Edge</a>, <a class="el" href="classINMOST_1_1Face.html" title="An interface for elements of type FACE.">Face</a>, <a class="el" href="classINMOST_1_1Cell.html" title="An interface for elements of type CELL.">Cell</a> or <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> you may use Element::getAsNode, Element::getAsEdge, Element::getAsFace, Element::getAsCell and Element::getAsSet functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>InvalidHandle </dd>
<dd>
Element::isValid </dd>
<dd>
Element::getAsNode </dd>
<dd>
Element::getAsEdge </dd>
<dd>
Element::getAsFace </dd>
<dd>
Element::getAsCell </dd>
<dd>
Element::getAsSet </dd></dl>

</div>
</div>
<a id="ab5abf1a33ab21a0c60338a97287fc115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5abf1a33ab21a0c60338a97287fc115">&#9670;&nbsp;</a></span>ReferenceDF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a8674802045ec170a3c9d0e3281545b54">reference</a>&amp; INMOST::Mesh::ReferenceDF </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference in dense array to the first element of constant size array of element handles. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and fixed is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<p>Using handle you can construct objects of type <a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes.">Storage</a>, <a class="el" href="classINMOST_1_1Element.html">Element</a>, <a class="el" href="classINMOST_1_1Node.html">Node</a>, <a class="el" href="classINMOST_1_1Edge.html">Edge</a>, <a class="el" href="classINMOST_1_1Face.html" title="An interface for elements of type FACE.">Face</a>, <a class="el" href="classINMOST_1_1Cell.html" title="An interface for elements of type CELL.">Cell</a>, <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> by calling their constructor with pointer to mesh and handle as arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents dense data of fixed size on given handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac87430b220565362949e68b073e07c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87430b220565362949e68b073e07c8a">&#9670;&nbsp;</a></span>ReferenceDV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a8674802045ec170a3c9d0e3281545b54">reference</a>&amp; INMOST::Mesh::ReferenceDV </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference in dense array to the first element of variable size array of element handles. </p>
<p>Future recommendation: If array was not allocated then this function will generate segmentation fault.</p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and variable is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<p>Using handle you can construct objects of type <a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes.">Storage</a>, <a class="el" href="classINMOST_1_1Element.html">Element</a>, <a class="el" href="classINMOST_1_1Node.html">Node</a>, <a class="el" href="classINMOST_1_1Edge.html">Edge</a>, <a class="el" href="classINMOST_1_1Face.html" title="An interface for elements of type FACE.">Face</a>, <a class="el" href="classINMOST_1_1Cell.html" title="An interface for elements of type CELL.">Cell</a>, <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> by calling their constructor with pointer to mesh and handle as arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40814cb2b1031870784d1a2fd3f389de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40814cb2b1031870784d1a2fd3f389de">&#9670;&nbsp;</a></span>ReleaseMarker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ReleaseMarker </td>
          <td>(</td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>cleanup</em> = <code>NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release marker back for reuse. </p>
<p>This function will only notice mesh that the marker is free to be reused, this will not clear markers from elements. Before releasing the marker you should ensure that all the marker is removed from all the elements. Since many inner algorithms use markers, not properly clearing markers from elements may lead to undefined behavior.</p>
<p>Since it is expensive to check asserts will fire in debug mode (NDEBUG not set) only if you define CHECKS_MARKERS in <a class="el" href="inmost__common_8h_source.html">inmost_common.h</a>, no checks will be performed in release mode(NDEBUG is set). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Byte position and byte bit mask. </td></tr>
    <tr><td class="paramname">cleanup</td><td>Elements on which marker should be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2820b01ab65f402c31a03158a3ebd76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2820b01ab65f402c31a03158a3ebd76c">&#9670;&nbsp;</a></span>RemMarker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE void INMOST::Mesh::RemMarker </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the marker from the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">n</td><td>stores byte number and byte bit mask that represent marker </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14f8614996be1f7dd81825a447e9f4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f8614996be1f7dd81825a447e9f4e8">&#9670;&nbsp;</a></span>RemMarkerArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::RemMarkerArray </td>
          <td>(</td>
          <td class="paramtype">const HandleType *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the marker from the set of handles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>set of handles </td></tr>
    <tr><td class="paramname">n</td><td>number of handles </td></tr>
    <tr><td class="paramname">m</td><td>stores byte number and byte bit mask that represent marker </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a2820b01ab65f402c31a03158a3ebd76c" title="Remove the marker from the element.">Mesh::RemMarker</a> </dd></dl>

</div>
</div>
<a id="a6cb599c441558cf1cdb40f37be8d0562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb599c441558cf1cdb40f37be8d0562">&#9670;&nbsp;</a></span>RemoteReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a211e235d55d933c5dc3f7040e0b50504">remote_reference</a>&amp; INMOST::Mesh::RemoteReference </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference in an inner representation to the first element of array of element remote handles. </p>
<p>Future recomendation: If variable size array was not allocated then this function will generate segmentation fault.</p>
<p>If you know that data is certanly dense and fixed or variable on elements you access then it is faster to use specialized variants of this function.</p>
<p>Reference to the data is guaranteed to be valid during mesh modification.</p>
<p>Using remote handle you can construct objects of type <a class="el" href="classINMOST_1_1Element.html">Element</a> with the function MakeElement or MakeElementRef.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>MakeElement </dd>
<dd>
MakeElementRef </dd></dl>

</div>
</div>
<a id="a7759b6b5f4a79de76713c4cf1fda1dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7759b6b5f4a79de76713c4cf1fda1dbf">&#9670;&nbsp;</a></span>RemoteReferenceArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage_1_1remote__reference__array.html">remote_reference_array</a> INMOST::Mesh::RemoteReferenceArray </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array of element remote handles. </p>
<p>If you know that data is certanly sparse or dense on elements you access then it is faster to use variants of this function with hint data structure.</p>
<p>The class reference_array that is used to represent array of elements stores remote handles inside but accessing them through square scopes [] or by arrow -&gt; in iterator will automatically form an object of type <a class="el" href="classINMOST_1_1Element.html">Element</a>. If you are not sure that stored handles are valid, you should either check that by Element::isValid (involves deep check) or test handle against InvalidHandle (simple check). To obtain remote handle you may use remote_reference_array::at function or dereference * operator for iterator. If you need custom object like <a class="el" href="classINMOST_1_1Node.html">Node</a>, <a class="el" href="classINMOST_1_1Edge.html">Edge</a>, <a class="el" href="classINMOST_1_1Face.html" title="An interface for elements of type FACE.">Face</a>, <a class="el" href="classINMOST_1_1Cell.html" title="An interface for elements of type CELL.">Cell</a> or <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> you may use Element::getAsNode, Element::getAsEdge, Element::getAsFace, Element::getAsCell and Element::getAsSet functions.</p>
<p>Array data structure is guaranteed to be valid during mesh modification. If you delete elements by <a class="el" href="classINMOST_1_1Mesh.html#a569c516120df121980d0585deadd3634" title="This function will hide element in modification state (between BeginModification and EndModification)...">Mesh::Delete</a> or <a class="el" href="classINMOST_1_1Element.html#ab07dd77f97d0c81c90b62cdcecdcf2a9" title="Remove element from mesh.">Element::Delete</a> all the references are also will be valid and reverted to InvalidHandle on <a class="el" href="classINMOST_1_1Mesh.html#a1f53070855f3503b2f4cefc16cedd6a0" title="After this function any link to deleted element will be replaced by InvalidHandle().">Mesh::ApplyModification</a>. If you use <a class="el" href="classINMOST_1_1Mesh.html#a0e2c090ee95e802c4f486a5d98fc6cb0" title="Completely destroy element from mesh.">Mesh::Destroy</a> to delete mesh elements or you delete elements not within modification state then references may become either invalid but not testable against InvalidHandle (situation may be tested by Element::isValid or Mesh::isValidHandle) or reference may be reused by another element. If you mix deletion and construction of elements then there is no way to resolve this situation, except if you have created only one element, then it may be retrieved by Mesh::LastHandle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>InvalidHandle </dd>
<dd>
Element::isValid </dd>
<dd>
Element::getAsNode </dd>
<dd>
Element::getAsEdge </dd>
<dd>
Element::getAsFace </dd>
<dd>
Element::getAsCell </dd>
<dd>
Element::getAsSet </dd></dl>

</div>
</div>
<a id="aa9375f7cdff4c060bb765028c95a9e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9375f7cdff4c060bb765028c95a9e73">&#9670;&nbsp;</a></span>RemoteReferenceArrayDF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage_1_1remote__reference__array.html">remote_reference_array</a> INMOST::Mesh::RemoteReferenceArrayDF </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of element remote handles in dense array. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and fixed is incorrect, no checks performed in release mode (NDEBUG is set), likely to result in segfault.</p>
<p>Note that as array is fixed you shouldn't use any functions that alter size of the array as resize, erase, insert, you may use replace if initial and final size will match, in debug mode assert will fire if you try to do this in release (NDEBUG is set) it will lead to segfault.</p>
<p>The class remote_reference_array that is used to represent array of elements stores handles inside but accessing them through square scopes [] or by arrow -&gt; in iterator will automatically form object of type <a class="el" href="classINMOST_1_1Element.html">Element</a>. If you are not sure that stored handles are valid, you should either check that by Element::isValid (involves deep check) or test handle against InvalidHandle (simple check). To obtain handle you may use reference_array::at function or dereference * operator for iterator. If you need custom object like <a class="el" href="classINMOST_1_1Node.html">Node</a>, <a class="el" href="classINMOST_1_1Edge.html">Edge</a>, <a class="el" href="classINMOST_1_1Face.html" title="An interface for elements of type FACE.">Face</a>, <a class="el" href="classINMOST_1_1Cell.html" title="An interface for elements of type CELL.">Cell</a> or <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> you may use Element::getAsNode, Element::getAsEdge, Element::getAsFace, Element::getAsCell and Element::getAsSet functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents dense data of fixed size on given handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>InvalidHandle </dd>
<dd>
Element::isValid </dd>
<dd>
Element::getAsNode </dd>
<dd>
Element::getAsEdge </dd>
<dd>
Element::getAsFace </dd>
<dd>
Element::getAsCell </dd>
<dd>
Element::getAsSet </dd></dl>

</div>
</div>
<a id="a610fbebb7fb4d1b0c4103fc5b3a37170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610fbebb7fb4d1b0c4103fc5b3a37170">&#9670;&nbsp;</a></span>RemoteReferenceArrayDV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage_1_1remote__reference__array.html">remote_reference_array</a> INMOST::Mesh::RemoteReferenceArrayDV </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of element remote handles in dense array of variable size. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and variable is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<p>The class remote_reference_array that is used to represent array of elements stores remote handles inside but accessing them through square scopes [] or by arrow -&gt; in iterator will automatically form object of type <a class="el" href="classINMOST_1_1Element.html">Element</a>. If you are not sure that stored handles are valid, you should either check that by Element::isValid (involves deep check) or test handle against InvalidHandle (simple check). To obtain handle you may use reference_array::at function or dereference * operator for iterator. If you need custom object like <a class="el" href="classINMOST_1_1Node.html">Node</a>, <a class="el" href="classINMOST_1_1Edge.html">Edge</a>, <a class="el" href="classINMOST_1_1Face.html" title="An interface for elements of type FACE.">Face</a>, <a class="el" href="classINMOST_1_1Cell.html" title="An interface for elements of type CELL.">Cell</a> or <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> you may use Element::getAsNode, Element::getAsEdge, Element::getAsFace, Element::getAsCell and Element::getAsSet functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>InvalidHandle </dd>
<dd>
Element::isValid </dd>
<dd>
Element::getAsNode </dd>
<dd>
Element::getAsEdge </dd>
<dd>
Element::getAsFace </dd>
<dd>
Element::getAsCell </dd>
<dd>
Element::getAsSet </dd></dl>

</div>
</div>
<a id="a4fdb38e9a9120e954ef1c4d7b912c591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fdb38e9a9120e954ef1c4d7b912c591">&#9670;&nbsp;</a></span>RemoteReferenceDF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a211e235d55d933c5dc3f7040e0b50504">remote_reference</a>&amp; INMOST::Mesh::RemoteReferenceDF </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference in dense array to the first element of constant size array of element remote handles. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and fixed is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<p>Using handle you can construct objects of type <a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes.">Storage</a>, <a class="el" href="classINMOST_1_1Element.html">Element</a>, <a class="el" href="classINMOST_1_1Node.html">Node</a>, <a class="el" href="classINMOST_1_1Edge.html">Edge</a>, <a class="el" href="classINMOST_1_1Face.html" title="An interface for elements of type FACE.">Face</a>, <a class="el" href="classINMOST_1_1Cell.html" title="An interface for elements of type CELL.">Cell</a>, <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> by calling their constructor with pointer to mesh and handle as arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents dense data of fixed size on given handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74af68d7c80c8b6b8259cfb68e47dd16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74af68d7c80c8b6b8259cfb68e47dd16">&#9670;&nbsp;</a></span>RemoteReferenceDV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a211e235d55d933c5dc3f7040e0b50504">remote_reference</a>&amp; INMOST::Mesh::RemoteReferenceDV </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference in dense array to the first element of variable size array of element remote handles. </p>
<p>Future recommendation: If array was not allocated then this function will generate segmentation fault.</p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and variable is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<p>Using handle you can construct objects of type <a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes.">Storage</a>, <a class="el" href="classINMOST_1_1Element.html">Element</a>, <a class="el" href="classINMOST_1_1Node.html">Node</a>, <a class="el" href="classINMOST_1_1Edge.html">Edge</a>, <a class="el" href="classINMOST_1_1Face.html" title="An interface for elements of type FACE.">Face</a>, <a class="el" href="classINMOST_1_1Cell.html" title="An interface for elements of type CELL.">Cell</a>, <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> by calling their constructor with pointer to mesh and handle as arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cb95f1e8d6b7987496fc8276c86cf3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb95f1e8d6b7987496fc8276c86cf3a">&#9670;&nbsp;</a></span>RemoveGhostElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::RemoveGhostElements </td>
          <td>(</td>
          <td class="paramtype">const HandleType *&#160;</td>
          <td class="paramname"><em>ghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete some ghost cells provided in array. </p>
<p>Non-ghost elements will also be deleted.</p>
<p>This algorithm will properly communicate between processors so that parallel states of deleted elements properly updated on remote processors. Internally function invokes Destroy function, not Delete, which hides elements during modification state, currently it is not expected that any parallel algorithms will be performed between BeginModification and EndModification since modification may break parallel state though it is never checked whether the mesh is in the modification state, so you are free to experiment. This behavior may change in future.</p>
<p>Collective point-2-point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ghost</td><td>array of handles </td></tr>
    <tr><td class="paramname">num</td><td>number of handles </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000030">Todo:</a></b></dt><dd><ol type="1">
<li>Currently request for deletion of elements of lower level then cell will be simply ignored, ensure in future that algorithm will properly rise deletion data from lower to upper adjacencies to delete all the upper adjacencies that depend on deleted lower adjacencies </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a60274817b98e76ec5a411f0c3df2a76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60274817b98e76ec5a411f0c3df2a76b">&#9670;&nbsp;</a></span>ResolveModification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ResolveModification </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is not yet implemented. </p>
<p>It should correctly resolve parallel state of newly created elements, provide them valid global identificators, resolve owners of the elements potentially optimized using information from BridgeTag and LayersTag May use ResolveShared function as basis but instead the whole mesh run the same algorithm for subset. </p>

</div>
</div>
<a id="ac12ba58210b79c61e64a74c389cd11f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12ba58210b79c61e64a74c389cd11f6">&#9670;&nbsp;</a></span>Save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::Save </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>File</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acceptable file formats for writing. </p>
<ul>
<li>".vtk" - legacy vtk format for unstructured grid</li>
<li>".pvtk" - legacy parallel vtk format</li>
<li>".gmv" - format acceptable by general mesh viewer</li>
<li>".pmf" - internal parallel portable binary format, saves all features</li>
</ul>
<p>Remeber: .pmf stores all references to elements. If reference are broken due to mesh modification, saving or loading such a mesh may lead to segfault. To automatically maintain correct references modify mesh using BeginModification, ApplyModification, EndModification</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">File</td><td>path to the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000037">Todo:</a></b></dt><dd><ol type="1">
<li>Markers are not saved in internal format due to possible conflict during load. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a2e40d1712147e6dc39113d855882743e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e40d1712147e6dc39113d855882743e">&#9670;&nbsp;</a></span>SetData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::SetData </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy into inner data array of size elements from provided array beginning from shift element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of element </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
    <tr><td class="paramname">shift</td><td>for which element to start to copy </td></tr>
    <tr><td class="paramname">size</td><td>how many elements to copy </td></tr>
    <tr><td class="paramname">data</td><td>user-provided array where data should be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ade9beb68c97be47897b50ce6e4dcb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ade9beb68c97be47897b50ce6e4dcb6">&#9670;&nbsp;</a></span>SetDataSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::SetDataSize </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>new_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the size of the array for data of variable size. </p>
<p>If you try to change size of data of constant size then if size is different from current then in debug mode (NDEBUG not set) assertion will fail, in release mode nothing happens. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of element </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents the data </td></tr>
    <tr><td class="paramname">new_size</td><td>new size of the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04a2c4cb85d29a3f8bae803b013a52c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a2c4cb85d29a3f8bae803b013a52c9">&#9670;&nbsp;</a></span>SetDimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::SetDimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set number of dimensions for mesh. </p>
<p>It sets the size for number of internally stored coordinates. Size of the array returned by Node::Coords will match this number. When you change number of dimensions and there are nodes with bigger number of dimensions then first dim coordinates are copied and the rest are dropped. </p><dl class="section see"><dt>See also</dt><dd>Node::Coords </dd></dl>

</div>
</div>
<a id="a8ef41098a12fe80cac6f45ee94ef892b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef41098a12fe80cac6f45ee94ef892b">&#9670;&nbsp;</a></span>SetEpsilon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE void INMOST::Mesh::SetEpsilon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set tolerance for coordinates comparison. </p>
<p>This tolerance is used in comparators when two meshes are merged during loading, in ResolveShared to check that nodes on different processors match and in UnpackElementsData </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>small real value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07c75e9dee2c400225a6095e45489ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c75e9dee2c400225a6095e45489ac1">&#9670;&nbsp;</a></span>SetFileOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::SetFileOption </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set file option. </p>
<p>Current available file options:</p><ul>
<li>"VERBOSITY" - Set "2" for progress messages, "1" for reports, "0" for silence</li>
<li>"VTK_GRID_DIMS" - Set "2" for two-dimensional vtk grids, "3" for three-dimensional vtk grids or "AUTO" for automatic detection.</li>
<li>"VTK_OUTPUT_FACES" - Set "1" for vtk output of values on faces</li>
<li>"ECL_SPLIT_GLUED" - Set "TRUE" to triangulate faces of the blocks that degenerate on three pillars.</li>
<li>"ECL_PROJECT_PERM" - Set "TRUE" to project permeability tensor from grid block coordinates into global coordinates. Otherwise the tensor is considered to be defined on global coordinates. Default "FALSE".</li>
<li>"ECL_COMPUTE_TRAN" - compute and store transmissibilities on the faces using NEWTRAN approach in eclipse 100</li>
<li>"ECL_DEGENERATE" - In GRDECL format some active grid block may have zero volume, which means there is a fault. Set "TRUE" to introduce a gap between blocks that share degenerate active grid block, set to "TRANM" to introduce zero transmissibility multiplier and keep the grid connected and "FALSE" to simply keep the grid connected. Default: "TRUE".</li>
<li>"ECL_TOPOLOGY" - If "TRUE" checks topology of the grid for errors, this may provide useful warnings if layers of the mesh enter each other and the grid cannot be considered conformal. Default: "FALSE". "ECL_PARALLEL_READ"- If "TRUE" then each processor loads part of the eclipse mesh, requires some synchronization. Otherwise if "FALSE" then each processor loads entire mesh. Default: "TRUE". "KEEP_GHOST" - If options is set, the ghost elements are written into files. By default ghost elements are skipped. "Tag:TAGNAME" - Set comma-separated rules for tag with the name TAGNAME, the rules list is: nosave - do not save the tag data into files; noload - do not load the tag data from files; noderivatives - do not save/load the derivatives for data with type DATA_VARIABLE (for .xml and .pmf); loadonly - this creates an exclusive list for data to be loaded from files, all other tag names will be ignored; saveonly - this creates an exclusive list for data to be saved to files, all other tag names will be ignored. Example: mesh-&gt;SetFileOption("Tag:PressureGradient","noload,noderivatives"); the tag with the name PressureGradient will not be loaded from files and when recording the derivaives data will be not saved. </li>
</ul>

</div>
</div>
<a id="a56670d2eca32f6af4bdd9c18a160dc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56670d2eca32f6af4bdd9c18a160dc81">&#9670;&nbsp;</a></span>SetMarker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE void INMOST::Mesh::SetMarker </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a marker on the element represented by handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">n</td><td>stores byte number and byte bit mask that represent marker </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8df87a8d03de319611d696f1fed6acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8df87a8d03de319611d696f1fed6acf">&#9670;&nbsp;</a></span>SetMarkerArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE void INMOST::Mesh::SetMarkerArray </td>
          <td>(</td>
          <td class="paramtype">const HandleType *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a marker on the set of handles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>set of handles </td></tr>
    <tr><td class="paramname">n</td><td>number of handles </td></tr>
    <tr><td class="paramname">m</td><td>stores byte number and byte bit mask that represent marker </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a56670d2eca32f6af4bdd9c18a160dc81" title="Set a marker on the element represented by handle.">Mesh::SetMarker</a> </dd></dl>

</div>
</div>
<a id="aadcd74b16a7a86db78d2cf5bb814f5a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadcd74b16a7a86db78d2cf5bb814f5a3">&#9670;&nbsp;</a></span>SetMarkerSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::SetMarkerSpace </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a>&#160;</td>
          <td class="paramname"><em>source</em>[MarkerFields]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrite the bytes that store markers on the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">source</td><td>storage to get data from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e45b137719114d78119bfe487be259f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e45b137719114d78119bfe487be259f">&#9670;&nbsp;</a></span>SetParallelFileStrategy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::SetParallelFileStrategy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set parallel strategy for inner communications. </p>
<p>There are three possible scenarios in parallel communication associated in accordance to enum Prepare structure:</p><ol type="1">
<li>The communicating processors and sizes of the messages are known apriori</li>
<li>UnknownSize: Communicating processors are known but sizes are unknown</li>
<li>unknownSource: Communicationg processors are unknown</li>
</ol>
<p>Currently with UnknownSize it will run the following algorithm none for strategy 0, following for strategies 1 and 2:</p><ol type="1">
<li>Post asynchronous receive with MPI_Irecv of size of buffer to be sent</li>
<li>Post asynchronous send with MPI_Isend for required corresponding receive buffer size</li>
<li>Wait for all asynchronous operations by MPI_Waitall</li>
</ol>
<p>With UnknownSource there are two options depending from the USE_MPI_P2P define. If USE_MPI_P2P is defined then MPI-2 api operations will be used</p><ol type="1">
<li>MPI_Win_fence to start operations</li>
<li>MPI_Put from specially allocated memory location to remote processor of array size is performed</li>
<li>MPI_Win_fence to stop operations</li>
</ol>
<p>if USE_MPI_P2P not set then MPI-1 api will be used</p><ol type="1">
<li>MPI_Allgather for number of processors to which current processor wants to send data</li>
<li>MPI_Allgatherv for sizes and destinations for each processors</li>
</ol>
<p>Initially it was intended to mainly use MPI-2 functionality for both scenarios but it was realized that there is no available hardware on which MPI-2 functionality performs much better than MPI-1 counterparts, especially in the case of UnknownSize. Probably this happens due to lack of support of RDMA operations. If you believe it will be better to use MPI-2 in both cases you are free to uncomment definition of PREFFER_MPI_P2P in <a class="el" href="inmost__common_8h_source.html">inmost_common.h</a> then MPI-2 will be used in both scenarios. These algorithms above are implemented in Mesh::ExchangeBufferInner.</p>
<p>After first problem was resolved following strategies are available for main communication: strategy = 0</p><ol type="1">
<li>Asynchronous send of data by MPI_Isend;</li>
<li>Check incoming messages by MPI_Probe;</li>
<li>Check incoming message size by MPI_Get_size;</li>
<li>Allocation of buffers of required size;</li>
<li>Asynchronous receive of data</li>
<li>MPI_Waitsome to copy received results to buffers</li>
</ol>
<p>This strategy shows to be the fastest on mac with intel core 2 duo it appears to be independent of apriori knowledge of sizes of incoming messages and skips the step of determining sizes in all the cases but still it requires establishing knowledge of communicating processors Asynchronous sending and receiving may be performed by breaking the steps 1) and 2-5) but should be considered bad since it will be performed without appropriate receive buffers posted for sends, as a result messages will stuck in network pipeline and would be repeatedly rejected resulting in bad networking performance especially if processors have small memory. As a result non-asynchronous communication is implemented with this strategy breaking steps 1-5) and 6) when you ask for asynchronous communication strategy = 1</p><ol type="1">
<li>Post asynchronous receive of data by MPI_Irecv</li>
<li>Post asynchronous send of data by MPI_Isend</li>
<li>MPI_Waitsome for any received data</li>
</ol>
<p>True asynchronous behavior is reproduced by breaking 1-2) and 3) strategy = 2</p><ol type="1">
<li>Post asynchronous receive of data by MPI_Irecv</li>
<li>Set MPI_Barrier to ensure that all the receives were properly set by the time</li>
</ol>
<ol type="1">
<li>Perform direct send of data by MPI_Irsend</li>
<li>MPI_Waitsome for any received data</li>
</ol>
<p>For asynchronous communication algorithm is broken into 1-3) and 4) which is fairly asynchronous. The only provisional benefit it may have on machines with small memory since it should bypass any allocation of buffers for sent and received data by MPI and probably not perform any rendezvous communication to ensure data allocation. But MPI_Barrier looks like elephant here.</p>
<p>Algorithms above are implemented in Mesh::ExchangeBuffersInner </p><dl class="section see"><dt>See also</dt><dd>Mesh::PrepareReceiveInner </dd>
<dd>
Mesh::ExchangeBuffersInner Retrieve currently set parallel strategy. </dd>
<dd>
Mesh::SetParallelStrategy This strategy corresponds only to internal ".pmf" mesh format. There are two available strategies for ".pmf" files loading and saving:</dd></dl>
<p>strategy = 0</p><ul>
<li>on save<ol type="1">
<li>every processor gather local data to some buffer</li>
<li>MPI_Gather to obtain sizes of data among processors</li>
<li>MPI_Gatherv to obtain the whole data on zeros processor</li>
<li>the first processor writes all the data to disk by std::fstream</li>
</ol>
</li>
<li>on load<ol type="1">
<li>first processors reads the whole file by std::fstream</li>
<li>MPI_Scatter distributes block sizes among processors</li>
<li>MPI_Scatterv distributes blocks among processors</li>
<li>Each processor parses its block</li>
</ol>
</li>
</ul>
<p>This strategy requires one processor to hold all the data, which is quite bad for large files. New strategy may be created from this one in the future when each processors consequently obtain access to the file using std::fstream and writes the data.</p>
<p>strategy = 1</p><ul>
<li>on save it will perform:<ol type="1">
<li>MPI_Gather to obtain sizes of data among processors on zeroth processor</li>
<li>MPI_File_open to get parallel handle for the file</li>
<li>MPI_File_write_shared called by processor with zeroth rank to write header</li>
<li>MPI_File_write_ordered to write contents of individual data</li>
<li>MPI_File_close to close parallel file handle</li>
</ol>
</li>
<li><p class="startli">on load it will perform</p><ol type="1">
<li>MPI_File_open to open the file in parallel</li>
<li>MPI_File_read_shared to get contents of header on zeroth processor</li>
<li>MPI_Scatter to distribute block sizes among processors</li>
<li>MPI_File_read_ordered to obtain contents</li>
<li>MPI_File_close to close parallel file handle</li>
</ol>
<p class="startli">Availible only when USE_MPI_P2P is set because it rely on MPI-2 api that begins with MPI_File_xxx some MPI-1 standards contain this API as an extension.</p>
</li>
</ul>
<p>The strategy 1 appeared to be considerably slower on INM cluster than strategy 0, this may happen due to lack of read-write devices that able to work in parallel. On IBM Bluegene/p strategy 1 was not working due to same old problem with shared file pointers in their MPI realization </p>

</div>
</div>
<a id="a666201ee66a5a0f871d17781055b06ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666201ee66a5a0f871d17781055b06ac">&#9670;&nbsp;</a></span>SetStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::SetStatus </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Element::Status&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set parallel status of the element. </p>
<p>If mesh is in Serial state then call will fire asserts in debug mode and segfault in relese mode.</p>
<p>Parallel status controls how exchange of data between elements will be performed, it is expected that number of elements and copies of elements do match between processors. This kind of check is never performed and if you fail to setup statuses correctly, you may end up with data being copied to incorrect elements. If you modify statuses on your own don't forget to call RecomputeParallelStorage, otherwise exchange will be performed by old status guidelines. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of the element </td></tr>
    <tr><td class="paramname">s</td><td>new status of the element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bfe7b75e432280922bfa7293743115c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bfe7b75e432280922bfa7293743115c">&#9670;&nbsp;</a></span>Show()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool INMOST::Mesh::Show </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Show element from mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true then element was recovered </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a2b3eaaadcd233cf11deba24d1fd64ad1" title="Hide element from mesh.">Mesh::Hide</a> </dd></dl>

</div>
</div>
<a id="a9f8cfa72de874bd9a17fb0067ac8d515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8cfa72de874bd9a17fb0067ac8d515">&#9670;&nbsp;</a></span>SortByGlobalID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::SortByGlobalID </td>
          <td>(</td>
          <td class="paramtype">HandleType *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000041">Todo:</a></b></dt><dd>TODO 53 check that putting global ids to array will be faster </dd></dl>

</div>
</div>
<a id="a3e47aee230b989eacc29fbfe6edfe305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e47aee230b989eacc29fbfe6edfe305">&#9670;&nbsp;</a></span>SortParallelStorage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::SortParallelStorage </td>
          <td>(</td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort parallel storage. </p>
<p>Parallel storage is sorted according to global identificators or centroids of elements if global identificators are not available. If you manually change global identificators or if global identificators are not available and coordinates of nodes change, then you should invoke this function. You can check presence of global identificators on single type of elements using function <a class="el" href="classINMOST_1_1Mesh.html#a1d9d87c22843c13e650befe095817230" title="Test whether global identificator was set on certain type of elements.">Mesh::HaveGlobalID</a>. This function is called automatically inside <a class="el" href="classINMOST_1_1Mesh.html#ae39e30b11f35de81d2a9b8451ef87391" title="Assign unique numbers to elements.">Mesh::AssignGlobalID</a>. No action will be performed if USE_PARALLEL_STORAGE is not set in <a class="el" href="inmost__common_8h_source.html">inmost_common.h</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Bitwise mask of element types for which to sort the parallel storage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c3acf2a90e25699a64e1f7b4125eaf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3acf2a90e25699a64e1f7b4125eaf7">&#9670;&nbsp;</a></span>SynchronizeElementType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ElementType INMOST::Mesh::SynchronizeElementType </td>
          <td>(</td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>etype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize bitwise mask of element types between processors. </p>
<p>Collective operation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">etype</td><td>bitwise type mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bitwise result among processors </dd></dl>

</div>
</div>
<a id="a8c7a825072f54b260caa0e8da8877647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7a825072f54b260caa0e8da8877647">&#9670;&nbsp;</a></span>SynchronizeMarker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::SynchronizeMarker </td>
          <td>(</td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SyncBitOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize marker on elements between processors using provided operation. </p>
<p>Depending on requested operation following action is performed:</p><ul>
<li>SYNC_BIT_SET - value on ghost elements is set by value on corresponding shared processors;</li>
<li>SYNC_BIT_OR - bitwise OR between values in ghost and shared elements;</li>
<li>SYNC_BIT_AND - bitwise AND between values in ghost and shared elements;</li>
<li>SYNC_BIT_XOR - bitwise XOR between values in ghost and shared elements. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">marker</td><td>marker to be synchronized </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or type mask </td></tr>
    <tr><td class="paramname">op</td><td>operation, one of SYNC_BIT_SET, SYNC_BIT_OR, SYNC_BIT_XOR, SYNC_BIT_AND </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="ab6a87be01328bed5563d7131b7c2bcec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a87be01328bed5563d7131b7c2bcec">&#9670;&nbsp;</a></span>TagOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;std::string&gt; INMOST::Mesh::TagOptions </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect file options related to records <a class="el" href="classINMOST_1_1Tag.html" title="This class provides the access to the individual mesh datum and general information about it.">Tag</a>:TAGNAME. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">given</td><td>option name, such as nosave, noload, noderivatives, loadonly, saveonly </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a set of tags that has given option </dd></dl>

</div>
</div>
<a id="af93dcc86ea21e59c9f32e61b901fcffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93dcc86ea21e59c9f32e61b901fcffa">&#9670;&nbsp;</a></span>TopologyErrorTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Tag.html">Tag</a> INMOST::Mesh::TopologyErrorTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This will return tag by which you can retrieve error mark to any element on which topology check failed. </p>
<p>As this is sparse tag you can check presence of error by <a class="el" href="classINMOST_1_1Storage.html#aec013f00d5c7947a1a8542859821c06c" title="Check if any data is associated with Tag.">Element::HaveData</a> or <a class="el" href="classINMOST_1_1Mesh.html#a77f07de278c0d245577192b66b809118" title="Check whether data is present on given element.">Mesh::HaveData</a> check. This tag will be valid only if you pass MARK_ON_ERROR to <a class="el" href="classINMOST_1_1Mesh.html#a6a8779484218dd10a3752a6d71e83baf" title="Retrieve currently set topology checks.">Mesh::GetTopologyCheck</a> and will be deleted if you pass MARK_ON_ERROR to <a class="el" href="classINMOST_1_1Mesh.html#a374a56ae3bdae9e54030c72538836c09" title="Remove topology checks.">Mesh::RemTopologyCheck</a> </p>

</div>
</div>
<a id="acc118e878e2cce11985e7384f18700fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc118e878e2cce11985e7384f18700fa">&#9670;&nbsp;</a></span>TotalNumberOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> INMOST::Mesh::TotalNumberOf </td>
          <td>(</td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum of all physical elements, it excludes ghost copies. </p>
<p>To compute total number including ghost copies run Integrate(NumberOf(mask))</p>
<p>Collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>bitwise mask of element types, example: NODE | CELL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum of elements </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Mesh::NumberOf </dd></dl>

</div>
</div>
<a id="a55554909d705c0084077dbaf9c49c509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55554909d705c0084077dbaf9c49c509">&#9670;&nbsp;</a></span>WachspressInterpolation2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::WachspressInterpolation2D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Face.html">Face</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; HandleType, <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes_stencil</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute node-centered interpolation on 2d face for point. </p>
<p>Point should be inside face or on its boundary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Interpolation point </td></tr>
    <tr><td class="paramname">f</td><td><a class="el" href="classINMOST_1_1Face.html" title="An interface for elements of type FACE.">Face</a> (should be 2d) which contains point </td></tr>
    <tr><td class="paramname">nodes_stencil</td><td>Vector of pairs (node handle, coefficient) to store interpolation data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad00c3c0062cb8b87e5f5a9e61d03a9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00c3c0062cb8b87e5f5a9e61d03a9de">&#9670;&nbsp;</a></span>WachspressInterpolation3D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::WachspressInterpolation3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Cell.html">Cell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; HandleType, <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes_stencil</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute node-centered interpolation on 3d cell for point Point should be inside cell or on its boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Interpolation point </td></tr>
    <tr><td class="paramname">c</td><td><a class="el" href="classINMOST_1_1Cell.html" title="An interface for elements of type CELL.">Cell</a> (should be 3d) which contains point </td></tr>
    <tr><td class="paramname">nodes_stencil</td><td>Vector of pairs (node handle, coefficient) to store interpolation data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="inmost__mesh_8h_source.html">inmost_mesh.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 14 2023 19:52:29 for INMOST by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.1
</small></address>
</body>
</html>
